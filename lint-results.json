
> schach9x9@1.0.0 lint
> eslint . --format json

[{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/jest.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/ai-worker.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'depth' is assigned a value but never used.","line":51,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":51,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Web Worker for Chess 9x9 AI Calculations\n * Prevents UI freezing during minimax search\n */\n\nimport { logger } from './logger.js';\nimport { getBestMove, evaluatePosition, setOpeningBook, setProgressCallback, getAllLegalMoves } from './aiEngine.js';\n\n// Helper to get moves from board (wrapper for consistency)\nfunction getAllLegalMovesFromBoard(board, color) {\n  return getAllLegalMoves(board, color);\n}\n\n// Main message handler\nself.onmessage = function (e) {\n  try {\n    const { type, data } = e.data;\n\n    switch (type) {\n    case 'loadBook': {\n      if (!data || !data.book) {\n        logger.warn('[AI Worker] loadBook called without book data');\n        break;\n      }\n      setOpeningBook(data.book);\n      logger.info('[AI Worker] Opening book loaded:', data.book.metadata);\n      break;\n    }\n\n    case 'getBestMove': {\n      const { board, color, depth, difficulty, moveNumber } = data;\n\n      // Setup progress callback\n      setProgressCallback(progress => {\n        self.postMessage({ type: 'progress', data: progress });\n      });\n\n      const bestMove = getBestMove(board, color, depth, difficulty, moveNumber);\n      self.postMessage({ type: 'bestMove', data: bestMove });\n      break;\n    }\n\n    case 'evaluatePosition': {\n      const { board: evalBoard, forColor } = data;\n      const score = evaluatePosition(evalBoard, forColor);\n      self.postMessage({ type: 'positionScore', data: score });\n      break;\n    }\n\n    case 'analyze': {\n      const { board, color, depth, topMovesCount = 5 } = data;\n\n      // Get position evaluation\n      const score = evaluatePosition(board, color);\n\n      // Get all legal moves and evaluate each\n      const allMoves = getAllLegalMovesFromBoard(board, color);\n\n      // Evaluate each move\n      const movesWithScores = allMoves.map(move => {\n        const fromPiece = board[move.from.r][move.from.c];\n        const targetPiece = board[move.to.r][move.to.c];\n\n        // Simulate move\n        board[move.to.r][move.to.c] = fromPiece;\n        board[move.from.r][move.from.c] = null;\n\n        // Evaluate resulting position\n        const moveScore = evaluatePosition(board, color);\n\n        // Undo move\n        board[move.from.r][move.from.c] = fromPiece;\n        board[move.to.r][move.to.c] = targetPiece;\n\n        return {\n          from: move.from,\n          to: move.to,\n          score: moveScore\n        };\n      });\n\n      // Sort moves by score (descending for current player)\n      movesWithScores.sort((a, b) => b.score - a.score);\n\n      // Get top N moves\n      const topMoves = movesWithScores.slice(0, topMovesCount);\n\n      self.postMessage({\n        type: 'analysis',\n        data: {\n          score,\n          topMoves\n        }\n      });\n      break;\n    }\n\n    default: {\n      logger.warn('Unknown message type:', type);\n    }\n    }\n  } catch (error) {\n    logger.error('[AI Worker] Error handling message:', error);\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/aiController.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/aiEngine.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'clearKillerMoves' is defined but never used.","line":174,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":174,"endColumn":26},{"ruleId":"no-unused-vars","severity":1,"message":"'clearHistory' is defined but never used.","line":178,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":178,"endColumn":22},{"ruleId":"no-constant-condition","severity":2,"message":"Unexpected constant condition.","line":561,"column":14,"nodeType":"Literal","messageId":"unexpected","endLine":561,"endColumn":18},{"ruleId":"no-unused-vars","severity":1,"message":"'undoStack' is assigned a value but never used.","line":675,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":675,"endColumn":16},{"ruleId":"no-unused-vars","severity":1,"message":"'materialCount' is assigned a value but never used.","line":993,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":993,"endColumn":22},{"ruleId":"no-unused-vars","severity":1,"message":"'ATTACK_DIRECTIONS' is assigned a value but never used.","line":1299,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":1299,"endColumn":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Core AI Logic for Schach 9x9\n * Extracted from ai-worker.js for better testing and modularity\n */\n\nimport { logger } from './logger.js';\nimport { BOARD_SIZE, AI_PIECE_VALUES as PIECE_VALUES } from './config.js';\n\n// Position bonus tables (simplified, center control)\n// Piece-Square Tables (PST) for 9x9 board.\n// Values are from White's perspective. For Black, rows are mirrored.\nconst PST = {\n  // Pawn: wants to advance, middle ones more\n  p: [\n    0, 0, 0, 0, 0, 0, 0, 0, 0,\n    50, 50, 50, 50, 50, 50, 50, 50, 50,\n    10, 10, 20, 30, 30, 30, 20, 10, 10,\n    5, 5, 10, 25, 25, 25, 10, 5, 5,\n    0, 0, 0, 20, 25, 20, 0, 0, 0,\n    5, -5, -10, 0, 10, 0, -10, -5, 5,\n    5, 10, 10, -20, -20, -20, 10, 10, 5,\n    0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0\n  ],\n  // Knight: dislikes edges\n  n: [\n    -50, -40, -30, -30, -30, -30, -30, -40, -50,\n    -40, -20, 0, 0, 0, 0, 0, -20, -40,\n    -30, 0, 10, 15, 15, 15, 10, 0, -30,\n    -30, 5, 15, 20, 20, 20, 15, 5, -30,\n    -30, 0, 15, 20, 25, 20, 15, 0, -30,\n    -30, 5, 15, 20, 20, 20, 15, 5, -30,\n    -30, 0, 10, 15, 15, 15, 10, 0, -30,\n    -40, -20, 0, 5, 5, 5, 0, -20, -40,\n    -50, -40, -30, -30, -30, -30, -30, -40, -50\n  ],\n  // Bishop: center control\n  b: [\n    -20, -10, -10, -10, -10, -10, -10, -10, -20,\n    -10, 0, 0, 0, 0, 0, 0, 0, -10,\n    -10, 0, 5, 10, 10, 10, 5, 0, -10,\n    -10, 5, 5, 10, 10, 10, 5, 5, -10,\n    -10, 0, 10, 10, 15, 10, 10, 0, -10,\n    -10, 10, 10, 10, 10, 10, 10, 10, -10,\n    -10, 5, 0, 0, 0, 0, 0, 5, -10,\n    -10, 0, 0, 0, 0, 0, 0, 0, -10,\n    -20, -10, -10, -10, -10, -10, -10, -10, -20\n  ],\n  // Rook: 7th/8th rank\n  r: [\n    0, 0, 0, 0, 0, 0, 0, 0, 0,\n    5, 10, 10, 10, 10, 10, 10, 10, 5,\n    -5, 0, 0, 0, 0, 0, 0, 0, -5,\n    -5, 0, 0, 0, 0, 0, 0, 0, -5,\n    -5, 0, 0, 0, 0, 0, 0, 0, -5,\n    -5, 0, 0, 0, 0, 0, 0, 0, -5,\n    -5, 0, 0, 0, 0, 0, 0, 0, -5,\n    0, 0, 0, 5, 5, 5, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0\n  ],\n  // Queen: center\n  q: [\n    -20, -10, -10, -5, -5, -5, -10, -10, -20,\n    -10, 0, 0, 0, 0, 0, 0, 0, -10,\n    -10, 0, 5, 5, 5, 5, 5, 0, -10,\n    -5, 0, 5, 5, 5, 5, 5, 0, -5,\n    0, 0, 5, 5, 5, 5, 5, 0, -5,\n    -5, 0, 5, 5, 5, 5, 5, 0, -5,\n    -10, 0, 5, 5, 5, 5, 5, 0, -10,\n    -10, 0, 0, 0, 0, 0, 0, 0, -10,\n    -20, -10, -10, -5, -5, -5, -10, -10, -20\n  ],\n  // King: safety\n  k: [\n    -30, -40, -40, -50, -50, -50, -40, -40, -30,\n    -30, -40, -40, -50, -50, -50, -40, -40, -30,\n    -30, -40, -40, -50, -50, -50, -40, -40, -30,\n    -30, -40, -40, -50, -50, -50, -40, -40, -30,\n    -30, -40, -40, -50, -50, -50, -40, -40, -30,\n    -30, -40, -40, -50, -50, -50, -40, -40, -30,\n    -20, -30, -30, -40, -40, -40, -30, -30, -20,\n    20, 20, 0, 0, 0, 0, 0, 20, 20,\n    20, 30, 10, 0, 0, 0, 10, 30, 20\n  ],\n  // Archbishop (Bishop + Knight)\n  a: [\n    -20, -15, -10, -10, -10, -10, -10, -15, -20,\n    -15, -5, 0, 0, 0, 0, 0, -5, -15,\n    -10, 0, 10, 15, 15, 15, 10, 0, -10,\n    -10, 5, 15, 20, 20, 20, 15, 5, -10,\n    -10, 0, 15, 20, 25, 20, 15, 0, -10,\n    -10, 5, 15, 20, 20, 20, 15, 5, -10,\n    -10, 0, 10, 15, 15, 15, 10, 0, -10,\n    -15, -5, 0, 5, 5, 5, 0, -5, -15,\n    -20, -15, -10, -10, -10, -10, -10, -15, -20\n  ],\n  // Chancellor (Rook + Knight)\n  c: [\n    -10, -5, 0, 5, 5, 5, 0, -5, -10,\n    -5, 5, 10, 10, 10, 10, 10, 5, -5,\n    0, 10, 15, 20, 20, 20, 15, 10, 0,\n    5, 10, 20, 25, 25, 25, 20, 10, 5,\n    5, 10, 20, 25, 30, 25, 20, 10, 5,\n    5, 10, 20, 25, 25, 25, 20, 10, 5,\n    0, 10, 15, 20, 20, 20, 15, 10, 0,\n    -5, 5, 10, 10, 10, 10, 10, 5, -5,\n    -10, -5, 0, 5, 5, 5, 0, -5, -10\n  ],\n  // Angel (Queen + Knight)\n  e: [\n    -20, -15, -10, -10, -10, -10, -10, -15, -20,\n    -15, 0, 5, 10, 10, 10, 5, 0, -15,\n    -10, 5, 15, 20, 20, 20, 15, 5, -10,\n    -10, 10, 20, 30, 30, 30, 20, 10, -10,\n    -10, 10, 20, 30, 40, 30, 20, 10, -10,\n    -10, 10, 20, 30, 30, 30, 20, 10, -10,\n    -10, 5, 15, 20, 20, 20, 15, 5, -10,\n    -15, 0, 5, 10, 10, 10, 5, 0, -15,\n    -20, -15, -10, -10, -10, -10, -10, -15, -20\n  ]\n};\n\n// Endgame Piece-Square Tables (PST)\nconst PST_EG = {\n  k: [\n    -50, -40, -30, -20, -20, -20, -30, -40, -50,\n    -30, -20, -10, 0, 0, 0, -10, -20, -30,\n    -30, -10, 10, 20, 20, 20, 10, -10, -30,\n    -30, 0, 20, 30, 30, 30, 20, 0, -30,\n    -30, 0, 20, 30, 40, 30, 20, 0, -30,\n    -30, 0, 20, 30, 30, 30, 20, 0, -30,\n    -30, -10, 10, 20, 20, 20, 10, -10, -30,\n    -30, -20, -10, 0, 0, 0, -10, -20, -30,\n    -50, -40, -30, -20, -20, -20, -30, -40, -50\n  ]\n};\n\n// ========================================\n// TRANSPOSITION TABLE & ZOBRIST HASHING\n// ========================================\n\n// Zobrist random numbers for hashing\n// Initialize Zobrist hashing table\nconst zobristTable = initializeZobrist();\n\n// Killer Moves: Moves that caused beta cutoffs at each depth\n// Format: killerMoves[depth] = [move1, move2]\nconst killerMoves = new Map();\nconst MAX_KILLER_MOVES = 2; // Store top 2 killer moves per depth\n\n// History Heuristic: Track which moves have been good historically\n// Format: historyTable[piece.type][ from.r][from.c][to.r][to.c] = score\nconst historyTable = {};\n\n// Initialize history table\nfunction initHistoryTable() {\n  const types = ['p', 'n', 'b', 'r', 'q', 'k', 'a', 'c', 'e'];\n  for (const type of types) {\n    historyTable[type] = [];\n    for (let fr = 0; fr < BOARD_SIZE; fr++) {\n      historyTable[type][fr] = [];\n      for (let fc = 0; fc < BOARD_SIZE; fc++) {\n        historyTable[type][fr][fc] = [];\n        for (let tr = 0; tr < BOARD_SIZE; tr++) {\n          historyTable[type][fr][fc][tr] = new Array(BOARD_SIZE).fill(0);\n        }\n      }\n    }\n  }\n}\ninitHistoryTable();\n\n// Clear killer moves and history (between moves)\nfunction clearKillerMoves() {\n  killerMoves.clear();\n}\n\nfunction clearHistory() {\n  initHistoryTable();\n}\n\n// Transposition Table (cache for evaluated positions)\nconst transpositionTable = new Map();\nlet TT_MAX_SIZE = 100000; // Maximum entries to prevent memory overflow\nlet ttHits = 0;\nlet ttMisses = 0;\n\nexport function getTTSize() {\n  return transpositionTable.size;\n}\n\nexport function setTTMaxSize(size) {\n  TT_MAX_SIZE = size;\n}\n\nexport function clearTT() {\n  transpositionTable.clear();\n}\n\n// Export for testing\nexport function testStoreTT(hash, depth, score, flag, bestMove) {\n  storeTT(hash, depth, score, flag, bestMove);\n}\n\nexport function testProbeTT(hash, depth, alpha, beta) {\n  return probeTT(hash, depth, alpha, beta);\n}\n\n// TT Entry types\nconst TT_EXACT = 0; // Exact score\nconst TT_ALPHA = 1; // Upper bound (fail-low)\nconst TT_BETA = 2; // Lower bound (fail-high)\n\n/**\n * Add a killer move for a specific depth\n */\nfunction addKillerMove(depth, move) {\n  if (!killerMoves.has(depth)) {\n    killerMoves.set(depth, []);\n  }\n\n  const killers = killerMoves.get(depth);\n\n  // Check if move already exists in killers\n  const exists = killers.some(\n    k =>\n      k &&\n      k.from.r === move.from.r &&\n      k.from.c === move.from.c &&\n      k.to.r === move.to.r &&\n      k.to.c === move.to.c\n  );\n\n  if (!exists) {\n    // Add to front and keep only top MAX_KILLER_MOVES\n    killers.unshift(move);\n    if (killers.length > MAX_KILLER_MOVES) {\n      killers.pop();\n    }\n  }\n}\n\n/**\n * Update history heuristic for a good move\n */\nfunction updateHistory(piece, move, depth) {\n  if (!piece || !historyTable[piece.type]) return;\n\n  // Increase history score based on depth (deeper = more valuable)\n  const bonus = depth * depth; // Quadratic bonus\n  historyTable[piece.type][move.from.r][move.from.c][move.to.r][move.to.c] += bonus;\n\n  // Cap history values to prevent overflow\n  const maxHistory = 10000;\n  if (historyTable[piece.type][move.from.r][move.from.c][move.to.r][move.to.c] > maxHistory) {\n    historyTable[piece.type][move.from.r][move.from.c][move.to.r][move.to.c] = maxHistory;\n  }\n}\n\n\n/**\n * Initialize Zobrist hashing table\n * Each piece type, color, and position gets a random 32-bit number\n */\nfunction initializeZobrist() {\n  const table = {};\n  const pieceTypes = ['p', 'n', 'b', 'r', 'q', 'k', 'a', 'c', 'e'];\n  const colors = ['white', 'black'];\n\n  // Simple pseudo-random number generator (seeded for consistency)\n  let seed = 12345;\n  const random = () => {\n    seed = (seed * 9301 + 49297) % 233280;\n    return seed / 233280;\n  };\n\n  for (const color of colors) {\n    table[color] = {};\n    for (const type of pieceTypes) {\n      table[color][type] = [];\n      for (let r = 0; r < BOARD_SIZE; r++) {\n        table[color][type][r] = [];\n        for (let c = 0; c < BOARD_SIZE; c++) {\n          // Generate random 32-bit integer\n          table[color][type][r][c] = Math.floor(random() * 0xffffffff);\n        }\n      }\n    }\n  }\n\n  // Side to move (white/black)\n  table.sideToMove = Math.floor(random() * 0xffffffff);\n\n  return table;\n}\n\n/**\n * Compute Zobrist hash for a board position\n */\nexport function computeZobristHash(board, colorToMove) {\n  let hash = 0;\n\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const piece = board[r][c];\n      if (piece) {\n        hash ^= zobristTable[piece.color][piece.type][r][c];\n      }\n    }\n  }\n\n  // Include side to move\n  if (colorToMove === 'white') {\n    hash ^= zobristTable.sideToMove;\n  }\n\n  return hash;\n}\n\n/**\n * Store position in transposition table\n */\nfunction storeTT(hash, depth, score, flag, bestMove) {\n  const existing = transpositionTable.get(hash);\n\n  // Depth-preferred replacement: only replace if the new entry is searched at least as deep\n  if (existing && existing.depth > depth) {\n    // We could potentially update the bestMove even if shallower, but usually deeper is better\n    return;\n  }\n\n  // Clear oldest entry if table is full (LRU eviction via Map insertion order)\n  if (!existing && transpositionTable.size >= TT_MAX_SIZE) {\n    const oldestKey = transpositionTable.keys().next().value;\n    transpositionTable.delete(oldestKey);\n  }\n\n  // Update entry (re-setting moves it to MRU position in Map)\n  if (existing) {\n    transpositionTable.delete(hash);\n  }\n\n  transpositionTable.set(hash, {\n    depth,\n    score,\n    flag,\n    bestMove,\n  });\n}\n\n/**\n * Probe transposition table\n */\nfunction probeTT(hash, depth, alpha, beta) {\n  const entry = transpositionTable.get(hash);\n\n  if (!entry) {\n    ttMisses++;\n    return null;\n  }\n\n  // Update entry position to MRU\n  transpositionTable.delete(hash);\n  transpositionTable.set(hash, entry);\n\n  ttHits++;\n\n  // Always return the bestMove found so far as a hint for move ordering,\n  // even if the depth is insufficient for a score cutoff.\n  const result = { bestMove: entry.bestMove };\n\n  // Only use score if it was searched to at least the same depth\n  if (entry.depth >= depth) {\n    if (entry.flag === TT_EXACT) {\n      result.score = entry.score;\n    } else if (entry.flag === TT_ALPHA && entry.score <= alpha) {\n      result.score = alpha;\n    } else if (entry.flag === TT_BETA && entry.score >= beta) {\n      result.score = beta;\n    }\n  }\n\n  return result;\n}\n\n// Progress tracking\nlet nodesEvaluated = 0;\nlet currentDepth = 0;\nlet bestMoveSoFar = null;\nlet lastProgressUpdate = 0;\nlet onProgressCallback = null;\n\nexport function setProgressCallback(callback) {\n  onProgressCallback = callback;\n}\n\n// ========================================\n// OPENING BOOK\n// ========================================\n\n// Opening book (loaded from main thread)\nlet openingBook = null;\n\nexport function setOpeningBook(book) {\n  openingBook = book;\n}\n\n/**\n * Query opening book for a move\n * Returns a move or null if position not in book\n */\nfunction queryOpeningBook(board, moveNumber) {\n  if (!openingBook || !openingBook.positions) {\n    return null;\n  }\n\n  // Only use book for first 10 moves\n  if (moveNumber >= 10) {\n    return null;\n  }\n\n  const hash = getBoardStringHash(board, moveNumber % 2 === 0 ? 'white' : 'black');\n\n  if (!openingBook.positions[hash]) {\n    return null;\n  }\n\n  const position = openingBook.positions[hash];\n  const moves = position.moves;\n\n  if (!moves || moves.length === 0) {\n    return null;\n  }\n\n  // Weighted random selection\n  const totalWeight = moves.reduce((sum, m) => sum + m.weight, 0);\n  let random = Math.random() * totalWeight;\n\n  for (const move of moves) {\n    random -= move.weight;\n    if (random <= 0) {\n      logger.debug(\n        `[Opening Book] Selected: ${move.from.r},${move.from.c} -> ${move.to.r},${move.to.c} (${move.weight}%)`\n      );\n      return { from: move.from, to: move.to };\n    }\n  }\n\n  // Fallback to first move\n  return { from: moves[0].from, to: moves[0].to };\n}\n\n/**\n * Generate a simple string hash for the board (must match trainer)\n */\nfunction getBoardStringHash(board, turn) {\n  let hash = '';\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const piece = board[r][c];\n      hash += piece ? `${piece.color[0]}${piece.type}` : '..';\n    }\n  }\n  hash += turn[0];\n  return hash;\n}\n\n/**\n * Get best move using minimax algorithm with iterative deepening\n */\nexport function getBestMove(board, color, depth, difficulty, moveNumber = 0) {\n  try {\n    // Check opening book first (only for first 8 moves)\n    const bookMove = queryOpeningBook(board, moveNumber);\n    if (bookMove) {\n      return bookMove;\n    }\n    // Reset progress tracking\n    nodesEvaluated = 0;\n    currentDepth = 0;\n    bestMoveSoFar = null;\n    lastProgressUpdate = Date.now();\n\n    const moves = getAllLegalMoves(board, color);\n\n    if (moves.length === 0) {\n      return null;\n    }\n\n    // Difficulty-based behavior\n    if (difficulty === 'beginner') {\n      // Beginner: Very weak, makes many random moves and occasional blunders\n      const randomChance = Math.random();\n\n      if (randomChance < 0.85) {\n        // 85% completely random move\n        return moves[Math.floor(Math.random() * moves.length)];\n      } else if (randomChance < 0.95) {\n        // 10% chance to deliberately pick a worse move (blunder)\n        // Evaluate all moves and pick one with lower score\n        const scoredMoves = moves.map(move => ({\n          move,\n          score: Math.random() - 0.5 // Random score to add variation\n        }));\n        // Sort by score ascending (worse moves first)\n        scoredMoves.sort((a, b) => a.score - b.score);\n        // Pick from bottom 30% of moves\n        const worstMoves = scoredMoves.slice(0, Math.max(1, Math.floor(moves.length * 0.3)));\n        return worstMoves[Math.floor(Math.random() * worstMoves.length)].move;\n      }\n      // Only 5% use shallow search (depth 1)\n      depth = 1;\n    } else if (difficulty === 'easy') {\n      // Easy: Random with strong capture preference, depth 2\n      const captures = moves.filter(\n        m => board[m.to.r][m.to.c] && board[m.to.r][m.to.c].color !== color\n      );\n      if (captures.length > 0 && Math.random() > 0.3) {\n        return captures[Math.floor(Math.random() * captures.length)];\n      }\n      depth = 2;\n    }\n\n    // For medium and above: Use iterative deepening\n    let bestMove = moves[0];\n    bestMoveSoFar = bestMove;\n\n    // Iterative deepening: search from depth 1 up to target depth\n    const useIterativeDeepening = difficulty === 'hard' || difficulty === 'expert';\n    const startDepth = useIterativeDeepening ? 1 : depth;\n    let previousIterationScore = 0;\n\n    for (let currentSearchDepth = startDepth; currentSearchDepth <= depth; currentSearchDepth++) {\n      currentDepth = currentSearchDepth;\n\n      let bestScore = -Infinity;\n      let iterationBestMove = moves[0];\n\n      // Send progress info\n      sendProgress(depth);\n\n      // Order moves (TT best move is not available at root, so pass null first iteration)\n      // But use previous iteration's best move for subsequent iterations\n      const ttBestMove = currentSearchDepth > startDepth ? bestMove : null;\n      const orderedMoves = orderMoves(board, moves, ttBestMove);\n\n      // Compute initial hash for the root position\n      const rootHash = computeZobristHash(board, color);\n\n      let alpha = -Infinity;\n      let beta = Infinity;\n\n      // ASPIRATION WINDOWS\n      let windowSize = 40;\n      if (currentSearchDepth > startDepth && Math.abs(previousIterationScore) < 5000) {\n        alpha = previousIterationScore - windowSize;\n        beta = previousIterationScore + windowSize;\n      }\n\n      // Root Search Loop\n      while (true) {\n        let currentAlpha = alpha;\n        let currentBestScore = -Infinity;\n        let currentBestMove = moves[0];\n\n        for (let i = 0; i < orderedMoves.length; i++) {\n          const move = orderedMoves[i];\n          let score;\n\n          if (i === 0) {\n            // Full window search for first move (PV candidate)\n            score = minimax(board, move, currentSearchDepth - 1, false, currentAlpha, beta, color, rootHash);\n          } else {\n            // Null window search for moves after PV candidate\n            score = minimax(board, move, currentSearchDepth - 1, false, currentAlpha, currentAlpha + 1, color, rootHash);\n            if (score > currentAlpha && score < beta) {\n              // Re-search with full window if it fails high\n              score = minimax(board, move, currentSearchDepth - 1, false, currentAlpha, beta, color, rootHash);\n            }\n          }\n\n          if (score > currentBestScore) {\n            currentBestScore = score;\n            currentBestMove = move;\n          }\n          if (score > currentAlpha) {\n            currentAlpha = score;\n          }\n\n          // If current score beats beta, we fail high early\n          if (score >= beta) break;\n        }\n\n        // Fail Low: Expand window downwards\n        if (currentBestScore <= alpha) {\n          alpha -= windowSize;\n          windowSize *= 2;\n          continue;\n        }\n        // Fail High: Expand window upwards\n        if (currentBestScore >= beta) {\n          beta += windowSize;\n          windowSize *= 2;\n          continue;\n        }\n\n        // Within window\n        bestScore = currentBestScore;\n        iterationBestMove = currentBestMove;\n        break;\n      }\n\n      previousIterationScore = bestScore;\n\n      // Update best move found so far\n      bestMove = iterationBestMove;\n      bestMoveSoFar = bestMove;\n\n      // Send progress update after completing this depth\n      sendProgress(depth);\n    }\n\n    // Log TT statistics\n    const ttTotal = ttHits + ttMisses;\n    const hitRate = ttTotal > 0 ? ((ttHits / ttTotal) * 100).toFixed(1) : 0;\n    logger.info(\n      `[AI Worker] TT Hit Rate: ${hitRate}% (${ttHits}/${ttTotal}), Nodes: ${nodesEvaluated}`\n    );\n\n    // Strip the score property used for move ordering before returning\n    if (bestMove && bestMove._score !== undefined) {\n      delete bestMove._score;\n    }\n\n    return bestMove;\n  } catch (error) {\n    logger.error('[AI Worker] Error in getBestMove:', error);\n    // Fallback: return a random legal move\n    const moves = getAllLegalMoves(board, color);\n    if (moves.length > 0) {\n      const move = moves[Math.floor(Math.random() * moves.length)];\n      if (move._score !== undefined) delete move._score;\n      return move;\n    }\n    return null;\n  }\n}\n\n/**\n * Send progress update to main thread\n */\nfunction sendProgress(maxDepth) {\n  if (!onProgressCallback) return;\n\n  const now = Date.now();\n  // Throttle updates to every 100ms\n  if (now - lastProgressUpdate < 100) return;\n\n  lastProgressUpdate = now;\n  onProgressCallback({\n    depth: currentDepth,\n    maxDepth: maxDepth,\n    nodes: nodesEvaluated,\n    bestMove: bestMoveSoFar,\n  });\n}\n\n/**\n * Minimax algorithm with alpha-beta pruning and transposition table\n */\n/**\n * Apply a move to the board and return undo information\n */\nconst MAX_PLY = 64; // Max depth\nconst undoStack = new Array(MAX_PLY).fill(null).map(() => ({\n  capturedPiece: null,\n  oldHasMoved: false,\n  move: null\n}));\n\n/**\n * Apply a move to the board and return undo information\n */\n/**\n * Apply a move to the board and return undo information\n */\nfunction makeMove(board, move) {\n  if (move === null) return null;\n\n  const fromPiece = board[move.from.r][move.from.c];\n  const capturedPiece = board[move.to.r][move.to.c];\n\n  const undoInfo = {\n    capturedPiece,\n    oldHasMoved: fromPiece ? fromPiece.hasMoved : false,\n    move\n  };\n\n  board[move.to.r][move.to.c] = fromPiece;\n  board[move.from.r][move.from.c] = null;\n\n  if (fromPiece) {\n    fromPiece.hasMoved = true;\n  }\n\n  return undoInfo;\n}\n\n/**\n * Undo a move\n */\nfunction undoMove(board, undoInfo) {\n  if (undoInfo === null) return;\n\n  const { move, capturedPiece, oldHasMoved } = undoInfo;\n  const piece = board[move.to.r][move.to.c];\n\n  if (piece) {\n    piece.hasMoved = oldHasMoved;\n  }\n\n  board[move.from.r][move.from.c] = piece;\n  board[move.to.r][move.to.c] = capturedPiece;\n}\n\n/**\n * Check if the side has major pieces (to avoid Zugzwang in endgames)\n */\nfunction hasMajorPieces(board, color) {\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const piece = board[r][c];\n      if (piece && piece.color === color) {\n        if (piece.type !== 'p' && piece.type !== 'k') {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Minimax algorithm with alpha-beta pruning and transposition table\n */\nfunction minimax(board, move, depth, isMaximizing, alpha, beta, aiColor, parentHash) {\n  // Track evaluated nodes\n  nodesEvaluated++;\n\n  // Send progress update periodically\n  if (nodesEvaluated % 100 === 0) {\n    const now = Date.now();\n    if (now - lastProgressUpdate >= 100) {\n      sendProgress(currentDepth);\n    }\n  }\n\n  const fromPiece = move ? board[move.from.r][move.from.c] : null; // Get piece from original board\n  const capturedPiece = move ? board[move.to.r][move.to.c] : null; // Get captured piece from original board\n\n  // INCREMENTAL HASH UPDATE\n  let hash = parentHash;\n\n  // 1. Toggle side to move\n  hash ^= zobristTable.sideToMove;\n\n  if (move) {\n    // 2. Remove moving piece from source\n    if (fromPiece) {\n      hash ^= zobristTable[fromPiece.color][fromPiece.type][move.from.r][move.from.c];\n    }\n\n    // 3. Add moving piece to destination\n    if (fromPiece) {\n      hash ^= zobristTable[fromPiece.color][fromPiece.type][move.to.r][move.to.c];\n    }\n\n    // 4. If capture, remove captured piece\n    if (capturedPiece) {\n      hash ^= zobristTable[capturedPiece.color][capturedPiece.type][move.to.r][move.to.c];\n    }\n  }\n\n  // Probe transposition table\n  const ttEntry = probeTT(hash, depth, alpha, beta);\n  if (ttEntry && ttEntry.score !== undefined) {\n    return ttEntry.score;\n  }\n\n  // Apply move\n  const undoInfo = makeMove(board, move);\n\n  let score;\n  let bestMove = null;\n  let flag = TT_ALPHA; // Default: upper bound\n\n  if (depth === 0) {\n    // Use quiescence search at leaf nodes\n    score = quiescenceSearch(board, alpha, beta, isMaximizing, aiColor);\n    flag = TT_EXACT;\n  } else {\n    // NULL MOVE PRUNING\n    const color = isMaximizing ? aiColor : aiColor === 'white' ? 'black' : 'white';\n\n    // Conditions: depth >= 3, not a null move itself, not in check, has pieces\n    if (depth >= 3 && move !== null && !isInCheck(board, color) && hasMajorPieces(board, color)) {\n      const R = 2;\n      // Search with reduced depth, passing null to skip move application\n      // Passing null means we pass the turn to the other side (!isMaximizing)\n      const nullScore = minimax(board, null, depth - 1 - R, !isMaximizing, alpha, beta, aiColor, hash);\n\n      if (isMaximizing) {\n        if (nullScore >= beta) {\n          undoMove(board, undoInfo);\n          return beta; // Cutoff\n        }\n      } else {\n        if (nullScore <= alpha) {\n          undoMove(board, undoInfo);\n          return alpha; // Cutoff\n        }\n      }\n    }\n\n    const moves = getAllLegalMoves(board, color);\n\n    if (moves.length === 0) {\n      // Game over\n      score = isMaximizing ? -10000 : 10000;\n      flag = TT_EXACT;\n    } else if (isMaximizing) {\n      score = -Infinity;\n      const ttBestMove = ttEntry ? ttEntry.bestMove : null;\n      const orderedMoves = orderMoves(board, moves, ttBestMove, depth);\n\n      for (let i = 0; i < orderedMoves.length; i++) {\n        const nextMove = orderedMoves[i];\n        let moveScore;\n        const isCapture = board[nextMove.to.r][nextMove.to.c] !== null;\n\n        if (i === 0) {\n          // PV move: search with full window\n          moveScore = minimax(board, nextMove, depth - 1, false, alpha, beta, aiColor, hash);\n        } else {\n          // PVS / LMR search\n          let reduction = 0;\n          if (depth >= 3 && i >= 4 && !isCapture && !isInCheck(board, color)) {\n            reduction = 1;\n            if (i >= 12) reduction = 2; // Extra reduction for very late moves\n          }\n\n          // Search with zero window (Fail-soft)\n          moveScore = minimax(board, nextMove, depth - 1 - reduction, false, alpha, alpha + 1, aiColor, hash);\n\n          // Re-search if reduced depth was too deep\n          if (moveScore > alpha && reduction > 0) {\n            moveScore = minimax(board, nextMove, depth - 1, false, alpha, alpha + 1, aiColor, hash);\n          }\n          // Re-search with full window if PV candidate\n          if (moveScore > alpha && moveScore < beta) {\n            moveScore = minimax(board, nextMove, depth - 1, false, alpha, beta, aiColor, hash);\n          }\n        }\n\n        if (moveScore > score) {\n          score = moveScore;\n          bestMove = nextMove;\n        }\n        alpha = Math.max(alpha, score);\n        if (beta <= alpha) {\n          if (!capturedPiece) addKillerMove(depth, nextMove);\n          updateHistory(fromPiece, nextMove, depth);\n          flag = TT_BETA; // Lower bound (fail-high)\n          break;\n        }\n      }\n      if (flag !== TT_BETA) flag = TT_EXACT;\n    } else {\n      score = Infinity;\n      const ttBestMove = ttEntry ? ttEntry.bestMove : null;\n      const orderedMoves = orderMoves(board, moves, ttBestMove, depth);\n\n      for (let i = 0; i < orderedMoves.length; i++) {\n        const nextMove = orderedMoves[i];\n        let moveScore;\n        const isCapture = board[nextMove.to.r][nextMove.to.c] !== null;\n\n        if (i === 0) {\n          // PV move: full search\n          moveScore = minimax(board, nextMove, depth - 1, true, alpha, beta, aiColor, hash);\n        } else {\n          // PVS / LMR search\n          let reduction = 0;\n          if (depth >= 3 && i >= 4 && !isCapture && !isInCheck(board, color)) {\n            reduction = 1;\n            if (i >= 12) reduction = 2;\n          }\n\n          // Zero-window search (Fail-soft)\n          moveScore = minimax(board, nextMove, depth - 1 - reduction, true, beta - 1, beta, aiColor, hash);\n\n          if (moveScore < beta && reduction > 0) {\n            moveScore = minimax(board, nextMove, depth - 1, true, beta - 1, beta, aiColor, hash);\n          }\n          if (moveScore < beta && moveScore > alpha) {\n            moveScore = minimax(board, nextMove, depth - 1, true, alpha, beta, aiColor, hash);\n          }\n        }\n\n        if (moveScore < score) {\n          score = moveScore;\n          bestMove = nextMove;\n        }\n        beta = Math.min(beta, score);\n        if (beta <= alpha) {\n          if (!capturedPiece) addKillerMove(depth, nextMove);\n          updateHistory(fromPiece, nextMove, depth);\n          flag = TT_BETA;\n          break;\n        }\n      }\n      if (flag !== TT_BETA) flag = TT_EXACT;\n    }\n  }\n\n  // Undo move\n  undoMove(board, undoInfo);\n\n  // Store in transposition table\n  storeTT(hash, depth, score, flag, bestMove);\n\n  return score;\n}\n\n/**\n * Quiescence search to avoid horizon effect\n */\n/**\n * Quiescence search to avoid horizon effect\n */\nfunction quiescenceSearch(board, alpha, beta, isMaximizing, aiColor) {\n  nodesEvaluated++;\n  const standPat = evaluatePosition(board, aiColor);\n\n  if (isMaximizing) {\n    if (standPat >= beta) return beta;\n    if (alpha < standPat) alpha = standPat;\n  } else {\n    if (standPat <= alpha) return alpha;\n    if (beta > standPat) beta = standPat;\n  }\n\n  // Find all capture moves\n  const color = isMaximizing ? aiColor : aiColor === 'white' ? 'black' : 'white';\n  const captureMoves = getAllCaptureMoves(board, color);\n\n  if (isMaximizing) {\n    for (const move of captureMoves) {\n      const undoInfo = makeMove(board, move);\n\n      const score = quiescenceSearch(board, alpha, beta, false, aiColor);\n\n      undoMove(board, undoInfo);\n\n      if (score >= beta) return beta;\n      if (score > alpha) alpha = score;\n    }\n    return alpha;\n  } else {\n    for (const move of captureMoves) {\n      const undoInfo = makeMove(board, move);\n\n      const score = quiescenceSearch(board, alpha, beta, true, aiColor);\n\n      undoMove(board, undoInfo);\n\n      if (score <= alpha) return alpha;\n      if (score < beta) beta = score;\n    }\n    return beta;\n  }\n}\n\n/**\n * Evaluate board position with advanced heuristics\n */\nconst pawnColumnsWhite = new Int8Array(BOARD_SIZE);\nconst pawnColumnsBlack = new Int8Array(BOARD_SIZE);\n\nexport function evaluatePosition(board, forColor) {\n  let mgScore = 0;\n  let egScore = 0;\n  const materialCount = 0;\n\n  // Reset static arrays for pawn structure\n  pawnColumnsWhite.fill(0);\n  pawnColumnsBlack.fill(0);\n\n  // Total material for phase calculation (excluding pawns and kings)\n  const PHASE_VALUES = { n: 1, b: 1, r: 2, q: 4, a: 3, c: 3, e: 4 };\n  let totalPhase = 0;\n\n  // First pass: collect pieces and basic material/pst/mobility\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const piece = board[r][c];\n      if (!piece) continue;\n\n      const pieceValue = PIECE_VALUES[piece.type] || 0;\n      const mgBonus = getPositionBonus(r, c, piece.type, piece.color, false);\n      const egBonus = getPositionBonus(r, c, piece.type, piece.color, true);\n\n      // Material and basic PST\n      const isWhite = piece.color === 'white';\n      const sideMult = isWhite ? 1 : -1;\n\n      mgScore += (pieceValue + mgBonus) * sideMult;\n      egScore += (pieceValue + egBonus) * sideMult;\n\n      // Mobility (only for non-pawn/king)\n      if (piece.type !== 'p' && piece.type !== 'k') {\n        const mobility = countMobility(board, r, c, piece);\n        const mobBonus = mobility * 2;\n        mgScore += mobBonus * sideMult;\n        egScore += mobBonus * sideMult;\n\n        // Phase contribution\n        totalPhase += PHASE_VALUES[piece.type] || 0;\n      }\n\n      // Record pawn for structure eval\n      if (piece.type === 'p') {\n        if (isWhite) {\n          pawnColumnsWhite[c]++;\n        } else {\n          pawnColumnsBlack[c]++;\n        }\n      }\n\n      // King Safety (Midgame only)\n      if (piece.type === 'k') {\n        const safety = evaluateKingSafety(board, r, c, piece.color);\n        mgScore += safety * sideMult;\n      }\n    }\n  }\n\n  // Second pass: Pawn structure (Isolated, Passed, Doubled)\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const piece = board[r][c];\n      if (!piece || piece.type !== 'p') continue;\n\n      const isWhite = piece.color === 'white';\n      const sideMult = isWhite ? 1 : -1;\n\n      // Doubled pawn penalty\n      const cols = isWhite ? pawnColumnsWhite : pawnColumnsBlack;\n      if (cols[c] > 1) {\n        mgScore -= 10 * sideMult;\n        egScore -= 12 * sideMult;\n      }\n\n      // Isolated pawn penalty\n      const leftCol = c > 0 ? cols[c - 1] : 0;\n      const rightCol = c < BOARD_SIZE - 1 ? cols[c + 1] : 0;\n      if (leftCol === 0 && rightCol === 0) {\n        mgScore -= 15 * sideMult;\n        egScore -= 20 * sideMult;\n      }\n\n      // Passed pawn bonus\n      if (isPassedPawn(board, r, c, piece.color)) {\n        const progress = isWhite ? (BOARD_SIZE - 1 - r) : r;\n        const passedBonus = progress * progress * 5;\n        mgScore += passedBonus * sideMult;\n        egScore += passedBonus * 1.5 * sideMult;\n      }\n    }\n  }\n\n  // Calculate phase (0 = pure endgame, 24+ = midgame)\n  // Max phase is roughly around 32-40 in this 9x9 setup\n  const maxPhase = 32;\n  const phaseValue = Math.min(totalPhase, maxPhase);\n  const mgWeight = phaseValue / maxPhase;\n  const egWeight = 1 - mgWeight;\n\n  const totalScore = (mgScore * mgWeight) + (egScore * egWeight);\n  const perspectiveScore = forColor === 'white' ? totalScore : -totalScore;\n\n  return Math.round(perspectiveScore);\n}\n\n/**\n * Check if a pawn is a passed pawn\n */\nfunction isPassedPawn(board, r, c, color) {\n  const opponentColor = color === 'white' ? 'black' : 'white';\n  const startR = color === 'white' ? r - 1 : r + 1;\n  const endR = color === 'white' ? 0 : BOARD_SIZE - 1;\n  const step = color === 'white' ? -1 : 1;\n\n  for (let row = startR; row !== endR + step; row += step) {\n    for (let col = Math.max(0, c - 1); col <= Math.min(BOARD_SIZE - 1, c + 1); col++) {\n      const piece = board[row][col];\n      if (piece && piece.type === 'p' && piece.color === opponentColor) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Get position bonus for piece placement using PSTs\n */\nfunction getPositionBonus(r, c, type, color, isEndgame = false) {\n  let table = (isEndgame && PST_EG[type]) ? PST_EG[type] : PST[type];\n  if (!table) table = PST[type]; // Fallback to normal PST if no EG table\n  if (!table) return 0;\n\n  // Mirror row for black pieces\n  const perspectiveRow = color === 'white' ? r : (BOARD_SIZE - 1 - r);\n  return table[perspectiveRow * BOARD_SIZE + c];\n}\n\n/**\n * Evaluate king safety based on surrounding pawns\n */\nfunction evaluateKingSafety(board, kingR, kingC, kingColor) {\n  let safety = 0;\n  const pawnRow = kingColor === 'white' ? 1 : -1;\n\n  // Check for pawn shield in front of king\n  for (let dc = -1; dc <= 1; dc++) {\n    const checkR = kingR + pawnRow;\n    const checkC = kingC + dc;\n\n    if (checkR >= 0 && checkR < BOARD_SIZE && checkC >= 0 && checkC < BOARD_SIZE) {\n      const piece = board[checkR][checkC];\n      if (piece && piece.type === 'p' && piece.color === kingColor) {\n        safety += 15; // Bonus for pawn shield\n      }\n    }\n  }\n\n  return safety;\n}\n\n\n/**\n * Order moves for better alpha-beta pruning\n * Priority: 1) TT best move, 2) Captures (MVV-LVA), 3) Killer moves, 4) History heuristic\n */\nfunction orderMoves(board, moves, ttBestMove, depth = 0) {\n  for (let i = 0; i < moves.length; i++) {\n    const move = moves[i];\n    let score = 0;\n    const fromPiece = board[move.from.r][move.from.c];\n    if (!fromPiece) continue;\n\n    // 1. TT move gets highest priority\n    if (\n      ttBestMove &&\n      move.from.r === ttBestMove.from.r &&\n      move.from.c === ttBestMove.from.c &&\n      move.to.r === ttBestMove.to.r &&\n      move.to.c === ttBestMove.to.c\n    ) {\n      score += 10000;\n    }\n\n    // 2. MVV-LVA: Most Valuable Victim - Least Valuable Attacker\n    const targetPiece = board[move.to.r][move.to.c];\n    if (targetPiece) {\n      const victimValue = PIECE_VALUES[targetPiece.type] || 0;\n      const attackerValue = PIECE_VALUES[fromPiece.type] || 0;\n      score += victimValue * 10 - attackerValue / 10;\n    } else {\n      // 3. Killer moves (non-capture moves that caused beta cutoffs)\n      const killers = killerMoves.get(depth);\n      if (killers) {\n        // Optimized check for MAX_KILLER_MOVES = 2\n        const k0 = killers[0];\n        if (k0 && move.from.r === k0.from.r && move.from.c === k0.from.c && move.to.r === k0.to.r && move.to.c === k0.to.c) {\n          score += 900;\n        } else {\n          const k1 = killers[1];\n          if (k1 && move.from.r === k1.from.r && move.from.c === k1.from.c && move.to.r === k1.to.r && move.to.c === k1.to.c) {\n            score += 800;\n          }\n        }\n      }\n\n      // 4. History heuristic\n      if (historyTable[fromPiece.type]) {\n        const historyValue = historyTable[fromPiece.type][move.from.r][move.from.c][move.to.r][move.to.c];\n        if (historyValue > 0) {\n          score += historyValue / 100;\n        }\n      }\n    }\n\n    move._score = score;\n  }\n\n  // Sort by score (highest first)\n  moves.sort((a, b) => (b._score || 0) - (a._score || 0));\n\n  return moves;\n}\n\n/**\n * Get all legal moves for a color (validating checks)\n */\nexport function getAllLegalMoves(board, color) {\n  const moves = [];\n  const kingPos = findKing(board, color);\n\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const piece = board[r][c];\n      if (piece && piece.color === color) {\n        const pieceMoves = getPseudoLegalMoves(board, r, c, piece);\n\n        // Filter out moves that leave king in check\n        for (let i = 0; i < pieceMoves.length; i++) {\n          const move = pieceMoves[i];\n          // Apply move temporarily\n          const fromPiece = board[move.from.r][move.from.c];\n          const targetPiece = board[move.to.r][move.to.c];\n          board[move.to.r][move.to.c] = fromPiece;\n          board[move.from.r][move.from.c] = null;\n\n          // If king moves, pass the new position\n          const currentKingPos = fromPiece.type === 'k' ? { r: move.to.r, c: move.to.c } : kingPos;\n\n          if (!isInCheck(board, color, currentKingPos)) {\n            moves.push(move);\n          }\n\n          // Undo move\n          board[move.from.r][move.from.c] = fromPiece;\n          board[move.to.r][move.to.c] = targetPiece;\n        }\n      }\n    }\n  }\n\n  return moves;\n}\n\n/**\n * Check if a color is in check\n */\n/**\n * Check if a color is in check\n */\nexport function isInCheck(board, color, knownKingPos) {\n  const kingPos = knownKingPos || findKing(board, color);\n  if (!kingPos) return false;\n\n  const opponentColor = color === 'white' ? 'black' : 'white';\n  return isSquareAttacked(board, kingPos.r, kingPos.c, opponentColor);\n}\n\n/**\n * Find the king for a specific color\n */\nfunction findKing(board, color) {\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const piece = board[r][c];\n      if (piece && piece.color === color && piece.type === 'k') {\n        return { r, c };\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Check if a square is attacked by a specific color\n */\nconst KNIGHT_MOVES = [\n  [-2, -1], [-2, 1], [-1, -2], [-1, 2],\n  [1, -2], [1, 2], [2, -1], [2, 1],\n];\n\nconst DIAGONAL_DIRS = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\nconst ORTHOGONAL_DIRS = [[-1, 0], [1, 0], [0, -1], [0, 1]];\nconst KING_DIRS = [\n  [-1, -1], [-1, 0], [-1, 1],\n  [0, -1], [0, 1],\n  [1, -1], [1, 0], [1, 1]\n];\n\nconst ATTACK_DIRECTIONS = [\n  { dr: -1, dc: -1, types: ['b', 'q', 'a', 'e'] }, // Diagonals\n  { dr: -1, dc: 1, types: ['b', 'q', 'a', 'e'] },\n  { dr: 1, dc: -1, types: ['b', 'q', 'a', 'e'] },\n  { dr: 1, dc: 1, types: ['b', 'q', 'a', 'e'] },\n  { dr: -1, dc: 0, types: ['r', 'q', 'c', 'e'] }, // Orthogonals\n  { dr: 1, dc: 0, types: ['r', 'q', 'c', 'e'] },\n  { dr: 0, dc: -1, types: ['r', 'q', 'c', 'e'] },\n  { dr: 0, dc: 1, types: ['r', 'q', 'c', 'e'] },\n];\n\n/**\n * Static lookup tables for move generation\n */\nconst PIECE_SLIDING_DIRS = {\n  b: DIAGONAL_DIRS,\n  r: ORTHOGONAL_DIRS,\n  q: [...DIAGONAL_DIRS, ...ORTHOGONAL_DIRS],\n  a: DIAGONAL_DIRS,\n  c: ORTHOGONAL_DIRS,\n  e: [...DIAGONAL_DIRS, ...ORTHOGONAL_DIRS]\n};\n\nconst PIECE_STEPPING_DIRS = {\n  n: KNIGHT_MOVES, // Knight\n  k: KING_DIRS,    // King\n  a: KNIGHT_MOVES, // Archbishop (N+B)\n  c: KNIGHT_MOVES, // Chancellor (N+R)\n  e: KNIGHT_MOVES  // Angel (Q+N)\n};\n\n/**\n * Check if a square is attacked by a specific color\n */\nconst PIECE_ATTACKS_DIAGONALLY = { b: true, q: true, a: true, e: true };\nconst PIECE_ATTACKS_ORTHOGONALLY = { r: true, q: true, c: true, e: true };\n\n/**\n * Check if a square is attacked by a specific color\n */\nfunction isSquareAttacked(board, r, c, attackerColor) {\n  // 1. Pawn attacks\n  const pawnRow = attackerColor === 'white' ? 1 : -1;\n  const pr = r + pawnRow;\n  if (pr >= 0 && pr < BOARD_SIZE) {\n    if (c > 0) {\n      const piece = board[pr][c - 1];\n      if (piece && piece.type === 'p' && piece.color === attackerColor) return true;\n    }\n    if (c < BOARD_SIZE - 1) {\n      const piece = board[pr][c + 1];\n      if (piece && piece.type === 'p' && piece.color === attackerColor) return true;\n    }\n  }\n\n  // 2. Knight attacks (Knight, Archbishop, Chancellor, Angel)\n  // Use unrolled loop for speed\n  for (let i = 0; i < 8; i++) {\n    const move = KNIGHT_MOVES[i];\n    const nr = r + move[0];\n    const nc = c + move[1];\n    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {\n      const piece = board[nr][nc];\n      if (piece && piece.color === attackerColor) {\n        const t = piece.type;\n        if (t === 'n' || t === 'a' || t === 'c' || t === 'e') return true;\n      }\n    }\n  }\n\n  // 3. Sliding pieces (Bishop/Rook/Queen/Archbishop/Chancellor/Angel)\n  // and King attack (distance 1)\n\n  // Diagonal\n  for (let i = 0; i < 4; i++) {\n    const dir = DIAGONAL_DIRS[i];\n    let nr = r + dir[0];\n    let nc = c + dir[1];\n\n    // King check\n    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {\n      const piece = board[nr][nc];\n      if (piece) {\n        if (piece.color === attackerColor) {\n          if (piece.type === 'k' || PIECE_ATTACKS_DIAGONALLY[piece.type]) return true;\n        }\n      } else {\n        // Sliding\n        nr += dir[0];\n        nc += dir[1];\n        while (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {\n          const nextPiece = board[nr][nc];\n          if (nextPiece) {\n            if (nextPiece.color === attackerColor && PIECE_ATTACKS_DIAGONALLY[nextPiece.type]) return true;\n            break;\n          }\n          nr += dir[0];\n          nc += dir[1];\n        }\n      }\n    }\n  }\n\n  // Orthogonal\n  for (let i = 0; i < 4; i++) {\n    const dir = ORTHOGONAL_DIRS[i];\n    let nr = r + dir[0];\n    let nc = c + dir[1];\n\n    // King check\n    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {\n      const piece = board[nr][nc];\n      if (piece) {\n        if (piece.color === attackerColor) {\n          if (piece.type === 'k' || PIECE_ATTACKS_ORTHOGONALLY[piece.type]) return true;\n        }\n      } else {\n        // Sliding\n        nr += dir[0];\n        nc += dir[1];\n        while (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {\n          const nextPiece = board[nr][nc];\n          if (nextPiece) {\n            if (nextPiece.color === attackerColor && PIECE_ATTACKS_ORTHOGONALLY[nextPiece.type]) return true;\n            break;\n          }\n          nr += dir[0];\n          nc += dir[1];\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Get pseudo-legal moves for a piece (ignoring check)\n */\n/**\n * Get pseudo-legal moves for a piece (ignoring check)\n */\nfunction getPseudoLegalMoves(board, r, c, piece, onlyCaptures = false) {\n  const moves = [];\n  const isInside = (r, c) => r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE;\n  const isEnemy = (r, c) => board[r][c] && board[r][c].color !== piece.color;\n  const isEmpty = (r, c) => !board[r][c];\n\n  if (piece.type === 'p') {\n    const forward = piece.color === 'white' ? -1 : 1;\n    // Move 1\n    if (!onlyCaptures && isInside(r + forward, c) && isEmpty(r + forward, c)) {\n      moves.push({ from: { r, c }, to: { r: r + forward, c } });\n      // Move 2 (if not moved)\n      if (piece.hasMoved === false && isInside(r + forward * 2, c) && isEmpty(r + forward * 2, c)) {\n        moves.push({ from: { r, c }, to: { r: r + forward * 2, c } });\n      }\n    }\n    // Capture\n    for (const dc of [-1, 1]) {\n      if (isInside(r + forward, c + dc) && isEnemy(r + forward, c + dc)) {\n        moves.push({ from: { r, c }, to: { r: r + forward, c: c + dc } });\n      }\n    }\n  } else {\n    // Stepping moves (Knight, King, and stepping components of hybrids)\n    const steppingDirs = PIECE_STEPPING_DIRS[piece.type];\n    if (steppingDirs) {\n      for (let i = 0; i < steppingDirs.length; i++) {\n        const [dr, dc] = steppingDirs[i];\n        const nr = r + dr, nc = c + dc;\n        if (isInside(nr, nc)) {\n          if (isEnemy(nr, nc)) {\n            moves.push({ from: { r, c }, to: { r: nr, c: nc } });\n          } else if (!onlyCaptures && isEmpty(nr, nc)) {\n            moves.push({ from: { r, c }, to: { r: nr, c: nc } });\n          }\n        }\n      }\n    }\n\n    // Sliding moves (Bishop, Rook, Queen, and sliding components of hybrids)\n    const slidingDirs = PIECE_SLIDING_DIRS[piece.type];\n    if (slidingDirs) {\n      for (let i = 0; i < slidingDirs.length; i++) {\n        const [dr, dc] = slidingDirs[i];\n        let nr = r + dr;\n        let nc = c + dc;\n        while (isInside(nr, nc)) {\n          if (isEmpty(nr, nc)) {\n            if (!onlyCaptures) {\n              moves.push({ from: { r, c }, to: { r: nr, c: nc } });\n            }\n          } else {\n            if (isEnemy(nr, nc)) {\n              moves.push({ from: { r, c }, to: { r: nr, c: nc } });\n            }\n            break;\n          }\n          nr += dr;\n          nc += dc;\n        }\n      }\n    }\n  }\n\n  return moves;\n}\n\n/**\n * Get all capture moves for a color (validating checks)\n */\nfunction getAllCaptureMoves(board, color) {\n  const moves = [];\n\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const piece = board[r][c];\n      if (piece && piece.color === color) {\n        const pieceMoves = getPseudoLegalMoves(board, r, c, piece, true); // onlyCaptures = true\n\n        for (const move of pieceMoves) {\n          const undoInfo = makeMove(board, move);\n\n          if (!isInCheck(board, color)) {\n            moves.push(move);\n          }\n\n          undoMove(board, undoInfo);\n        }\n      }\n    }\n  }\n\n  return moves;\n}\n\n\n/**\n * Count pseudo-legal moves for mobility bonus (optimized, no object creation)\n */\nfunction countMobility(board, r, c, piece) {\n  let count = 0;\n  const isInside = (r, c) => r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE;\n  const isEnemy = (r, c) => board[r][c] && board[r][c].color !== piece.color;\n  const isEmpty = (r, c) => !board[r][c];\n\n  // Stepping moves (Knight etc)\n  const steppingDirs = PIECE_STEPPING_DIRS[piece.type];\n  if (steppingDirs) {\n    for (let i = 0; i < steppingDirs.length; i++) {\n      const [dr, dc] = steppingDirs[i];\n      const nr = r + dr, nc = c + dc;\n      if (isInside(nr, nc) && (isEmpty(nr, nc) || isEnemy(nr, nc))) {\n        count++;\n      }\n    }\n  }\n\n  // Sliding moves\n  const slidingDirs = PIECE_SLIDING_DIRS[piece.type];\n  if (slidingDirs) {\n    for (let i = 0; i < slidingDirs.length; i++) {\n      const [dr, dc] = slidingDirs[i];\n      let nr = r + dr;\n      let nc = c + dc;\n      while (isInside(nr, nc)) {\n        if (isEmpty(nr, nc)) {\n          count++;\n        } else {\n          if (isEnemy(nr, nc)) {\n            count++;\n          }\n          break;\n        }\n        nr += dr;\n        nc += dc;\n      }\n    }\n  }\n\n  return count;\n}\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/arrows.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/battleAnimations.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'attackerType' is defined but never used. Allowed unused args must match /^_/u.","line":125,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":125,"endColumn":37},{"ruleId":"no-unused-vars","severity":1,"message":"'defenderType' is defined but never used. Allowed unused args must match /^_/u.","line":125,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":125,"endColumn":51},{"ruleId":"no-unused-vars","severity":1,"message":"'defenderPos' is defined but never used. Allowed unused args must match /^_/u.","line":166,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":166,"endColumn":47}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Battle Animations for 3D Chess\n * Handles animated battle sequences when pieces capture each other\n * @module battleAnimations\n */\n\nimport * as THREE from 'three';\nimport { logger } from './logger.js';\n\n/**\n * Battle Animator - choreographs piece capture animations\n */\nexport class BattleAnimator {\n  constructor(scene, camera) {\n    this.scene = scene;\n    this.camera = camera;\n    this.originalCameraPos = null;\n    this.originalCameraTarget = null;\n  }\n\n  /**\n     * Play a battle sequence\n     * @param {Object} attacker - Attacking piece data\n     * @param {Object} defender - Defending piece data\n     * @param {Object} attackerPos - Attacker 3D position\n     * @param {Object} defenderPos - Defender 3D position\n     */\n  async playBattle(attacker, defender, attackerPos, defenderPos) {\n    logger.info(`Battle: ${attacker.type} vs ${defender.type}`);\n\n    // Save camera state\n    this.saveCameraState();\n\n    // Move camera to battle view\n    await this.moveCameraToBattle(attackerPos, defenderPos);\n\n    // Select and play battle animation\n    const animation = this.selectBattleAnimation(attacker.type, defender.type);\n    await this.executeBattleAnimation(\n      animation,\n      attacker,\n      defender,\n      attackerPos,\n      defenderPos,\n    );\n\n    // Restore camera\n    await this.restoreCamera();\n  }\n\n  /**\n     * Save current camera state\n     */\n  saveCameraState() {\n    this.originalCameraPos = this.camera.position.clone();\n    this.originalCameraTarget = new THREE.Vector3(0, 0, 0); // Default target\n  }\n\n  /**\n     * Move camera to battle viewpoint\n     */\n  async moveCameraToBattle(attackerPos, defenderPos) {\n    // Calculate midpoint between attacker and defender\n    const midpoint = new THREE.Vector3(\n      (attackerPos.x + defenderPos.x) / 2,\n      0.5,\n      (attackerPos.z + defenderPos.z) / 2,\n    );\n\n    // Camera position: side view of the battle\n    const cameraPos = new THREE.Vector3(midpoint.x + 3, 2, midpoint.z + 3);\n\n    return this.animateCameraMove(cameraPos, midpoint, 800);\n  }\n\n  /**\n     * Restore camera to original position\n     */\n  async restoreCamera() {\n    if (!this.originalCameraPos) return;\n\n    return this.animateCameraMove(\n      this.originalCameraPos,\n      this.originalCameraTarget,\n      600,\n    );\n  }\n\n  /**\n     * Animate camera movement\n     */\n  animateCameraMove(targetPos, lookAt, duration) {\n    const startPos = this.camera.position.clone();\n    const startTime = Date.now();\n\n    return new Promise((resolve) => {\n      const animate = () => {\n        const elapsed = Date.now() - startTime;\n        const progress = Math.min(elapsed / duration, 1);\n\n        // Ease in-out\n        const eased =\n                    progress < 0.5\n                      ? 2 * progress * progress\n                      : 1 - Math.pow(-2 * progress + 2, 2) / 2;\n\n        this.camera.position.lerpVectors(startPos, targetPos, eased);\n        this.camera.lookAt(lookAt);\n\n        if (progress < 1) {\n          requestAnimationFrame(animate);\n        } else {\n          resolve();\n        }\n      };\n\n      animate();\n    });\n  }\n\n  /**\n     * Select appropriate battle animation\n     * Returns animation type based on piece types\n     */\n  selectBattleAnimation(attackerType, defenderType) {\n    // Random selection from pool for variety\n    const animations = ['charge', 'strike', 'clash', 'overpower'];\n    const randomIndex = Math.floor(Math.random() * animations.length);\n    return animations[randomIndex];\n  }\n\n  /**\n     * Execute the battle animation\n     */\n  async executeBattleAnimation(\n    animationType,\n    attacker,\n    defender,\n    attackerPos,\n    defenderPos,\n  ) {\n    switch (animationType) {\n    case 'charge':\n      await this.animateCharge(attackerPos, defenderPos);\n      break;\n    case 'strike':\n      await this.animateStrike(attackerPos, defenderPos);\n      break;\n    case 'clash':\n      await this.animateClash(attackerPos, defenderPos);\n      break;\n    case 'overpower':\n      await this.animateOverpower(attackerPos, defenderPos);\n      break;\n    default:\n      await this.animateCharge(attackerPos, defenderPos);\n    }\n\n    // Defender defeat animation\n    await this.animateDefeat(defenderPos);\n  }\n\n  /**\n     * Charge animation - attacker rushes forward\n     */\n  async animateCharge(attackerPos, defenderPos) {\n    // Create temporary visual effect\n    const particles = this.createDustParticles(attackerPos);\n\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        particles.forEach((p) => this.scene.remove(p));\n        resolve();\n      }, 500);\n    });\n  }\n\n  /**\n     * Strike animation - quick attack\n     */\n  async animateStrike(attackerPos, defenderPos) {\n    // Flash effect\n    const flash = this.createFlashEffect(defenderPos);\n\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        this.scene.remove(flash);\n        resolve();\n      }, 300);\n    });\n  }\n\n  /**\n     * Clash animation - both pieces engage\n     */\n  async animateClash(attackerPos, defenderPos) {\n    const sparks = this.createSparkParticles(\n      (attackerPos.x + defenderPos.x) / 2,\n      0.5,\n      (attackerPos.z + defenderPos.z) / 2,\n    );\n\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        sparks.forEach((s) => this.scene.remove(s));\n        resolve();\n      }, 600);\n    });\n  }\n\n  /**\n     * Overpower animation - attacker dominates\n     */\n  async animateOverpower(attackerPos, defenderPos) {\n    // Shockwave effect\n    const shockwave = this.createShockwave(defenderPos);\n\n    return new Promise((resolve) => {\n      const startTime = Date.now();\n      const duration = 700;\n\n      const animate = () => {\n        const elapsed = Date.now() - startTime;\n        const progress = elapsed / duration;\n\n        if (shockwave) {\n          shockwave.scale.set(1 + progress * 2, 1, 1 + progress * 2);\n          shockwave.material.opacity = 1 - progress;\n        }\n\n        if (progress < 1) {\n          requestAnimationFrame(animate);\n        } else {\n          this.scene.remove(shockwave);\n          resolve();\n        }\n      };\n\n      animate();\n    });\n  }\n\n  /**\n     * Defeat animation - defender is defeated\n     */\n  async animateDefeat(defenderPos) {\n    // Smoke/dust cloud\n    const smoke = this.createSmokeEffect(defenderPos);\n\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        smoke.forEach((s) => this.scene.remove(s));\n        resolve();\n      }, 800);\n    });\n  }\n\n  /**\n     * Create dust particle effects\n     */\n  createDustParticles(position) {\n    const particles = [];\n    const particleCount = 10;\n\n    for (let i = 0; i < particleCount; i++) {\n      const geometry = new THREE.SphereGeometry(0.05, 4, 4);\n      const material = new THREE.MeshBasicMaterial({\n        color: 0xccaa88,\n        transparent: true,\n        opacity: 0.6,\n      });\n      const particle = new THREE.Mesh(geometry, material);\n\n      particle.position.set(\n        position.x + (Math.random() - 0.5) * 0.5,\n        0.1,\n        position.z + (Math.random() - 0.5) * 0.5,\n      );\n\n      this.scene.add(particle);\n      particles.push(particle);\n    }\n\n    return particles;\n  }\n\n  /**\n     * Create flash effect\n     */\n  createFlashEffect(position) {\n    const geometry = new THREE.SphereGeometry(0.3, 16, 16);\n    const material = new THREE.MeshBasicMaterial({\n      color: 0xffff00,\n      transparent: true,\n      opacity: 0.8,\n    });\n    const flash = new THREE.Mesh(geometry, material);\n    flash.position.set(position.x, 0.5, position.z);\n\n    this.scene.add(flash);\n    return flash;\n  }\n\n  /**\n     * Create spark particles\n     */\n  createSparkParticles(x, y, z) {\n    const sparks = [];\n    const sparkCount = 15;\n\n    for (let i = 0; i < sparkCount; i++) {\n      const geometry = new THREE.SphereGeometry(0.03, 4, 4);\n      const material = new THREE.MeshBasicMaterial({\n        color: 0xffaa00,\n        transparent: true,\n        opacity: 0.9,\n      });\n      const spark = new THREE.Mesh(geometry, material);\n\n      spark.position.set(\n        x + (Math.random() - 0.5) * 0.4,\n        y + Math.random() * 0.3,\n        z + (Math.random() - 0.5) * 0.4,\n      );\n\n      this.scene.add(spark);\n      sparks.push(spark);\n    }\n\n    return sparks;\n  }\n\n  /**\n     * Create shockwave effect\n     */\n  createShockwave(position) {\n    const geometry = new THREE.RingGeometry(0.2, 0.3, 32);\n    const material = new THREE.MeshBasicMaterial({\n      color: 0x00aaff,\n      side: THREE.DoubleSide,\n      transparent: true,\n      opacity: 0.7,\n    });\n    const shockwave = new THREE.Mesh(geometry, material);\n\n    shockwave.position.set(position.x, 0.05, position.z);\n    shockwave.rotation.x = -Math.PI / 2;\n\n    this.scene.add(shockwave);\n    return shockwave;\n  }\n\n  /**\n     * Create smoke effect\n     */\n  createSmokeEffect(position) {\n    const smoke = [];\n    const smokeCount = 8;\n\n    for (let i = 0; i < smokeCount; i++) {\n      const geometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.1, 8, 8);\n      const material = new THREE.MeshBasicMaterial({\n        color: 0x666666,\n        transparent: true,\n        opacity: 0.5,\n      });\n      const puff = new THREE.Mesh(geometry, material);\n\n      puff.position.set(\n        position.x + (Math.random() - 0.5) * 0.3,\n        0.2 + Math.random() * 0.3,\n        position.z + (Math.random() - 0.5) * 0.3,\n      );\n\n      this.scene.add(puff);\n      smoke.push(puff);\n    }\n\n    return smoke;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/battleChess3D.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'PIECE_COLORS' is defined but never used.","line":9,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":37},{"ruleId":"no-unused-vars","severity":1,"message":"'captured' is assigned a value but never used.","line":356,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":356,"endColumn":61},{"ruleId":"no-unused-vars","severity":1,"message":"'key' is defined but never used. Allowed unused args must match /^_/u.","line":547,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":547,"endColumn":46}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Battle Chess 3D Module\n * Handles 3D rendering, animations, and battle sequences for Schach 9x9\n * @module battleChess3D\n */\n\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { createPiece3D, PIECE_COLORS } from './pieces3D.js';\nimport { BattleAnimator } from './battleAnimations.js';\nimport { logger } from './logger.js';\nimport { BOARD_SIZE } from './config.js';\n\n/**\n * Main 3D Battle Chess Engine\n */\nexport class BattleChess3D {\n  constructor(containerElement) {\n    this.container = containerElement;\n    this.enabled = false;\n    this.scene = null;\n    this.camera = null;\n    this.renderer = null;\n    this.controls = null;\n    this.board = null;\n    this.pieces = {}; // map of \"r,c\" to 3D piece\n    this.highlights = [];\n    this.battleAnimator = null;\n    this.animationFrameId = null;\n    this.raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    this.clickHandler = null;\n    this.resizeHandler = null;\n    this.squareSize = 1;\n\n    // Skin system - use unified localStorage key\n    this.currentSkin = localStorage.getItem('chessSkin') || 'classic';\n\n    logger.info('[3D] BattleChess3D instance created');\n  }\n\n  /**\n     * Initialize the 3D scene\n     */\n  async init() {\n    try {\n      logger.info('Setting up 3D scene...');\n\n      // Validate container\n      if (!this.container) {\n        logger.error('3D container is null!');\n        return false;\n      }\n\n      const width = this.container.clientWidth;\n      const height = this.container.clientHeight;\n      logger.info(`Container dimensions: ${width}x${height}`);\n\n      if (width === 0 || height === 0) {\n        logger.error('Container has zero dimensions!');\n        return false;\n      }\n\n      // Scene\n      this.scene = new THREE.Scene();\n      // Use transparent background to see through to board or use a gradient\n      this.scene.background = new THREE.Color(0x1a1d29); // Match app background\n      // Remove fog for clearer visibility\n      // this.scene.fog = new THREE.Fog(0x0a0e27, 10, 50);\n      logger.info('Scene created');\n\n\n      // Camera\n      const aspect = width / height;\n      this.camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);\n      // Better camera position for 9x9 board\n      this.camera.position.set(0, 12, 12);\n      this.camera.lookAt(0, 0, 0);\n      logger.info(`Camera positioned at (0, 12, 12), aspect: ${aspect}`);\n\n      // Renderer\n      this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });\n      this.renderer.setSize(width, height);\n      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n      this.renderer.shadowMap.enabled = true;\n      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n      // CRITICAL: Clear container first\n      while (this.container.firstChild) {\n        this.container.removeChild(this.container.firstChild);\n      }\n\n      this.container.appendChild(this.renderer.domElement);\n      logger.info('Renderer canvas added to DOM');\n\n      // Controls\n      this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n      this.controls.enableDamping = true;\n      this.controls.dampingFactor = 0.05;\n      this.controls.maxPolarAngle = Math.PI / 2.2;\n      this.controls.minDistance = 8;\n      this.controls.maxDistance = 30;\n      this.controls.target.set(0, 0, 0);\n\n      // Lighting\n      this.setupLighting();\n\n      // Create board\n      this.createBoard();\n      logger.info(`Board created with ${this.boardGroup.children.length} squares`);\n\n      // Battle animator\n      this.battleAnimator = new BattleAnimator(this.scene, this.camera);\n\n      // Handle window resize\n      window.addEventListener('resize', this.onWindowResize.bind(this));\n\n      // Raycasting for clicks\n      this.raycaster = new THREE.Raycaster();\n      this.mouse = new THREE.Vector2();\n      this.renderer.domElement.addEventListener(\n        'click',\n        this.onClick.bind(this),\n      );\n\n      // Start animation loop BEFORE toggling enabled\n      this.animate();\n\n      // Enable rendering\n      this.enabled = true;\n\n      // Force first render\n      this.renderer.render(this.scene, this.camera);\n      logger.info(`Scene objects: ${this.scene.children.length}, First render complete`);\n\n      logger.info('3D scene setup complete');\n      return true;\n    } catch (error) {\n      logger.error('Failed to initialize 3D scene:', error);\n      return false;\n    }\n  }\n\n  /**\n     * Setup scene lighting\n     */\n  setupLighting() {\n    // Hemisphere light for natural sky/ground ambient mix\n    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);\n    hemiLight.position.set(0, 20, 0);\n    this.scene.add(hemiLight);\n\n    // Main directional light (Sun)\n    const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);\n    mainLight.position.set(5, 15, 8);\n    mainLight.castShadow = true;\n\n    // Optimize shadow map\n    mainLight.shadow.mapSize.width = 2048;\n    mainLight.shadow.mapSize.height = 2048;\n    mainLight.shadow.camera.near = 0.5;\n    mainLight.shadow.camera.far = 50;\n    mainLight.shadow.camera.left = -15;\n    mainLight.shadow.camera.right = 15;\n    mainLight.shadow.camera.top = 15;\n    mainLight.shadow.camera.bottom = -15;\n    mainLight.shadow.bias = -0.001; // Reduce shadow acne\n\n    this.scene.add(mainLight);\n\n    // Rim light (Backlight) for edge definition\n    const rimLight = new THREE.DirectionalLight(0x4466ff, 0.5);\n    rimLight.position.set(-5, 5, -10);\n    this.scene.add(rimLight);\n\n    logger.info('3D lighting setup: Enhanced with Hemisphere and Rim lights');\n  }\n\n  /**\n     * Get theme colors\n     */\n  getThemeColors(theme) {\n    const themes = {\n      classic: { light: 0xe8dcc0, dark: 0x6b5d4f },\n      blue: { light: 0x87ceeb, dark: 0x4682b4 },\n      green: { light: 0x90ee90, dark: 0x228b22 },\n      wood: { light: 0xdeb887, dark: 0x8b4513 },\n      dark: { light: 0x4a4a4a, dark: 0x2a2a2a }\n    };\n    return themes[theme] || themes.classic;\n  }\n\n  /**\n     * Create the 9x9 chess board\n     */\n  createBoard() {\n    this.boardGroup = new THREE.Group();\n    this.currentTheme = localStorage.getItem('chess_theme') || 'classic';\n\n    const squareGeometry = new THREE.BoxGeometry(\n      this.squareSize,\n      0.1,\n      this.squareSize,\n    );\n\n    // Get theme colors\n    const colors = this.getThemeColors(this.currentTheme);\n\n    // Create 9x9 grid\n    for (let row = 0; row < BOARD_SIZE; row++) {\n      for (let col = 0; col < BOARD_SIZE; col++) {\n        const isLight = (row + col) % 2 === 0;\n\n        const material = new THREE.MeshStandardMaterial({\n          color: isLight ? colors.light : colors.dark,\n          roughness: 0.7,\n          metalness: 0.1,\n        });\n\n        const square = new THREE.Mesh(squareGeometry, material);\n\n        // Position: convert board coords to 3D coords\n        const pos = this.boardToWorld(row, col);\n        square.position.set(pos.x, -0.05, pos.z);\n        square.receiveShadow = true;\n\n        // Store board position and light/dark info for raycasting\n        square.userData = { row, col, type: 'square', isLight };\n\n        this.boardGroup.add(square);\n      }\n    }\n\n    // Add coordinate labels (simple)\n    this.addCoordinateLabels();\n\n    this.scene.add(this.boardGroup);\n  }\n\n  /**\n     * Add coordinate labels to the board\n     */\n  addCoordinateLabels() {\n    // TODO: Add text sprites for coordinates\n    // For now, just add small markers at corners\n    const markerGeometry = new THREE.SphereGeometry(0.05, 8, 8);\n    const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });\n\n    // Mark origin\n    const origin = new THREE.Mesh(markerGeometry, markerMaterial);\n    origin.position.set(-4 * this.squareSize, 0.1, -4 * this.squareSize);\n    this.boardGroup.add(origin);\n  }\n\n  /**\n     * Convert board coordinates [0-8][0-8] to 3D world position\n     */\n  boardToWorld(row, col) {\n    // Center the board at origin\n    // row 0 = z: -4, row 8 = z: 4\n    // col 0 = x: -4, col 8 = x: 4\n    const x = (col - 4) * this.squareSize;\n    const z = (row - 4) * this.squareSize;\n    return { x, z };\n  }\n\n  /**\n     * Update 3D board from game state\n     */\n  updateFromGameState(game) {\n    if (!this.scene) return;\n\n    // Clear existing pieces\n    Object.values(this.pieces).forEach((piece) => {\n      this.scene.remove(piece);\n    });\n    this.pieces = {};\n\n    // Add pieces from game board\n    for (let row = 0; row < BOARD_SIZE; row++) {\n      for (let col = 0; col < BOARD_SIZE; col++) {\n        const piece = game.board[row][col];\n        if (piece) {\n          this.addPiece(piece.type, piece.color, row, col);\n        }\n      }\n    }\n  }\n\n  /**\n     * Add a 3D piece to the board\n     */\n  addPiece(type, color, row, col) {\n    const piece3D = createPiece3D(type, color, this.currentSkin);\n    if (!piece3D) return;\n\n    const pos = this.boardToWorld(row, col);\n    piece3D.position.set(pos.x, 0, pos.z);\n    piece3D.userData = { type, color, row, col };\n\n    this.scene.add(piece3D);\n    this.pieces[`${row},${col}`] = piece3D;\n  }\n\n  /**\n     * Remove piece from 3D scene\n     */\n  removePiece(row, col) {\n    const key = `${row},${col}`;\n    const piece = this.pieces[key];\n    if (piece) {\n      this.scene.remove(piece);\n      delete this.pieces[key];\n    }\n  }\n\n  /**\n     * Highlight valid moves on the board\n     */\n  highlightMoves(moves) {\n    // Clear previous highlights\n    this.clearHighlights();\n\n    // Create highlight markers\n    const geometry = new THREE.RingGeometry(0.3, 0.45, 32);\n    const material = new THREE.MeshBasicMaterial({\n      color: 0x00ff00,\n      side: THREE.DoubleSide,\n      transparent: true,\n      opacity: 0.6,\n    });\n\n    moves.forEach((move) => {\n      const marker = new THREE.Mesh(geometry, material);\n      const pos = this.boardToWorld(move.r, move.c);\n      marker.position.set(pos.x, 0.05, pos.z);\n      marker.rotation.x = -Math.PI / 2;\n      marker.userData = { type: 'highlight', row: move.r, col: move.c };\n\n      this.scene.add(marker);\n      this.highlights.push(marker);\n    });\n  }\n\n  /**\n     * Clear move highlights\n     */\n  clearHighlights() {\n    this.highlights.forEach((h) => this.scene.remove(h));\n    this.highlights = [];\n  }\n\n  /**\n     * Animate a piece move\n     */\n  async animateMove(fromRow, fromCol, toRow, toCol, captured = false) {\n    const key = `${fromRow},${fromCol}`;\n    const piece = this.pieces[key];\n    if (!piece) return;\n\n    this.animating = true;\n\n    const fromPos = this.boardToWorld(fromRow, fromCol);\n    const toPos = this.boardToWorld(toRow, toCol);\n\n    // Animate movement\n    const duration = 500; // ms\n    const start = Date.now();\n\n    return new Promise((resolve) => {\n      const moveAnimation = () => {\n        const elapsed = Date.now() - start;\n        const progress = Math.min(elapsed / duration, 1);\n\n        // Easing function (ease-in-out)\n        const eased =\n                    progress < 0.5\n                      ? 2 * progress * progress\n                      : 1 - Math.pow(-2 * progress + 2, 2) / 2;\n\n        piece.position.x = fromPos.x + (toPos.x - fromPos.x) * eased;\n        piece.position.z = fromPos.z + (toPos.z - fromPos.z) * eased;\n        piece.position.y = Math.sin(progress * Math.PI) * 0.5; // Arc\n\n        if (progress < 1) {\n          requestAnimationFrame(moveAnimation);\n        } else {\n          piece.position.y = 0;\n          piece.userData.row = toRow;\n          piece.userData.col = toCol;\n\n          // Update pieces tracking\n          delete this.pieces[key];\n          this.pieces[`${toRow},${toCol}`] = piece;\n\n          this.animating = false;\n          resolve();\n        }\n      };\n\n      moveAnimation();\n    });\n  }\n\n  /**\n     * Play battle animation when piece is captured\n     */\n  async playBattleSequence(attacker, defender, attackerPos, defenderPos) {\n    logger.info('Playing battle sequence:', attacker.type, 'vs', defender.type);\n\n    if (!this.battleAnimator) return;\n\n    this.animating = true;\n\n    // Convert board coordinates to world coordinates if needed\n    let startPos = attackerPos;\n    let endPos = defenderPos;\n\n    if (attackerPos.r !== undefined && attackerPos.c !== undefined) {\n      startPos = this.boardToWorld(attackerPos.r, attackerPos.c);\n    }\n    if (defenderPos.r !== undefined && defenderPos.c !== undefined) {\n      endPos = this.boardToWorld(defenderPos.r, defenderPos.c);\n    }\n\n    try {\n      await this.battleAnimator.playBattle(\n        attacker,\n        defender,\n        startPos,\n        endPos,\n      );\n    } catch (error) {\n      logger.error('Battle animation failed:', error);\n    }\n\n    this.animating = false;\n  }\n\n  /**\n     * Handle mouse clicks on the 3D scene\n     */\n  onClick(event) {\n    if (this.animating) return;\n\n    // Calculate mouse position in normalized device coordinates\n    const rect = this.renderer.domElement.getBoundingClientRect();\n    this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n\n    // Raycast\n    this.raycaster.setFromCamera(this.mouse, this.camera);\n\n    // Check intersections with pieces and board\n    const allObjects = [\n      this.board,\n      ...Object.values(this.pieces),\n    ];\n\n    const intersects = this.raycaster.intersectObjects(allObjects, true);\n\n    if (intersects.length > 0) {\n      // Find the first object with userData\n      for (const intersect of intersects) {\n        const obj = intersect.object;\n        if (obj.userData && obj.userData.row !== undefined) {\n          // Dispatch custom event with board coordinates\n          const clickEvent = new CustomEvent('board3dclick', {\n            detail: {\n              row: obj.userData.row,\n              col: obj.userData.col,\n              type: obj.userData.type,\n              color: obj.userData.color\n            }\n          });\n          window.dispatchEvent(clickEvent);\n          break;\n        }\n      }\n    }\n  }\n\n\n  /**\n     * Handle window resize\n     */\n  onWindowResize() {\n    if (!this.camera || !this.renderer) return;\n\n    const aspect = this.container.clientWidth / this.container.clientHeight;\n    this.camera.aspect = aspect;\n    this.camera.updateProjectionMatrix();\n\n    this.renderer.setSize(\n      this.container.clientWidth,\n      this.container.clientHeight,\n    );\n  }\n\n  /**\n     * Animation loop\n     */\n  animate() {\n    requestAnimationFrame(this.animate.bind(this));\n\n    // Only render if enabled\n    if (!this.enabled || !this.renderer || !this.scene || !this.camera) {\n      return;\n    }\n\n    // Update controls\n    this.controls?.update();\n\n    // Render scene\n    this.renderer.render(this.scene, this.camera);\n  }\n\n  /**\n     * Toggle 3D mode on/off\n     */\n  toggle(enabled) {\n    this.enabled = enabled;\n\n    if (enabled) {\n      logger.info('3D mode enabled');\n      // Make sure animation loop is running\n      if (!this.scene) {\n        this.init();\n      }\n    } else {\n      logger.info('3D mode disabled');\n    }\n  }\n\n  /**\n     * Change the 3D piece skin\n     * @param {string} skinName - Name of the skin preset\n     */\n  setSkin(skinName) {\n    if (!this.scene) return;\n\n    this.currentSkin = skinName;\n    localStorage.setItem('chessSkin', skinName);\n\n    // Recreate all pieces with the new skin\n    const piecesToRecreate = [];\n    Object.entries(this.pieces).forEach(([key, piece]) => {\n      const { type, color, row, col } = piece.userData;\n      piecesToRecreate.push({ type, color, row, col });\n    });\n\n    // Remove and recreate\n    piecesToRecreate.forEach(({ type, color, row, col }) => {\n      this.removePiece(row, col);\n      this.addPiece(type, color, row, col);\n    });\n\n    logger.info(`3D skin changed to: ${skinName}`);\n  }\n\n  /**\n     * Change the board theme\n     * @param {string} themeName - Name of the theme (classic, blue, green, wood, dark)\n     */\n  setTheme(themeName) {\n    if (!this.boardGroup || !this.scene) return;\n\n    this.currentTheme = themeName;\n    const colors = this.getThemeColors(themeName);\n\n    // Update all board squares\n    this.boardGroup.children.forEach((square) => {\n      if (square.userData.type === 'square') {\n        const isLight = square.userData.isLight;\n        square.material.color.setHex(isLight ? colors.light : colors.dark);\n      }\n    });\n\n    logger.info(`3D board theme changed to: ${themeName}`);\n  }\n\n  /**\n     * Cleanup and dispose\n     */\n  dispose() {\n    logger.info('Disposing 3D scene');\n\n    // Remove event listeners\n    window.removeEventListener('resize', this.onWindowResize);\n    this.renderer?.domElement.removeEventListener('click', this.onClick);\n\n    // Dispose controls\n    this.controls?.dispose();\n\n    // Dispose renderer\n    this.renderer?.dispose();\n\n    // Clear scene\n    if (this.scene) {\n      this.scene.traverse((object) => {\n        if (object.geometry) object.geometry.dispose();\n        if (object.material) {\n          if (Array.isArray(object.material)) {\n            object.material.forEach((m) => m.dispose());\n          } else {\n            object.material.dispose();\n          }\n        }\n      });\n    }\n\n    // Remove canvas\n    if (this.renderer?.domElement) {\n      this.container.removeChild(this.renderer.domElement);\n    }\n\n    this.enabled = false;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/chess-pieces.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/debug.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/effects.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'now' is assigned a value but never used.","line":59,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":59,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Particle Effects System for Schach 9x9\n */\n\nexport class ParticleSystem {\n  constructor() {\n    this.particles = [];\n    this.container = document.getElementById('board-container') || document.body;\n    this.animating = false;\n  }\n\n  spawn(x, y, type, color = '#fff') {\n    const count = type === 'CAPTURE' ? 20 : type === 'MOVE' ? 8 : 15;\n\n    for (let i = 0; i < count; i++) {\n      const p = document.createElement('div');\n      p.className = 'particle';\n\n      // Randomize physics\n      const angle = Math.random() * Math.PI * 2;\n      const speed = Math.random() * 4 + 2;\n      const vx = Math.cos(angle) * speed;\n      const vy = Math.sin(angle) * speed;\n      const life = Math.random() * 0.5 + 0.3; // seconds\n\n      p.style.left = x + 'px';\n      p.style.top = y + 'px';\n      p.style.backgroundColor = color;\n\n      if (type === 'CAPTURE') {\n        p.style.width = (Math.random() * 6 + 2) + 'px';\n        p.style.height = p.style.width;\n        p.style.boxShadow = `0 0 6px ${color}`;\n      } else {\n        p.style.width = '3px';\n        p.style.height = '3px';\n      }\n\n      this.container.appendChild(p);\n\n      this.particles.push({\n        el: p,\n        x, y, vx, vy, life, maxLife: life\n      });\n    }\n\n    if (!this.animating) {\n      this.animating = true;\n      requestAnimationFrame(() => this.update());\n    }\n  }\n\n  update() {\n    if (this.particles.length === 0) {\n      this.animating = false;\n      return;\n    }\n\n    const now = Date.now();\n    // Use fixed time step or delta for smoother animation if needed, \n    // but simple per-frame update is fine for this.\n\n    for (let i = this.particles.length - 1; i >= 0; i--) {\n      const p = this.particles[i];\n      p.life -= 0.016; // approx 60fps\n\n      if (p.life <= 0) {\n        p.el.remove();\n        this.particles.splice(i, 1);\n        continue;\n      }\n\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy += 0.2; // Gravity\n\n      p.el.style.transform = `translate(${p.x - parseFloat(p.el.style.left)}px, ${p.y - parseFloat(p.el.style.top)}px) scale(${p.life / p.maxLife})`;\n      p.el.style.opacity = p.life / p.maxLife;\n    }\n\n    requestAnimationFrame(() => this.update());\n  }\n}\n\nexport const particleSystem = new ParticleSystem();\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/gameController.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'BOARD_SIZE' is defined but never used.","line":1,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":28},{"ruleId":"no-unused-vars","severity":1,"message":"'tutorial' is assigned a value but never used.","line":55,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":55,"endColumn":19},{"ruleId":"no-unused-vars","severity":1,"message":"'winningColor' is assigned a value but never used.","line":428,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":428,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PHASES, BOARD_SIZE } from './gameEngine.js';\nimport { storageManager } from './storage.js';\nimport { SHOP_PIECES, PIECE_VALUES } from './config.js';\nimport * as UI from './ui.js';\nimport { soundManager } from './sounds.js';\nimport { PIECE_SVGS } from './chess-pieces.js';\nimport { logger } from './logger.js';\nimport { Tutorial } from './tutorial.js';\nimport { ArrowRenderer } from './arrows.js';\nimport { StatisticsManager } from './statisticsManager.js';\nimport { puzzleManager } from './puzzleManager.js';\n\n// Piece values for shop\nconst PIECES = SHOP_PIECES;\n\nexport class GameController {\n  constructor(game) {\n    this.game = game;\n    this.clockInterval = null;\n    this.statisticsManager = new StatisticsManager();\n    this.gameStartTime = null;\n  }\n\n  initGame(initialPoints, mode = 'setup') {\n    // Initialize UI\n    UI.initBoardUI(this.game);\n    UI.updateStatus(this.game);\n\n    if (mode === 'setup') {\n      UI.updateShopUI(this.game);\n    } else {\n      // In classic mode, we start directly in PLAY phase\n      this.game.gameStartTime = Date.now();\n      this.startClock();\n\n      // Show game controls immediately\n      const infoTabsContainer = document.getElementById('info-tabs-container');\n      if (infoTabsContainer) infoTabsContainer.classList.remove('hidden');\n\n      const quickActions = document.getElementById('quick-actions');\n      if (quickActions) quickActions.classList.remove('hidden');\n    }\n\n    UI.updateStatistics(this.game);\n    UI.updateClockUI(this.game);\n    UI.updateClockDisplay(this.game);\n\n    // Render board to show corridor highlighting\n    UI.renderBoard(this.game);\n\n    // Initialize Sound Manager\n    soundManager.init();\n\n    // Initialize Tutorial\n    const tutorial = new Tutorial();\n\n    // Initialize Arrow Renderer\n    const boardContainer = document.querySelector('#board').parentElement;\n    if (boardContainer) {\n      this.game.arrowRenderer = new ArrowRenderer(boardContainer);\n    }\n\n    // Start clock update loop\n    if (this.game.clockInterval) clearInterval(this.game.clockInterval);\n    this.game.clockInterval = setInterval(() => {\n      if (this.game.phase === PHASES.PLAY && !this.game.replayMode && this.game.clockEnabled) {\n        const now = Date.now();\n        const delta = (now - this.game.lastMoveTime) / 1000;\n        this.game.lastMoveTime = now;\n\n        if (this.game.turn === 'white') {\n          this.game.whiteTime = Math.max(0, this.game.whiteTime - delta);\n          if (this.game.whiteTime <= 0) {\n            this.game.phase = PHASES.GAME_OVER;\n            this.game.log('Zeit abgelaufen! Schwarz gewinnt.');\n            UI.updateStatus(this.game);\n            soundManager.playGameOver(false);\n          }\n        } else {\n          this.game.blackTime = Math.max(0, this.game.blackTime - delta);\n          if (this.game.blackTime <= 0) {\n            this.game.phase = PHASES.GAME_OVER;\n            this.game.log('Zeit abgelaufen! Wei gewinnt.');\n            UI.updateStatus(this.game);\n            soundManager.playGameOver(false);\n          }\n        }\n        UI.updateClockDisplay(this.game);\n        UI.updateClockUI(this.game);\n      }\n    }, 100);\n\n    logger.info('Game initialized with', initialPoints, 'points in mode:', mode);\n  }\n\n  handleCellClick(r, c) {\n    // Prevent interaction in replay mode\n    if (this.game.replayMode) {\n      return;\n    }\n    // Disable clicks if it's AI's turn\n    if (\n      this.game.isAI &&\n            (this.game.phase === PHASES.SETUP_BLACK_KING ||\n                this.game.phase === PHASES.SETUP_BLACK_PIECES ||\n                (this.game.phase === PHASES.PLAY && this.game.turn === 'black'))\n    ) {\n      return;\n    }\n\n    if (this.game.isAnimating) return; // Block input during animation\n\n    if (this.game.phase === PHASES.SETUP_WHITE_KING) {\n      this.placeKing(r, c, 'white');\n    } else if (this.game.phase === PHASES.SETUP_BLACK_KING) {\n      this.placeKing(r, c, 'black');\n    } else if (\n      this.game.phase === PHASES.SETUP_WHITE_PIECES ||\n            this.game.phase === PHASES.SETUP_BLACK_PIECES\n    ) {\n      this.placeShopPiece(r, c);\n    } else if (this.game.phase === PHASES.PLAY) {\n      if (this.game.handlePlayClick) {\n        this.game.handlePlayClick(r, c);\n      }\n    }\n\n    console.time('Rendering');\n    UI.renderBoard(this.game);\n    console.timeEnd('Rendering');\n  }\n\n  placeKing(r, c, color) {\n    // White at bottom (6), Black at top (0)\n    const validRowStart = color === 'white' ? 6 : 0;\n\n    if (r < validRowStart || r >= validRowStart + 3) {\n      this.game.log('Ungltiger Bereich fr Knig!');\n      return;\n    }\n\n    const colBlock = Math.floor(c / 3);\n    const colStart = colBlock * 3;\n\n    const kingR = validRowStart + 1;\n    const kingC = colStart + 1;\n\n    this.game.board[kingR][kingC] = { type: 'k', color: color, hasMoved: false };\n\n    if (color === 'white') {\n      this.game.whiteCorridor = { rowStart: validRowStart, colStart: colStart };\n      this.game.phase = PHASES.SETUP_BLACK_KING;\n      this.game.log('Weier Knig platziert. Schwarz ist dran.');\n      UI.updateStatus(this.game);\n\n      if (this.game.isAI) {\n        setTimeout(() => {\n          if (this.game.aiSetupKing) this.game.aiSetupKing();\n        }, 1000);\n      }\n    } else {\n      this.game.blackCorridor = { rowStart: validRowStart, colStart: colStart };\n      this.game.phase = PHASES.SETUP_WHITE_PIECES;\n      this.game.points = this.game.initialPoints;\n      UI.updateStatus(this.game);\n      this.showShop(true);\n      this.game.log('Wei kauft ein.');\n    }\n    UI.updateStatus(this.game);\n  }\n\n  selectShopPiece(pieceType) {\n    if (!pieceType) return;\n    const cost = PIECE_VALUES[pieceType];\n    if (cost > this.game.points) {\n      this.game.log('Nicht genug Punkte!');\n      return;\n    }\n\n    this.game.selectedShopPiece = pieceType;\n\n    // Update UI\n    document.querySelectorAll('.shop-btn').forEach(btn => btn.classList.remove('selected'));\n    const btn = document.querySelector(`.shop-btn[data-piece=\"${pieceType}\"]`);\n    if (btn) btn.classList.add('selected');\n\n    const displayEl = document.getElementById('selected-piece-display');\n    // Find the piece info from SHOP_PIECES by matching the symbol\n    const pieceInfo = Object.values(PIECES).find(p => p.symbol === pieceType);\n    const svg = PIECE_SVGS['white'][pieceType];\n    displayEl.innerHTML = `Ausgewhlt: <div style=\"display:inline-block;width:30px;height:30px;vertical-align:middle;\">${svg}</div> ${pieceInfo ? pieceInfo.name : pieceType} (${cost})`;\n  }\n\n  placeShopPiece(r, c) {\n    if (!this.game.selectedShopPiece) {\n      const piece = this.game.board[r][c];\n      const isWhiteTurn = this.game.phase === PHASES.SETUP_WHITE_PIECES;\n      const color = isWhiteTurn ? 'white' : 'black';\n\n      if (piece && piece.color === color && piece.type !== 'k') {\n        const cost =\n                    PIECES[Object.keys(PIECES).find(k => PIECES[k].symbol === piece.type)].points;\n        this.game.points += cost;\n        this.game.board[r][c] = null;\n        this.updateShopUI();\n        this.game.log('Figur entfernt, Punkte erstattet.');\n\n        // Update 3D board if active\n        if (window.battleChess3D && window.battleChess3D.enabled) {\n          window.battleChess3D.removePiece(r, c);\n        }\n      } else {\n        this.game.log('Bitte zuerst eine Figur im Shop auswhlen!');\n      }\n      return;\n    }\n\n    const isWhiteTurn = this.game.phase === PHASES.SETUP_WHITE_PIECES;\n    const color = isWhiteTurn ? 'white' : 'black';\n    const corridor = isWhiteTurn ? this.game.whiteCorridor : this.game.blackCorridor;\n\n    if (\n      r < corridor.rowStart ||\n            r >= corridor.rowStart + 3 ||\n            c < corridor.colStart ||\n            c >= corridor.colStart + 3\n    ) {\n      this.game.log('Muss im eigenen Korridor platziert werden!');\n      return;\n    }\n\n    if (this.game.board[r][c]) {\n      this.game.log('Feld besetzt!');\n      return;\n    }\n\n    const cost = PIECE_VALUES[this.game.selectedShopPiece];\n    if (this.game.points >= cost) {\n      const pieceType = this.game.selectedShopPiece; // Store before clearing\n\n      this.game.board[r][c] = {\n        type: pieceType,\n        color: color,\n        hasMoved: false,\n      };\n      this.game.points -= cost;\n\n      // Clear selection after placing the piece\n      this.game.selectedShopPiece = null;\n\n      // Deselect all shop buttons\n      document.querySelectorAll('.shop-item').forEach(btn => btn.classList.remove('selected'));\n\n      this.updateShopUI();\n\n      // Update 3D board if active\n      if (window.battleChess3D && window.battleChess3D.enabled) {\n        window.battleChess3D.addPiece(pieceType, color, r, c);\n      }\n    }\n  }\n\n  finishSetupPhase() {\n    const handleTransition = () => {\n      if (this.game.phase === PHASES.SETUP_WHITE_PIECES) {\n        this.game.phase = PHASES.SETUP_BLACK_PIECES;\n        this.game.points = this.game.initialPoints;\n        this.game.selectedShopPiece = null;\n        this.updateShopUI();\n        this.game.log('Wei fertig. Schwarz kauft ein.');\n        this.autoSave();\n\n        if (this.game.isAI) {\n          setTimeout(() => {\n            if (this.game.aiSetupPieces) this.game.aiSetupPieces();\n          }, 1000);\n        }\n      } else if (this.game.phase === PHASES.SETUP_BLACK_PIECES) {\n        this.game.phase = PHASES.PLAY;\n        this.showShop(false);\n\n        // Track game start time for statistics\n        this.gameStartTime = Date.now();\n\n        document.querySelectorAll('.cell.selectable-corridor').forEach(cell => {\n          cell.classList.remove('selectable-corridor');\n        });\n        logger.debug('Removed all corridor highlighting for PLAY phase');\n\n        // Ensure Action Bar is visible\n        const actionBar = document.querySelector('.action-bar');\n        if (actionBar) actionBar.classList.remove('hidden');\n\n        this.game.log('Spiel beginnt! Wei ist am Zug.');\n        if (this.game.updateBestMoves) this.game.updateBestMoves();\n        this.startClock();\n        UI.updateStatistics(this.game);\n        soundManager.playGameStart();\n        this.autoSave();\n      }\n      UI.updateStatus(this.game);\n      UI.renderBoard(this.game);\n    };\n\n    // Check for unspent points\n    if (this.game.points > 0) {\n      // Don't warn AI\n      if (this.game.phase === PHASES.SETUP_BLACK_PIECES && this.game.isAI) {\n        handleTransition();\n        return;\n      }\n\n      UI.showModal('Ungewutzte Punkte', `Du hast noch ${this.game.points} Punkte brig! Mchtest du wirklich fortfahren?`, [\n        { text: 'Abbrechen', class: 'btn-secondary' },\n        { text: 'Fortfahren', class: 'btn-primary', callback: handleTransition }\n      ]);\n      return;\n    }\n\n    handleTransition();\n  }\n  setTimeControl(mode) {\n    const controls = {\n      blitz3: { base: 180, increment: 2 },\n      blitz5: { base: 300, increment: 3 },\n      rapid10: { base: 600, increment: 0 },\n      rapid15: { base: 900, increment: 10 },\n      classical30: { base: 1800, increment: 0 },\n    };\n    this.game.timeControl = controls[mode] || controls['blitz5'];\n    this.game.whiteTime = this.game.timeControl.base;\n    this.game.blackTime = this.game.timeControl.base;\n    this.updateClockDisplay();\n  }\n\n  updateClockVisibility() {\n    const clockEl = document.getElementById('chess-clock');\n    if (clockEl) {\n      if (this.game.clockEnabled) {\n        clockEl.classList.remove('hidden');\n      } else {\n        clockEl.classList.add('hidden');\n      }\n    }\n  }\n\n  startClock() {\n    if (!this.game.clockEnabled || this.game.phase !== PHASES.PLAY) return;\n\n    this.stopClock();\n    this.game.lastMoveTime = Date.now();\n    this.clockInterval = setInterval(() => this.tickClock(), 100);\n    this.updateClockUI();\n  }\n\n  stopClock() {\n    if (this.clockInterval) {\n      clearInterval(this.clockInterval);\n      this.clockInterval = null;\n    }\n  }\n\n  tickClock() {\n    if (this.game.phase !== PHASES.PLAY) {\n      this.stopClock();\n      return;\n    }\n\n    const now = Date.now();\n    const elapsed = (now - this.game.lastMoveTime) / 1000;\n    this.game.lastMoveTime = now;\n\n    if (this.game.turn === 'white') {\n      this.game.whiteTime = Math.max(0, this.game.whiteTime - elapsed);\n    } else {\n      this.game.blackTime = Math.max(0, this.game.blackTime - elapsed);\n    }\n\n    this.updateClockDisplay();\n\n    if (this.game.whiteTime <= 0) {\n      this.stopClock();\n      this.game.phase = PHASES.GAME_OVER;\n      this.game.log('Wei hat keine Zeit mehr! Schwarz gewinnt durch Zeitberschreitung.');\n      const overlay = document.getElementById('game-over-overlay');\n      const winnerText = document.getElementById('winner-text');\n      winnerText.textContent = 'Schwarz gewinnt durch Zeitberschreitung!';\n      overlay.classList.remove('hidden');\n\n      // Save to statistics\n      this.saveGameToStatistics('loss', 'white');\n    } else if (this.game.blackTime <= 0) {\n      this.stopClock();\n      this.game.phase = PHASES.GAME_OVER;\n      this.game.log('Schwarz hat keine Zeit mehr! Wei gewinnt durch Zeitberschreitung.');\n      const overlay = document.getElementById('game-over-overlay');\n      const winnerText = document.getElementById('winner-text');\n      winnerText.textContent = 'Wei gewinnt durch Zeitberschreitung!';\n      overlay.classList.remove('hidden');\n\n      // Save to statistics\n      this.saveGameToStatistics('win', 'black');\n    }\n  }\n\n  updateClockDisplay() {\n    UI.updateClockDisplay(this.game);\n  }\n\n  updateClockUI() {\n    UI.updateClockUI(this.game);\n  }\n\n  showShop(show) {\n    UI.showShop(this.game, show);\n  }\n\n  updateShopUI() {\n    UI.updateShopUI(this.game);\n  }\n\n  resign(color) {\n    if (this.game.phase !== PHASES.PLAY) {\n      return;\n    }\n\n    const resigningColor = color || this.game.turn;\n    const winningColor = resigningColor === 'white' ? 'black' : 'white';\n\n    this.game.phase = PHASES.GAME_OVER;\n    UI.renderBoard(this.game);\n    UI.updateStatus(this.game);\n\n    const message =\n            resigningColor === 'white'\n              ? 'Wei gibt auf! Schwarz gewinnt.'\n              : 'Schwarz gibt auf! Wei gewinnt.';\n    this.game.log(message);\n\n    const overlay = document.getElementById('game-over-overlay');\n    const winnerText = document.getElementById('winner-text');\n    winnerText.textContent = message;\n    overlay.classList.remove('hidden');\n\n    soundManager.playGameOver();\n    this.stopClock();\n\n    // Save game to statistics\n    this.saveGameToStatistics('loss', resigningColor);\n  }\n\n  offerDraw(color) {\n    if (this.game.phase !== PHASES.PLAY) {\n      return;\n    }\n\n    // Don't allow multiple pending offers\n    if (this.game.drawOffered) {\n      this.game.log('Es gibt bereits ein offenes Remis-Angebot.');\n      return;\n    }\n\n    this.game.drawOffered = true;\n    this.game.drawOfferedBy = color || this.game.turn;\n\n    const offeringColor = this.game.drawOfferedBy === 'white' ? 'Wei' : 'Schwarz';\n    this.game.log(`${offeringColor} bietet Remis an.`);\n\n    // If AI is the opponent, let AI evaluate and respond\n    if (this.game.isAI) {\n      const aiColor = this.game.turn === 'white' ? 'black' : 'white';\n      if (this.game.turn !== aiColor) {\n        // Player offered draw to AI\n        setTimeout(() => {\n          if (this.game.aiEvaluateDrawOffer) this.game.aiEvaluateDrawOffer();\n        }, 1000);\n      }\n    } else {\n      // Show draw offer dialog to human opponent\n      this.showDrawOfferDialog();\n    }\n  }\n\n  showDrawOfferDialog() {\n    const overlay = document.getElementById('draw-offer-overlay');\n    const message = document.getElementById('draw-offer-message');\n\n    const offeringColor = this.game.drawOfferedBy === 'white' ? 'Wei' : 'Schwarz';\n    message.textContent = `${offeringColor} bietet Remis an. Mchtest du annehmen?`;\n\n    overlay.classList.remove('hidden');\n  }\n\n  acceptDraw() {\n    if (!this.game.drawOffered) {\n      return;\n    }\n\n    this.game.phase = PHASES.GAME_OVER;\n    this.game.drawOffered = false;\n    this.game.drawOfferedBy = null;\n\n    // Hide draw offer dialog\n    const overlay = document.getElementById('draw-offer-overlay');\n    if (overlay) {\n      overlay.classList.add('hidden');\n    }\n\n    UI.renderBoard(this.game);\n    UI.updateStatus(this.game);\n    this.game.log('Remis vereinbart!');\n\n    const gameOverOverlay = document.getElementById('game-over-overlay');\n    const winnerText = document.getElementById('winner-text');\n    winnerText.textContent = 'Remis vereinbart';\n    gameOverOverlay.classList.remove('hidden');\n\n    // Save game to statistics\n    this.saveGameToStatistics('draw', null);\n  }\n\n  declineDraw() {\n    if (!this.game.drawOffered) {\n      return;\n    }\n\n    const decliningColor =\n            this.game.turn === this.game.drawOfferedBy ? (this.game.turn === 'white' ? 'black' : 'white') : this.game.turn;\n    this.game.log(`${decliningColor === 'white' ? 'Wei' : 'Schwarz'} lehnt das Remis-Angebot ab.`);\n\n    this.game.drawOffered = false;\n    this.game.drawOfferedBy = null;\n\n    // Hide draw offer dialog\n    const overlay = document.getElementById('draw-offer-overlay');\n    if (overlay) {\n      overlay.classList.add('hidden');\n    }\n  }\n\n  saveGame() {\n    if (storageManager.saveGame(this.game)) {\n      this.game.log(' Spiel erfolgreich gespeichert!');\n      soundManager.playMove(); // Feedback sound\n    } else {\n      this.game.log(' Fehler beim Speichern.');\n    }\n  }\n\n  loadGame() {\n    let state;\n    try {\n      state = storageManager.loadGame();\n      if (!state) {\n        this.game.log(' Kein gespeichertes Spiel gefunden.');\n        return;\n      }\n    } catch (e) {\n      this.game.log(' Fehler beim Laden: ' + e.message);\n      return;\n    }\n\n    // Stop any running clock before loading\n    this.stopClock();\n\n    // Restore state\n    if (storageManager.loadStateIntoGame(this.game, state)) {\n      this.game.log(' Spielstand geladen.');\n    } else {\n      this.game.log(' Fehler beim Laden des Spielstands.');\n      return;\n    }\n\n    // Re-initialize UI components\n    UI.renderBoard(this.game);\n    UI.updateStatus(this.game);\n    UI.updateShopUI(this.game);\n    UI.updateStatistics(this.game);\n    UI.updateClockUI(this.game);\n    UI.updateClockDisplay(this.game);\n\n    // Restore captured pieces display\n    // We need to clear and re-add them\n    const whiteCaptured = document.getElementById('captured-white');\n    const blackCaptured = document.getElementById('captured-black');\n    if (whiteCaptured) whiteCaptured.innerHTML = '';\n    if (blackCaptured) blackCaptured.innerHTML = '';\n\n    // Re-populate captured pieces\n    if (this.game.capturedPieces) {\n      if (this.game.capturedPieces.white) {\n        this.game.capturedPieces.white.forEach(piece => {\n          UI.addCapturedPiece(piece);\n        });\n      }\n      if (this.game.capturedPieces.black) {\n        this.game.capturedPieces.black.forEach(piece => {\n          UI.addCapturedPiece(piece);\n        });\n      }\n    }\n\n    // Restore move history panel\n    const moveHistoryPanel = document.getElementById('move-history-panel');\n    if (moveHistoryPanel) {\n      // Clear existing history\n      const historyList = document.getElementById('move-history');\n      if (historyList) historyList.innerHTML = '';\n\n      // Re-populate history\n      if (this.game.history) {\n        this.game.history.forEach((move, index) => {\n          UI.addMoveToHistory(move, index + 1);\n        });\n        // Scroll to bottom\n        if (historyList) historyList.scrollTop = historyList.scrollHeight;\n      }\n\n      if (this.game.phase === PHASES.PLAY) {\n        moveHistoryPanel.classList.remove('hidden');\n      }\n    }\n\n    // Restart clock if needed\n    if (this.game.phase === PHASES.PLAY && this.game.clockEnabled) {\n      this.startClock();\n    }\n\n    // Trigger AI actions if in setup phase\n    if (this.game.isAI) {\n      if (this.game.phase === PHASES.SETUP_BLACK_KING) {\n        // AI needs to place black king\n        setTimeout(() => {\n          if (this.game.aiSetupKing) this.game.aiSetupKing();\n        }, 1000);\n      } else if (this.game.phase === PHASES.SETUP_BLACK_PIECES) {\n        // AI needs to place black pieces\n        setTimeout(() => {\n          if (this.game.aiSetupPieces) this.game.aiSetupPieces();\n        }, 1000);\n      }\n    }\n\n    this.game.log(' Spiel erfolgreich geladen!');\n    soundManager.playGameStart(); // Feedback sound\n\n  }\n\n  autoSave() {\n    if (this.game.mode !== 'puzzle' && storageManager.saveGame(this.game)) {\n      // Silently success or debug log\n      logger.debug('Auto-saved game');\n    }\n  }\n\n  startPuzzleMode() {\n    const puzzle = puzzleManager.loadPuzzle(this.game);\n    if (puzzle) {\n      UI.showPuzzleOverlay(puzzle);\n      UI.renderBoard(this.game);\n      UI.updateStatus(this.game);\n      // Ensure UI controls are appropriate\n      this.showShop(false);\n    }\n  }\n\n  nextPuzzle() {\n    const puzzle = puzzleManager.nextPuzzle(this.game);\n    if (puzzle) {\n      UI.showPuzzleOverlay(puzzle);\n      UI.renderBoard(this.game);\n      UI.updateStatus(this.game);\n    } else {\n      UI.updatePuzzleStatus('success', 'Alle Puzzles gelst!');\n    }\n  }\n\n  exitPuzzleMode() {\n    UI.hidePuzzleOverlay();\n    // Return to main menu or restart\n    location.reload();\n  }\n\n\n  // ===== ANALYSIS MODE METHODS =====\n\n  enterAnalysisMode() {\n    // Can only analyze during play phase\n    if (this.game.phase !== PHASES.PLAY) {\n      this.game.log(' Analyse-Modus nur whrend des Spiels verfgbar.');\n      return false;\n    }\n\n    // Save current game state\n    this.game.analysisBasePosition = {\n      board: JSON.parse(JSON.stringify(this.game.board)),\n      turn: this.game.turn,\n      moveHistory: [...this.game.moveHistory],\n      redoStack: [...this.game.redoStack],\n      lastMove: this.game.lastMove ? { ...this.game.lastMove } : null,\n      lastMoveHighlight: this.game.lastMoveHighlight ? { ...this.game.lastMoveHighlight } : null,\n      selectedSquare: this.game.selectedSquare,\n      validMoves: this.game.validMoves,\n      halfMoveClock: this.game.halfMoveClock,\n      positionHistory: [...this.game.positionHistory]\n    };\n\n    // Enter analysis mode\n    this.game.analysisMode = true;\n    this.game.phase = PHASES.ANALYSIS;\n\n    // Stop clock\n    this.stopClock();\n\n    // Clear selection\n    this.game.selectedSquare = null;\n    this.game.validMoves = null;\n\n    // Show analysis panel\n    const analysisPanel = document.getElementById('analysis-panel');\n    if (analysisPanel) {\n      analysisPanel.classList.remove('hidden');\n    }\n\n    UI.updateStatus(this.game);\n    UI.renderBoard(this.game);\n    UI.renderEvalGraph(this.game);\n\n    this.game.log(' Analyse-Modus aktiviert. Zge lsen keine KI-Reaktion aus.');\n\n    // Start continuous analysis if enabled\n    if (this.game.continuousAnalysis && this.game.aiController) {\n      this.requestPositionAnalysis();\n    }\n\n    return true;\n  }\n\n  exitAnalysisMode(restore = true) {\n    if (!this.game.analysisMode) {\n      return false;\n    }\n\n    if (restore && this.game.analysisBasePosition) {\n      // Restore saved position\n      this.game.board = JSON.parse(JSON.stringify(this.game.analysisBasePosition.board));\n      this.game.turn = this.game.analysisBasePosition.turn;\n      this.game.moveHistory = [...this.game.analysisBasePosition.moveHistory];\n      this.game.redoStack = [...this.game.analysisBasePosition.redoStack];\n      this.game.lastMove = this.game.analysisBasePosition.lastMove ? { ...this.game.analysisBasePosition.lastMove } : null;\n      this.game.lastMoveHighlight = this.game.analysisBasePosition.lastMoveHighlight ? { ...this.game.analysisBasePosition.lastMoveHighlight } : null;\n      this.game.selectedSquare = this.game.analysisBasePosition.selectedSquare;\n      this.game.validMoves = this.game.analysisBasePosition.validMoves;\n      this.game.halfMoveClock = this.game.analysisBasePosition.halfMoveClock;\n      this.game.positionHistory = [...this.game.analysisBasePosition.positionHistory];\n    }\n\n    // Exit analysis mode\n    this.game.analysisMode = false;\n    this.game.phase = PHASES.PLAY;\n    this.game.analysisBasePosition = null;\n    this.game.analysisVariations = [];\n\n    // Hide analysis panel\n    const analysisPanel = document.getElementById('analysis-panel');\n    if (analysisPanel) {\n      analysisPanel.classList.add('hidden');\n    }\n\n    // Restart clock if enabled\n    if (this.game.clockEnabled) {\n      this.startClock();\n    }\n\n    UI.updateStatus(this.game);\n    UI.renderBoard(this.game);\n    UI.renderEvalGraph(this.game);\n\n    const message = restore ? ' Analyse-Modus beendet. Position wiederhergestellt.' : ' Analyse-Modus beendet. Aktuelle Position behalten.';\n    this.game.log(message);\n\n    return true;\n  }\n\n  requestPositionAnalysis() {\n    // Request analysis from AI controller\n    if (!this.game.aiController || !this.game.aiController.analyzePosition) {\n      return;\n    }\n\n    this.game.aiController.analyzePosition();\n  }\n\n  toggleContinuousAnalysis() {\n    this.game.continuousAnalysis = !this.game.continuousAnalysis;\n\n    if (this.game.continuousAnalysis && this.game.analysisMode) {\n      this.requestPositionAnalysis();\n      this.game.log(' Kontinuierliche Analyse aktiviert.');\n    } else {\n      this.game.log(' Kontinuierliche Analyse deaktiviert.');\n    }\n  }\n\n  /**\n     * Jumps to a specific move in the game history (for analysis).\n     * @param {number} moveIndex - Index of the move in moveHistory\n     */\n  jumpToMove(moveIndex) {\n    if (!this.game.moveController || !this.game.moveController.reconstructBoardAtMove) {\n      return;\n    }\n\n    this.game.moveController.reconstructBoardAtMove(moveIndex);\n    this.game.replayPosition = moveIndex;\n\n    UI.renderBoard(this.game);\n    UI.updateStatus(this.game);\n\n    if (this.game.continuousAnalysis) {\n      this.requestPositionAnalysis();\n    }\n  }\n\n  /**\n     * Jumps to the initial game position (for analysis).\n     */\n  jumpToStart() {\n    if (!this.game.moveController || !this.game.moveController.reconstructBoardAtMove) {\n      return;\n    }\n\n    this.game.moveController.reconstructBoardAtMove(0);\n    this.game.replayPosition = -1;\n\n    UI.renderBoard(this.game);\n    UI.updateStatus(this.game);\n  }\n\n  /**\n     * Saves completed game to statistics\n     * @param {string} result - 'win', 'loss', or 'draw'\n     * @param {string} losingColor - Color that lost (only for win/loss)\n     */\n  saveGameToStatistics(result, losingColor = null) {\n    if (!this.gameStartTime) {\n      logger.warn('Game start time not set, skipping statistics save');\n      return;\n    }\n\n    // Determine player color (assuming player is always white when playing against AI)\n    const playerColor = 'white';\n\n    // Determine opponent\n    let opponent = 'Human';\n    if (this.game.isAI) {\n      const difficultyMap = {\n        'beginner': 'AI-Anfnger',\n        'easy': 'AI-Einfach',\n        'medium': 'AI-Mittel',\n        'hard': 'AI-Schwer',\n        'expert': 'AI-Experte'\n      };\n      opponent = difficultyMap[this.game.difficulty] || 'AI';\n    }\n\n    // Determine actual result from player's perspective\n    let playerResult = result;\n    if (result === 'loss') {\n      // If player lost (white resigned or got mated)\n      playerResult = losingColor === 'white' ? 'loss' : 'win';\n    } else if (result === 'win') {\n      // If someone won\n      playerResult = losingColor === 'black' ? 'win' : 'loss';\n    }\n\n    const gameData = {\n      result: playerResult,\n      playerColor: playerColor,\n      opponent: opponent,\n      moveHistory: this.game.moveHistory || [],\n      duration: Date.now() - this.gameStartTime,\n      finalPosition: JSON.stringify(this.game.board)\n    };\n\n    this.statisticsManager.saveGame(gameData);\n    this.gameStartTime = null;\n    logger.info('Game saved to statistics:', playerResult, 'vs', opponent);\n  }\n}\n\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/gameEngine.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/logger.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/main.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'ArrowRenderer' is defined but never used.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":23},{"ruleId":"no-unused-vars","severity":1,"message":"'debounce' is defined but never used.","line":10,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Game } from './gameEngine.js';\nimport { GameController } from './gameController.js';\nimport { MoveController } from './moveController.js';\nimport { AIController } from './aiController.js';\nimport { TutorController } from './tutorController.js';\nimport { logger } from './logger.js';\nimport { ArrowRenderer } from './arrows.js';\nimport * as UI from './ui.js';\nimport { soundManager } from './sounds.js';\nimport { debounce } from './utils.js';\nimport { BOARD_SIZE, PHASES } from './gameEngine.js';\nimport { storageManager } from './storage.js';\nimport { BattleChess3D } from './battleChess3D.js';\n\n// Register Service Worker for PWA\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker.register('./service-worker.js')\n      .then(registration => {\n        logger.info('ServiceWorker registration successful with scope: ', registration.scope);\n      })\n      .catch(err => {\n        logger.error('ServiceWorker registration failed: ', err);\n      });\n  });\n}\n\nlogger.info('main.js loaded (Refactored)');\n\n// Global game instance\nlet game = null;\nlet kbRow = 0;\nlet kbCol = 0;\nlet battleChess3D = null; // 3D mode instance\n\n// --- Initialization ---\n\nasync function initGame(initialPoints, mode = 'setup') {\n  try {\n    game = new Game(initialPoints, mode);\n    window.game = game;\n\n    // Initialize controllers\n    game.gameController = new GameController(game);\n    game.moveController = new MoveController(game);\n    game.aiController = new AIController(game);\n\n    // Make controllers accessible to each other\n    game.aiController.game = game;\n    game.gameController.game = game;\n    game.moveController.game = game;\n    game.tutorController = new TutorController(game);\n\n    // --- Delegate Game.prototype methods to controllers ---\n\n    // GameController delegations\n    Game.prototype.placeKing = function (r, c, color) { return this.gameController.placeKing(r, c, color); };\n    Game.prototype.selectShopPiece = function (type) { return this.gameController.selectShopPiece(type); };\n    Game.prototype.placeShopPiece = function (r, c) { return this.gameController.placeShopPiece(r, c); };\n    Game.prototype.finishSetupPhase = function () { return this.gameController.finishSetupPhase(); };\n    Game.prototype.setTimeControl = function (mode) { return this.gameController.setTimeControl(mode); };\n    Game.prototype.updateClockVisibility = function () { return this.gameController.updateClockVisibility(); };\n    Game.prototype.startClock = function () { return this.gameController.startClock(); };\n    Game.prototype.stopClock = function () { return this.gameController.stopClock(); };\n    Game.prototype.tickClock = function () { return this.gameController.tickClock(); };\n    Game.prototype.updateClockDisplay = function () { return this.gameController.updateClockDisplay(); };\n    Game.prototype.updateClockUI = function () { return this.gameController.updateClockUI(); };\n    Game.prototype.showShop = function (show) { return this.gameController.showShop(show); };\n    Game.prototype.updateShopUI = function () { return this.gameController.updateShopUI(); };\n    Game.prototype.handleCellClick = function (r, c) { return this.gameController.handleCellClick(r, c); };\n    Game.prototype.resign = function (color) { return this.gameController.resign(color); };\n    Game.prototype.offerDraw = function (color) { return this.gameController.offerDraw(color); };\n    Game.prototype.acceptDraw = function () { return this.gameController.acceptDraw(); };\n    Game.prototype.declineDraw = function () { return this.gameController.declineDraw(); };\n    Game.prototype.showDrawOfferDialog = function () { return this.gameController.showDrawOfferDialog(); };\n\n    // MoveController delegations\n    Game.prototype.handlePlayClick = function (r, c) { return this.moveController.handlePlayClick(r, c); };\n    Game.prototype.executeMove = function (from, to) { return this.moveController.executeMove(from, to); };\n    Game.prototype.showPromotionUI = function (r, c, color, record) { return this.moveController.showPromotionUI(r, c, color, record); };\n    Game.prototype.animateMove = function (from, to, piece) { return this.moveController.animateMove(from, to, piece); };\n    Game.prototype.finishMove = function () { return this.moveController.finishMove(); };\n    Game.prototype.undoMove = function () { return this.moveController.undoMove(); };\n    Game.prototype.redoMove = function () { return this.moveController.redoMove(); };\n    Game.prototype.checkDraw = function () { return this.moveController.checkDraw(); };\n    Game.prototype.isInsufficientMaterial = function () { return this.moveController.isInsufficientMaterial(); };\n    Game.prototype.getBoardHash = function () { return this.moveController.getBoardHash(); };\n    Game.prototype.saveGame = function () { return this.gameController.saveGame(); };\n    Game.prototype.loadGame = function () { return this.gameController.loadGame(); };\n    Game.prototype.autoSave = function (show) {\n      if (this.moveController.autoSave) return this.moveController.autoSave(show);\n    };\n\n    Game.prototype.updateMoveHistoryUI = function () { UI.updateMoveHistoryUI(this); };\n    Game.prototype.updateUndoRedoButtons = function () { return this.moveController.updateUndoRedoButtons(); };\n    Game.prototype.updateCapturedUI = function () { UI.updateCapturedUI(this); };\n    Game.prototype.animateCheck = function (color) { UI.animateCheck(this, color); };\n    Game.prototype.animateCheckmate = function (color) { UI.animateCheckmate(this, color); };\n    Game.prototype.calculateMaterialAdvantage = function () { return this.moveController.calculateMaterialAdvantage(); };\n    Game.prototype.getMaterialValue = function (piece) { return this.moveController.getMaterialValue(piece); };\n    Game.prototype.updateStatistics = function () { UI.updateStatistics(this); };\n\n    // Replay methods\n    Game.prototype.enterReplayMode = function () { return this.moveController.enterReplayMode(); };\n    Game.prototype.exitReplayMode = function () { return this.moveController.exitReplayMode(); };\n    Game.prototype.replayFirst = function () { return this.moveController.replayFirst(); };\n    Game.prototype.replayPrevious = function () { return this.moveController.replayPrevious(); };\n    Game.prototype.replayNext = function () { return this.moveController.replayNext(); };\n    Game.prototype.replayLast = function () { return this.moveController.replayLast(); };\n    Game.prototype.updateReplayUI = function () { return this.moveController.updateReplayUI(); };\n    Game.prototype.reconstructBoardAtMove = function (idx) { return this.moveController.reconstructBoardAtMove(idx); };\n    Game.prototype.undoMoveForReplay = function (move) { return this.moveController.undoMoveForReplay(move); };\n    Game.prototype.setTheme = function (theme) { return this.moveController.setTheme(theme); };\n    Game.prototype.applyTheme = function (theme) { return this.moveController.applyTheme(theme); };\n\n    // AI delegations\n    Game.prototype.aiSetupKing = function () { return this.aiController.aiSetupKing(); };\n    Game.prototype.aiSetupPieces = function () { return this.aiController.aiSetupPieces(); };\n    Game.prototype.aiMove = function () { return this.aiController.aiMove(); };\n    Game.prototype.evaluateMove = function (move) { return this.aiController.evaluateMove(move); };\n    Game.prototype.getBestMoveMinimax = function (moves, depth) { return this.aiController.getBestMoveMinimax(moves, depth); };\n    Game.prototype.minimax = function (move, depth, isMax, alpha, beta) { return this.aiController.minimax(move, depth, isMax, alpha, beta); };\n    Game.prototype.quiescenceSearch = function (alpha, beta, isMax) { return this.aiController.quiescenceSearch(alpha, beta, isMax); };\n    Game.prototype.evaluatePosition = function (color) { return this.aiController.evaluatePosition(color); };\n    Game.prototype.updateAIProgress = function (data) { return this.aiController.updateAIProgress(data); };\n    Game.prototype.aiEvaluateDrawOffer = function () { return this.aiController.aiEvaluateDrawOffer(); };\n    Game.prototype.aiShouldOfferDraw = function () { return this.aiController.aiShouldOfferDraw(); };\n    Game.prototype.aiShouldResign = function () { return this.aiController.aiShouldResign(); };\n\n    // Tutor delegations\n    Game.prototype.updateBestMoves = function () { return this.tutorController.updateBestMoves(); };\n    Game.prototype.isTutorMove = function (from, to) { return this.tutorController.isTutorMove(from, to); };\n    Game.prototype.getTutorHints = function () { return this.tutorController.getTutorHints(); };\n    Game.prototype.getMoveNotation = function (move) { return this.tutorController.getMoveNotation(move); };\n    Game.prototype.showTutorSuggestions = function () { return this.tutorController.showTutorSuggestions(); };\n    Game.prototype.getPieceName = function (type) { return this.tutorController.getPieceName(type); };\n    Game.prototype.getThreatenedPieces = function (pos, color) { return this.tutorController.getThreatenedPieces(pos, color); };\n    Game.prototype.detectTacticalPatterns = function (move) { return this.tutorController.detectTacticalPatterns(move); };\n    Game.prototype.getDefendedPieces = function (pos, color) { return this.tutorController.getDefendedPieces(pos, color); };\n    Game.prototype.analyzeStrategicValue = function (move) { return this.tutorController.analyzeStrategicValue(move); };\n    Game.prototype.getScoreDescription = function (score) { return this.tutorController.getScoreDescription(score); };\n    Game.prototype.analyzeMoveWithExplanation = function (move, score, best) { return this.tutorController.analyzeMoveWithExplanation(move, score, best); };\n\n    // Initialize GameController logic\n    game.gameController.initGame(initialPoints, mode);\n\n    // Initialize 3D Battle Chess mode\n    const container3D = document.getElementById('battle-chess-3d-container');\n    if (container3D && !battleChess3D) {\n      battleChess3D = new BattleChess3D(container3D);\n      window.battleChess3D = battleChess3D;\n\n      // Listen for 3D board clicks\n      container3D.addEventListener('board3dclick', (event) => {\n        const { row, col } = event.detail;\n        if (game && game.phase === PHASES.PLAY) {\n          game.handleCellClick(row, col);\n        }\n      });\n    }\n\n    // Check for autosaved game\n    if (storageManager.hasSave()) {\n      checkSavedGame();\n    }\n\n  } catch (error) {\n    console.error('Error initializing game:', error);\n    alert('Fehler beim Starten des Spiels. Bitte Konsole prfen.');\n  }\n}\n\nfunction focusCell(r, c) {\n  document.querySelectorAll('.cell').forEach(cell => cell.classList.remove('keyboard-focus'));\n  const cell = document.querySelector(`.cell[data-r=\"${r}\"][data-c=\"${c}\"]`);\n  if (cell) {\n    cell.classList.add('keyboard-focus');\n    cell.focus();\n  }\n}\n\nfunction checkSavedGame() {\n  const saveData = storageManager.loadGame();\n  if (!saveData) return;\n\n  try {\n    if (saveData.timestamp) {\n      const hoursAgo = Math.floor((Date.now() - saveData.timestamp) / (1000 * 60 * 60));\n      const timeAgo =\n        hoursAgo < 1\n          ? 'vor weniger als 1 Stunde'\n          : hoursAgo === 1\n            ? 'vor 1 Stunde'\n            : `vor ${hoursAgo} Stunden`;\n\n      const restoreDialog = document.createElement('div');\n      restoreDialog.id = 'restore-dialog';\n      restoreDialog.className = 'modal-overlay';\n      restoreDialog.innerHTML = `\n          <div class=\"modal-content\">\n            <h2> Gespeichertes Spiel gefunden</h2>\n            <p>Mchtest du das Spiel fortsetzen?</p>\n            <div class=\"save-info\">\n              <p> Gespeichert: ${timeAgo}</p>\n              <p> Zge gespielt: <strong>${(saveData.moveHistory && saveData.moveHistory.length) || 0}</strong></p>\n              <p> Spieler: ${saveData.turn === 'white' ? 'Wei' : 'Schwarz'} am Zug</p>\n            </div>\n            <div class=\"modal-buttons\">\n              <button id=\"restore-yes\" class=\"btn-primary\"> Fortsetzen</button>\n              <button id=\"restore-no\" class=\"btn-secondary\"> Neues Spiel</button>\n            </div>\n          </div>\n      `;\n      document.body.appendChild(restoreDialog);\n\n      document.getElementById('restore-yes').onclick = () => {\n        window.game.loadGame(); // Calls GameController.loadGame -> storageManager.loadGame\n        restoreDialog.remove();\n      };\n\n      document.getElementById('restore-no').onclick = () => {\n        localStorage.removeItem('schach9x9_save_autosave'); // Or storageManager.clearSave()?\n        restoreDialog.remove();\n      };\n    }\n  } catch (e) {\n    console.error('Failed to parse saved game:', e);\n  }\n}\n\n// --- DOM Event Listeners ---\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const pointsOverlay = document.getElementById('points-selection-overlay');\n\n  // Handle points selection\n  document.querySelectorAll('.points-btn').forEach(btn => {\n    btn.addEventListener('click', () => {\n      const points = parseInt(btn.dataset.points);\n      if (points) {\n        pointsOverlay.classList.add('hidden');\n        pointsOverlay.style.display = 'none';\n        initGame(points, 'setup');\n      }\n    });\n  });\n\n  const classicBtn = document.getElementById('classic-mode-btn');\n  if (classicBtn) {\n    classicBtn.addEventListener('click', () => {\n      pointsOverlay.classList.add('hidden');\n      pointsOverlay.style.display = 'none';\n      initGame(15, 'classic'); // Points don't matter for classic, but passing default\n    });\n  }\n\n  setupGlobalListeners();\n});\n\nfunction setupGlobalListeners() {\n  // --- Menu Overlay Logic ---\n  const menuBtn = document.getElementById('menu-btn');\n  const menuOverlay = document.getElementById('menu-overlay');\n  const menuCloseBtn = document.getElementById('menu-close-btn');\n\n  function toggleMenu(show) {\n    if (show) {\n      menuOverlay.classList.remove('hidden');\n    } else {\n      menuOverlay.classList.add('hidden');\n    }\n  }\n\n  if (menuBtn) menuBtn.addEventListener('click', () => toggleMenu(true));\n  if (menuCloseBtn) menuCloseBtn.addEventListener('click', () => toggleMenu(false));\n\n  // Close menu when clicking outside content\n  if (menuOverlay) {\n    menuOverlay.addEventListener('click', (e) => {\n      if (e.target === menuOverlay) toggleMenu(false);\n    });\n  }\n\n  // --- Info Overlay Logic ---\n  const infoToggleBtn = document.getElementById('info-toggle-btn');\n  const infoOverlay = document.getElementById('info-overlay');\n  const infoCloseBtn = document.getElementById('info-close-btn');\n\n  function toggleInfo(show) {\n    if (show) {\n      infoOverlay.classList.remove('hidden');\n      // Refresh logs/history when opening\n      if (window.game) {\n        UI.updateMoveHistoryUI(window.game);\n        // UI.updateLogUI(window.game); // If you have a separate log update\n      }\n    } else {\n      infoOverlay.classList.add('hidden');\n    }\n  }\n\n  if (infoToggleBtn) infoToggleBtn.addEventListener('click', () => toggleInfo(true));\n  if (infoCloseBtn) infoCloseBtn.addEventListener('click', () => toggleInfo(false));\n\n  // Tab Switching for Info Overlay\n  const tabButtons = document.querySelectorAll('.tab-btn');\n  const tabPanes = document.querySelectorAll('.tab-pane');\n\n  tabButtons.forEach(btn => {\n    btn.addEventListener('click', () => {\n      // Deactivate all\n      tabButtons.forEach(b => b.classList.remove('active'));\n      tabPanes.forEach(p => p.classList.remove('active'));\n\n      // Activate clicked\n      btn.classList.add('active');\n      const tabId = btn.dataset.tab;\n      const pane = document.getElementById(`tab-${tabId}`);\n      if (pane) pane.classList.add('active');\n    });\n  });\n\n  // --- Action Bar Buttons ---\n  const undoBtn = document.getElementById('undo-btn');\n  const hintBtn = document.getElementById('hint-btn');\n\n  if (undoBtn) {\n    undoBtn.addEventListener('click', () => {\n      if (window.game && window.game.moveHistory.length > 0 && window.game.phase === PHASES.PLAY) {\n        window.game.undoMove();\n      }\n    });\n  }\n\n  if (hintBtn) {\n    hintBtn.addEventListener('click', () => {\n      if (window.game && window.game.phase === PHASES.PLAY) {\n        window.game.showTutorSuggestions();\n      }\n    });\n  }\n\n  // 3D Mode Toggle\n  const toggle3DBtn = document.getElementById('toggle-3d-btn');\n  if (toggle3DBtn) {\n    toggle3DBtn.addEventListener('click', () => {\n      if (!window.battleChess3D || !window.game) return;\n\n      const container3D = document.getElementById('battle-chess-3d-container');\n      const board2D = document.getElementById('board-wrapper');\n      const isEnabled = container3D.classList.contains('active');\n\n      if (isEnabled) {\n        // Disable 3D mode - show 2D board\n        container3D.classList.remove('active');\n        toggle3DBtn.classList.remove('active-3d');\n        window.battleChess3D.toggle(false);\n\n        // Fade out 3D, fade in 2D\n        setTimeout(() => {\n          if (board2D) board2D.style.opacity = '1';\n        }, 300);\n\n        soundManager.playMove();\n      } else {\n        // Enable 3D mode - hide 2D board\n        toggle3DBtn.classList.add('active-3d');\n\n        // Fade out 2D first\n        if (board2D) {\n          board2D.style.transition = 'opacity 0.3s';\n          board2D.style.opacity = '0';\n        }\n\n        // Show 3D after fade\n        setTimeout(() => {\n          container3D.classList.add('active');\n\n          // Initialize 3D scene if not already done\n          if (!window.battleChess3D.scene) {\n            window.battleChess3D.init().then(() => {\n              window.battleChess3D.updateFromGameState(window.game);\n              window.battleChess3D.toggle(true);\n            });\n          } else {\n            window.battleChess3D.updateFromGameState(window.game);\n            window.battleChess3D.toggle(true);\n          }\n        }, 300);\n\n        soundManager.playCapture();\n      }\n    });\n  }\n\n  // Unified Skin Selector (for both 2D and 3D)\n  const skinSelector = document.getElementById('skin-selector');\n  if (skinSelector) {\n    // Clean up old localStorage keys\n    const oldSkin1 = localStorage.getItem('chessSkin');\n    const oldSkin2 = localStorage.getItem('schach9x9_skin');\n\n    // Remove old keys if they exist\n    if (oldSkin1) localStorage.removeItem('chessSkin');\n    if (oldSkin2) localStorage.removeItem('schach9x9_skin');\n\n    // Get saved skin or default to 'classic'\n    let savedSkin = localStorage.getItem('selectedSkin');\n\n    // If no valid skin is saved, use 'classic' and persist it\n    if (!savedSkin) {\n      savedSkin = 'classic';\n      localStorage.setItem('selectedSkin', 'classic');\n      console.log('No saved skin found, defaulting to classic');\n    }\n\n    // Load chess pieces module and set skin\n    import('./chess-pieces.js').then(chessPiecesModule => {\n      window.setPieceSkin = chessPiecesModule.setPieceSkin;\n      window.getAvailableSkins = chessPiecesModule.getAvailableSkins;\n\n      // Apply saved or default skin\n      if (window.setPieceSkin) {\n        window.setPieceSkin(savedSkin);\n        console.log(`Loaded skin: ${savedSkin}`);\n      }\n\n      // Set initial value for the selector\n      skinSelector.value = savedSkin;\n\n      // Re-render 2D board if game exists\n      if (window.game) {\n        import('./ui.js').then(UI => UI.renderBoard(window.game));\n      }\n    });\n\n    if (window.battleChess3D) {\n      window.battleChess3D.currentSkin = savedSkin;\n    }\n\n    // Tutor Mode Selector\n    const tutorModeSelect = document.getElementById('tutor-mode-select');\n    if (tutorModeSelect) {\n      tutorModeSelect.addEventListener('change', (e) => {\n        window.game.tutorMode = e.target.value;\n        window.game.log(`Tutor-Modus auf \"${e.target.value}\" gendert.`);\n      });\n    }\n\n    // Handle skin changes\n    skinSelector.addEventListener('change', (e) => {\n      const newSkin = e.target.value;\n\n      // Save to localStorage with consistent key\n      localStorage.setItem('selectedSkin', newSkin);\n      console.log(`Skin changed to: ${newSkin}`);\n\n      // Update 2D pieces\n      import('./chess-pieces.js').then(module => {\n        if (module.setPieceSkin(newSkin)) {\n          // Clear SVG cache to force re-render of new skin\n          window._svgCache = {};\n\n          // Force full re-render of the board\n          if (window.game) {\n            window.game._forceFullRender = true;\n            // Reset previous board state to ensure diffing triggers\n            window.game._previousBoardState = null;\n          }\n\n          // Re-render 2D board\n          import('./ui.js').then(UI => {\n            if (window.game) UI.renderBoard(window.game);\n          });\n        }\n      });\n\n      // Update 3D pieces\n      if (window.battleChess3D) {\n        window.battleChess3D.setSkin(newSkin);\n      }\n\n      soundManager.playMove();\n    });\n  }\n\n\n  // --- Menu Actions ---\n  document.getElementById('puzzle-mode-btn').addEventListener('click', () => {\n    if (window.game) {\n      window.game.gameController.startPuzzleMode();\n      toggleMenu(false);\n    }\n  });\n\n  document.getElementById('restart-btn').addEventListener('click', () => location.reload());\n\n  document.getElementById('save-btn').addEventListener('click', () => {\n    if (window.game) {\n      window.game.saveGame();\n      toggleMenu(false);\n    }\n  });\n\n  document.getElementById('load-btn').addEventListener('click', () => {\n    if (window.game) {\n      window.game.loadGame();\n      toggleMenu(false);\n    }\n  });\n\n  document.getElementById('resign-btn').addEventListener('click', () => {\n    if (window.game && window.game.phase === PHASES.PLAY) {\n      toggleMenu(false);\n      const overlay = document.getElementById('confirmation-overlay');\n      const message = document.getElementById('confirmation-message');\n      message.textContent = 'Mchtest du wirklich aufgeben?';\n      overlay.classList.remove('hidden');\n\n      window.game.pendingConfirmation = () => {\n        const color = window.game.isAI ? 'white' : window.game.turn;\n        window.game.resign(color);\n      };\n    } else {\n      alert('Du kannst nur whrend des Spiels aufgeben.');\n    }\n  });\n\n  document.getElementById('draw-offer-btn').addEventListener('click', () => {\n    if (window.game && window.game.phase === PHASES.PLAY) {\n      toggleMenu(false);\n      const overlay = document.getElementById('confirmation-overlay');\n      const message = document.getElementById('confirmation-message');\n      message.textContent = 'Mchtest du Remis anbieten?';\n      overlay.classList.remove('hidden');\n\n      window.game.pendingConfirmation = () => {\n        const color = window.game.isAI ? 'white' : window.game.turn;\n        window.game.offerDraw(color);\n      };\n    } else {\n      alert('Du kannst nur whrend des Spiels Remis anbieten.');\n    }\n  });\n\n  document.getElementById('stats-btn').addEventListener('click', () => {\n    toggleMenu(false);\n    if (window.game) UI.showStatisticsOverlay(window.game);\n  });\n\n\n  document.getElementById('help-btn').addEventListener('click', () => {\n    toggleMenu(false);\n    document.getElementById('help-overlay').classList.remove('hidden');\n  });\n\n  // --- Settings ---\n  // Theme (Board Colors)\n  const themeSelect = document.getElementById('theme-select');\n  if (themeSelect) {\n    const savedTheme = localStorage.getItem('chess_theme') || 'classic';\n    themeSelect.value = savedTheme;\n    document.body.setAttribute('data-theme', savedTheme);\n\n    themeSelect.addEventListener('change', e => {\n      const theme = e.target.value;\n      localStorage.setItem('chess_theme', theme);\n      document.body.setAttribute('data-theme', theme);\n\n      // Update 3D board theme as well\n      if (window.battleChess3D && window.battleChess3D.setTheme) {\n        window.battleChess3D.setTheme(theme);\n      }\n    });\n  }\n\n\n  // Difficulty\n  const difficultySelect = document.getElementById('difficulty-select');\n  if (difficultySelect) {\n    const savedDifficulty = localStorage.getItem('chess_difficulty') || 'beginner';\n    difficultySelect.value = savedDifficulty;\n    difficultySelect.addEventListener('change', e => {\n      const newDifficulty = e.target.value;\n      if (window.game) window.game.difficulty = newDifficulty;\n      localStorage.setItem('chess_difficulty', newDifficulty);\n    });\n  }\n\n  // Time Control\n  const timeControlSelect = document.getElementById('time-control-select');\n  if (timeControlSelect) {\n    const savedTimeControl = localStorage.getItem('chess_time_control') || 'blitz5';\n    timeControlSelect.value = savedTimeControl;\n    timeControlSelect.addEventListener('change', e => {\n      const newTimeControl = e.target.value;\n      if (window.game) window.game.setTimeControl(newTimeControl);\n      localStorage.setItem('chess_time_control', newTimeControl);\n    });\n  }\n\n  // Sound\n  const soundToggle = document.getElementById('sound-toggle');\n  if (soundToggle) {\n    soundToggle.checked = soundManager.enabled;\n    soundToggle.addEventListener('change', e => {\n      soundManager.setEnabled(e.target.checked);\n    });\n  }\n\n  // --- Overlays ---\n  document.getElementById('close-help-btn').addEventListener('click', () => {\n    document.getElementById('help-overlay').classList.add('hidden');\n  });\n\n  document.getElementById('stats-close-btn').addEventListener('click', () => {\n    document.getElementById('stats-overlay').classList.add('hidden');\n  });\n\n  document.getElementById('confirm-yes-btn').addEventListener('click', () => {\n    if (window.game && window.game.pendingConfirmation) {\n      window.game.pendingConfirmation();\n      window.game.pendingConfirmation = null;\n    }\n    document.getElementById('confirmation-overlay').classList.add('hidden');\n  });\n\n  document.getElementById('confirm-no-btn').addEventListener('click', () => {\n    if (window.game) window.game.pendingConfirmation = null;\n    document.getElementById('confirmation-overlay').classList.add('hidden');\n  });\n\n  document.getElementById('accept-draw-btn').addEventListener('click', () => {\n    if (window.game) window.game.acceptDraw();\n    document.getElementById('draw-offer-overlay').classList.add('hidden');\n  });\n\n  document.getElementById('decline-draw-btn').addEventListener('click', () => {\n    if (window.game) window.game.declineDraw();\n    document.getElementById('draw-offer-overlay').classList.add('hidden');\n  });\n\n  document.getElementById('close-game-over-btn').addEventListener('click', () => {\n    document.getElementById('game-over-overlay').classList.add('hidden');\n  });\n\n  document.getElementById('restart-btn-overlay').addEventListener('click', () => {\n    location.reload();\n  });\n\n  // Puzzle Overlay\n  document.getElementById('puzzle-next-btn').addEventListener('click', () => {\n    if (window.game) window.game.gameController.nextPuzzle();\n  });\n\n  document.getElementById('puzzle-exit-btn').addEventListener('click', () => {\n    if (window.game) window.game.gameController.exitPuzzleMode();\n  });\n\n  // --- Shop ---\n  const shopButtons = document.querySelectorAll('.shop-item');\n  shopButtons.forEach(btn => {\n    btn.addEventListener('click', () => {\n      if (window.game) window.game.selectShopPiece(btn.dataset.piece);\n\n      // Visual feedback\n      shopButtons.forEach(b => b.classList.remove('selected'));\n      btn.classList.add('selected');\n    });\n  });\n\n  const finishBtn = document.getElementById('finish-setup-btn');\n  if (finishBtn) {\n    finishBtn.addEventListener('click', () => {\n      if (window.game) window.game.finishSetupPhase();\n    });\n  }\n\n  // --- Keyboard ---\n  document.addEventListener('keydown', e => {\n    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;\n\n    if (e.ctrlKey || e.metaKey) {\n      if (!window.game) return;\n      switch (e.key.toLowerCase()) {\n      case 's': e.preventDefault(); window.game.saveGame(); break;\n      case 'l': e.preventDefault(); window.game.loadGame(); break;\n      case 'z':\n        e.preventDefault();\n        if (e.shiftKey) {\n          if (window.game.redoStack.length > 0 && window.game.phase === PHASES.PLAY) window.game.redoMove();\n        } else {\n          if (window.game.moveHistory.length > 0 && window.game.phase === PHASES.PLAY) window.game.undoMove();\n        }\n        break;\n      case 'y':\n        e.preventDefault();\n        if (window.game.redoStack.length > 0 && window.game.phase === PHASES.PLAY) window.game.redoMove();\n        break;\n      }\n    }\n\n    if (window.game && !window.game.replayMode) {\n      switch (e.key.toLowerCase()) {\n      case 'h': if (window.game.phase === PHASES.PLAY) window.game.showTutorSuggestions(); break;\n      case 'u': if (window.game.moveHistory.length > 0 && window.game.phase === PHASES.PLAY) window.game.undoMove(); break;\n      case '3': document.getElementById('toggle-3d-btn')?.click(); break; // Toggle 3D mode\n      case 'escape':\n      case 'esc':\n        if (window.game.selectedSquare) {\n          window.game.selectedSquare = null;\n          window.game.validMoves = null;\n          UI.renderBoard(window.game);\n        }\n        // Close overlays\n        document.querySelectorAll('.fullscreen-overlay, .modal-overlay').forEach(el => {\n          if (!el.id.includes('points-selection')) el.classList.add('hidden');\n        });\n        break;\n      }\n    }\n\n    // Arrow keys for board navigation\n    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {\n      e.preventDefault();\n      if (e.key === 'ArrowUp') kbRow = (kbRow + BOARD_SIZE - 1) % BOARD_SIZE;\n      if (e.key === 'ArrowDown') kbRow = (kbRow + 1) % BOARD_SIZE;\n      if (e.key === 'ArrowLeft') kbCol = (kbCol + BOARD_SIZE - 1) % BOARD_SIZE;\n      if (e.key === 'ArrowRight') kbCol = (kbCol + 1) % BOARD_SIZE;\n      focusCell(kbRow, kbCol);\n    }\n    if (e.key === 'Enter' || e.key === ' ') {\n      e.preventDefault();\n      const cell = document.querySelector(`.cell[data-r=\"${kbRow}\"][data-c=\"${kbCol}\"]`);\n      if (cell) cell.click();\n    }\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/moveController.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'PIECE_SVGS' is defined but never used.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":20},{"ruleId":"no-unused-vars","severity":1,"message":"'logger' is defined but never used.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":16},{"ruleId":"no-unused-vars","severity":1,"message":"'PIECES' is assigned a value but never used.","line":11,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PHASES, BOARD_SIZE, PIECE_VALUES } from './gameEngine.js';\nimport { SHOP_PIECES } from './config.js';\nimport * as UI from './ui.js';\nimport { soundManager } from './sounds.js';\nimport { PIECE_SVGS } from './chess-pieces.js';\nimport { logger } from './logger.js';\nimport { puzzleManager } from './puzzleManager.js';\nimport { evaluatePosition } from './aiEngine.js';\n\n// Piece values for shop (needed for some logic?)\nconst PIECES = SHOP_PIECES;\n\nexport class MoveController {\n  constructor(game) {\n    this.game = game;\n    this.redoStack = [];\n  }\n\n  handlePlayClick(r, c) {\n    const clickedPiece = this.game.board[r][c];\n    const isCurrentPlayersPiece = clickedPiece && clickedPiece.color === this.game.turn;\n\n    // 1. If clicking own piece, always select it (change selection)\n    if (isCurrentPlayersPiece) {\n      this.game.selectedSquare = { r, c };\n      this.game.validMoves = this.game.getValidMoves(r, c, clickedPiece);\n      UI.renderBoard(this.game);\n      return;\n    }\n\n    // 2. If we have a selected piece AND it belongs to us, check if we want to move/capture\n    const selectedPiece = this.game.selectedSquare\n      ? this.game.board[this.game.selectedSquare.r][this.game.selectedSquare.c]\n      : null;\n    const isSelectedMine = selectedPiece && selectedPiece.color === this.game.turn;\n\n    if (isSelectedMine && this.game.validMoves) {\n      const move = this.game.validMoves.find(m => m.r === r && m.c === c);\n      if (move) {\n        // Track accuracy for human player\n        const isHumanMove = this.game.isAI ? this.game.turn === 'white' : true;\n        if (isHumanMove) {\n          this.game.stats.playerMoves++;\n          if (this.game.tutorController && this.game.tutorController.handlePlayerMove) {\n            this.game.tutorController.handlePlayerMove(this.game.selectedSquare, move);\n          }\n        }\n        this.executeMove(this.game.selectedSquare, move);\n        return;\n      }\n    }\n\n    // 3. If clicking an enemy piece (and not capturing it), select it to show threats\n    if (clickedPiece) {\n      this.game.selectedSquare = { r, c };\n      this.game.validMoves = this.game.getValidMoves(r, c, clickedPiece);\n      UI.renderBoard(this.game);\n      return;\n    }\n\n    // 4. Otherwise (clicking empty square that is not a move), deselect\n    this.game.selectedSquare = null;\n    this.game.validMoves = null;\n    UI.renderBoard(this.game);\n  }\n\n  /**\n     * Executes a move on the board\n     * @param {Object} from Source square {r, c}\n     * @param {Object} to Destination square {r, c}\n     * @param {boolean} isUndoRedo Whether this move is from an undo/redo operation\n     */\n  async executeMove(from, to, isUndoRedo = false) {\n    // Clear redo stack if this is a new move\n    if (!isUndoRedo) {\n      this.redoStack = [];\n      this.updateUndoRedoButtons();\n    }\n\n    // Clear tutor arrows when making a move\n    if (this.game.arrowRenderer) {\n      this.game.arrowRenderer.clearArrows();\n    }\n\n    const piece = this.game.board[from.r][from.c];\n    if (!piece) return;\n\n    const targetPiece = this.game.board[to.r][to.c];\n\n    // Record move in history (snapshot current state)\n    const moveRecord = {\n      from: { r: from.r, c: from.c },\n      to: { r: to.r, c: to.c },\n      piece: { type: piece.type, color: piece.color, hasMoved: piece.hasMoved },\n      capturedPiece: targetPiece ? { type: targetPiece.type, color: targetPiece.color } : null,\n      specialMove: null,\n      halfMoveClock: this.game.halfMoveClock,\n      positionHistoryLength: this.game.positionHistory.length,\n    };\n\n    // Handle Castling\n    if (piece.type === 'k' && Math.abs(to.c - from.c) === 2) {\n      const isKingside = to.c > from.c;\n      const rookCol = isKingside ? BOARD_SIZE - 1 : 0;\n      const rookTargetCol = isKingside ? to.c - 1 : to.c + 1;\n      const rook = this.game.board[from.r][rookCol];\n\n      moveRecord.specialMove = {\n        type: 'castling',\n        isKingside,\n        rookFrom: { r: from.r, c: rookCol },\n        rookTo: { r: from.r, c: rookTargetCol },\n        rookHadMoved: rook.hasMoved,\n        rookType: rook.type, // FIX: Store rook type to prevent corruption\n      };\n\n      // Move Rook\n      this.game.board[from.r][rookTargetCol] = rook;\n      this.game.board[from.r][rookCol] = null;\n      rook.hasMoved = true;\n      this.game.log(`${piece.color === 'white' ? 'Wei' : 'Schwarz'} rochiert!`);\n    }\n\n    // Handle En Passant\n    if (piece.type === 'p' && to.c !== from.c && !targetPiece) {\n      const capturedPawnRow = from.r;\n      const capturedPawn = this.game.board[capturedPawnRow][to.c];\n\n      moveRecord.specialMove = {\n        type: 'enPassant',\n        capturedPawnPos: { r: capturedPawnRow, c: to.c },\n        capturedPawn: { type: capturedPawn.type, color: capturedPawn.color },\n      };\n\n      this.game.board[capturedPawnRow][to.c] = null;\n      this.game.log('En Passant geschlagen!');\n    }\n    // Update 50-move rule clock\n    if (piece.type === 'p' || targetPiece) {\n      this.game.halfMoveClock = 0;\n    } else {\n      this.game.halfMoveClock++;\n    }\n\n    // Animate move BEFORE updating board state\n    if (this.game.phase === PHASES.PLAY) {\n      await this.animateMove(from, to, piece);\n    }\n\n    // NOW execute move\n    this.game.board[to.r][to.c] = piece;\n    this.game.board[from.r][from.c] = null;\n    piece.hasMoved = true;\n\n    UI.renderBoard(this.game);\n\n    // Play sound\n    if (targetPiece || (moveRecord.specialMove && moveRecord.specialMove.type === 'enPassant')) {\n      soundManager.playCapture();\n    } else {\n      soundManager.playMove();\n    }\n\n    // Update captured pieces\n    if (targetPiece) {\n      const capturerColor = piece.color;\n      this.game.capturedPieces[capturerColor].push(targetPiece);\n      UI.updateCapturedUI(this.game);\n    } else if (moveRecord.specialMove && moveRecord.specialMove.type === 'enPassant') {\n      const capturerColor = piece.color;\n      this.game.capturedPieces[capturerColor].push(moveRecord.specialMove.capturedPawn);\n      UI.updateCapturedUI(this.game);\n    }\n\n    // Update last move highlight\n    this.game.lastMoveHighlight = {\n      from: { r: from.r, c: from.c },\n      to: { r: to.r, c: to.c },\n    };\n\n    // Track last move for En Passant\n    this.game.lastMove = {\n      from: { r: from.r, c: from.c },\n      to: { r: to.r, c: to.c },\n      piece: piece,\n      isDoublePawnPush: piece.type === 'p' && Math.abs(to.r - from.r) === 2,\n    };\n\n    // Promotion check\n    if (piece.type === 'p') {\n      const promotionRow = piece.color === 'white' ? 0 : BOARD_SIZE - 1;\n      if (to.r === promotionRow) {\n        // Automatic promotion to Angel (Engel)\n        piece.type = 'e';\n        moveRecord.specialMove = { type: 'promotion', promotedTo: 'e' };\n        this.game.log(`${piece.color === 'white' ? 'Weier' : 'Schwarzer'} Bauer zum Engel befrdert!`);\n\n        // Play promotion sound if available, otherwise move sound\n        soundManager.playMove();\n      }\n    }\n\n    // Calculate evaluation score (from white's perspective)\n    const evalScore = evaluatePosition(this.game.board, 'white');\n    moveRecord.evalScore = evalScore;\n\n    // Add move to history\n    this.game.moveHistory.push(moveRecord);\n    UI.updateMoveHistoryUI(this.game);\n\n    // Blunder Detection\n    if (this.game.tutorController && this.game.tutorController.checkBlunder) {\n      this.game.tutorController.checkBlunder(moveRecord);\n    }\n\n    // Puzzle Logic Check\n    if (this.game.mode === 'puzzle') {\n      const result = puzzleManager.checkMove(this.game, moveRecord);\n      if (result === 'wrong') {\n        // Delay slightly to show the wrong move, then undo\n        setTimeout(() => {\n          this.undoMove();\n          UI.updatePuzzleStatus('error', 'Falscher Zug!');\n          if (window.soundManager && window.soundManager.playError) soundManager.playError();\n        }, 500);\n      } else if (result === 'solved') {\n        UI.updatePuzzleStatus('success', 'Richtig! Puzzle gelst!');\n        if (window.soundManager && window.soundManager.playSuccess) soundManager.playSuccess();\n      } else {\n        UI.updatePuzzleStatus('neutral', 'Richtig... weiter!');\n      }\n      // For puzzles, we might not want to switch turns if it's \"white to move and win\" single player experience\n      // But usually we do switch to let the \"opponent\" (AI or script) reply if it's a multi-move puzzle.\n      // For now, let's assume standard turn switching but we might need \"PuzzleManager.getReply(game)\"\n    }\n\n    // Check for insufficient material\n    if (this.isInsufficientMaterial()) {\n      this.game.phase = PHASES.GAME_OVER;\n      UI.renderBoard(this.game);\n      UI.updateStatus(this.game);\n      this.game.log('Unentschieden (Ungengendes Material)');\n      const overlay = document.getElementById('game-over-overlay');\n      const winnerText = document.getElementById('winner-text');\n      winnerText.textContent = 'Unentschieden (Ungengendes Material)';\n      overlay.classList.remove('hidden');\n\n      // Save to statistics\n      if (this.game.gameController) {\n        this.game.gameController.saveGameToStatistics('draw', null);\n      }\n      return;\n    }\n\n    this.finishMove();\n  }\n\n  showPromotionUI(r, c, color, moveRecord) {\n    UI.showPromotionUI(this.game, r, c, color, moveRecord, () => this.finishMove());\n  }\n\n  async animateMove(from, to, piece) {\n    await UI.animateMove(this.game, from, to, piece);\n  }\n\n  finishMove() {\n    this.game.selectedSquare = null;\n    this.game.validMoves = null;\n\n    this.game.stats.totalMoves++;\n    if (this.game.turn === 'white') this.game.stats.playerMoves++;\n\n    // Check if a king was captured\n    let whiteKingExists = false;\n    let blackKingExists = false;\n    for (let r = 0; r < BOARD_SIZE; r++) {\n      for (let c = 0; c < BOARD_SIZE; c++) {\n        const piece = this.game.board[r][c];\n        if (piece && piece.type === 'k') {\n          if (piece.color === 'white') whiteKingExists = true;\n          if (piece.color === 'black') blackKingExists = true;\n        }\n      }\n    }\n\n    if (!whiteKingExists || !blackKingExists) {\n      this.game.phase = PHASES.GAME_OVER;\n      const winner = !whiteKingExists ? 'Schwarz' : 'Wei';\n      this.game.log(`KNIG GESCHLAGEN! ${winner} gewinnt!`);\n\n      const overlay = document.getElementById('game-over-overlay');\n      const winnerText = document.getElementById('winner-text');\n      winnerText.textContent = `${winner} gewinnt!\\n(Knig geschlagen)`;\n      overlay.classList.remove('hidden');\n\n      const isPlayerWin = (this.game.isAI && this.game.turn === 'black') || !this.game.isAI;\n      soundManager.playGameOver(isPlayerWin);\n\n      UI.renderBoard(this.game);\n      UI.updateStatus(this.game);\n\n      // Save to statistics\n      if (this.game.gameController) {\n        const losingColor = !whiteKingExists ? 'white' : 'black';\n        this.game.gameController.saveGameToStatistics('win', losingColor);\n      }\n      return;\n    }\n\n    // Switch turns\n    this.game.turn = this.game.turn === 'white' ? 'black' : 'white';\n\n    UI.updateStatistics(this.game);\n\n    if (this.game.clockEnabled) {\n      const previousPlayer = this.game.turn === 'white' ? 'black' : 'white';\n      if (previousPlayer === 'white') {\n        this.game.whiteTime += this.game.timeControl.increment;\n      } else {\n        this.game.blackTime += this.game.timeControl.increment;\n      }\n      UI.updateClockDisplay(this.game);\n      UI.updateClockUI(this.game);\n    }\n\n    // Add position to repetition history\n    const currentHash = this.getBoardHash();\n    this.game.positionHistory.push(currentHash);\n\n    // Update 3D board if active\n    if (window.battleChess3D && window.battleChess3D.enabled && this.game.moveHistory.length > 0) {\n      const lastMove = this.game.moveHistory[this.game.moveHistory.length - 1];\n      const piece = lastMove.piece;\n      const from = lastMove.from;\n      const to = lastMove.to;\n      const targetPiece = lastMove.capturedPiece;\n      const moveRecord = lastMove;\n\n      const captured = targetPiece || (moveRecord.specialMove && moveRecord.specialMove.type === 'enPassant');\n      if (captured) {\n        // Play battle animation on capture\n        const attackerData = { type: piece.type, color: piece.color };\n        const defenderData = targetPiece || moveRecord.specialMove.capturedPawn;\n        window.battleChess3D.playBattleSequence(\n          attackerData,\n          defenderData,\n          from,\n          to\n        ).then(() => {\n          // After battle, update the board state\n          window.battleChess3D.removePiece(to.r, to.c);\n          window.battleChess3D.animateMove(from.r, from.c, to.r, to.c);\n        });\n      } else {\n        // Normal move animation\n        window.battleChess3D.animateMove(from.r, from.c, to.r, to.c);\n      }\n    }\n\n    const opponentColor = this.game.turn;\n    if (this.game.isCheckmate(opponentColor)) {\n      this.game.phase = PHASES.GAME_OVER;\n      UI.renderBoard(this.game);\n      UI.updateStatus(this.game);\n      const winner = opponentColor === 'white' ? 'Schwarz' : 'Wei';\n      this.game.log(`SCHACHMATT! ${winner} gewinnt!`);\n\n      UI.animateCheckmate(this.game, opponentColor);\n\n      const overlay = document.getElementById('game-over-overlay');\n      const winnerText = document.getElementById('winner-text');\n      winnerText.textContent = `${winner} gewinnt!`;\n      overlay.classList.remove('hidden');\n\n      const isPlayerWin = (this.game.isAI && opponentColor === 'black') || !this.game.isAI;\n      soundManager.playGameOver(isPlayerWin);\n\n      // Save to statistics\n      if (this.game.gameController) {\n        this.game.gameController.saveGameToStatistics('win', opponentColor);\n      }\n      return;\n    } else if (this.game.isStalemate(opponentColor)) {\n      this.game.phase = PHASES.GAME_OVER;\n      UI.renderBoard(this.game);\n      UI.updateStatus(this.game);\n      this.game.log('PATT! Unentschieden.');\n      const overlay = document.getElementById('game-over-overlay');\n      const winnerText = document.getElementById('winner-text');\n      winnerText.textContent = 'Unentschieden (Patt)';\n      overlay.classList.remove('hidden');\n\n      // Save to statistics\n      if (this.game.gameController) {\n        this.game.gameController.saveGameToStatistics('draw', null);\n      }\n      return;\n    } else if (this.checkDraw()) {\n      return;\n    } else if (this.game.isInCheck(opponentColor)) {\n      this.game.log(`SCHACH! ${opponentColor === 'white' ? 'Wei' : 'Schwarz'} steht im Schach.`);\n      soundManager.playCheck();\n      UI.animateCheck(this.game, opponentColor);\n    }\n\n    UI.updateStatus(this.game);\n    UI.renderEvalGraph(this.game);\n    this.game.log(`${this.game.turn === 'white' ? 'Wei' : 'Schwarz'} ist am Zug.`);\n\n    if (this.game.isAI && this.game.turn === 'black' && this.game.phase === PHASES.PLAY) {\n      setTimeout(() => {\n        if (this.game.aiMove) this.game.aiMove();\n      }, 1000);\n    } else {\n      setTimeout(() => {\n        if (this.game.updateBestMoves) this.game.updateBestMoves();\n      }, 10);\n    }\n  }\n\n  undoMove() {\n    if (this.game.moveHistory.length === 0 || this.game.phase !== PHASES.PLAY) {\n      return;\n    }\n\n    const move = this.game.moveHistory.pop();\n    this.redoStack.push(move);\n\n    const piece = this.game.board[move.to.r][move.to.c];\n    if (!piece) return;\n\n    // Restore the piece to its original position\n    this.game.board[move.from.r][move.from.c] = piece;\n    this.game.board[move.to.r][move.to.c] = move.capturedPiece\n      ? { type: move.capturedPiece.type, color: move.capturedPiece.color, hasMoved: true }\n      : null;\n\n    // Restore piece properties (hasMoved and type)\n    piece.hasMoved = move.piece.hasMoved;\n    piece.type = move.piece.type;\n\n    if (move.specialMove) {\n      if (move.specialMove.type === 'castling') {\n        // Undo rook movement\n        const rook = this.game.board[move.specialMove.rookTo.r][move.specialMove.rookTo.c];\n        if (rook) {\n          this.game.board[move.specialMove.rookFrom.r][move.specialMove.rookFrom.c] = rook;\n          this.game.board[move.specialMove.rookTo.r][move.specialMove.rookTo.c] = null;\n          rook.hasMoved = move.specialMove.rookHadMoved;\n          // FIX: Restore rook type to prevent it from being corrupted\n          if (move.specialMove.rookType) {\n            rook.type = move.specialMove.rookType;\n          }\n        }\n      } else if (move.specialMove.type === 'enPassant') {\n        this.game.board[move.specialMove.capturedPawnPos.r][move.specialMove.capturedPawnPos.c] = {\n          type: 'p',\n          color: move.specialMove.capturedPawn.color,\n          hasMoved: true,\n        };\n      }\n    }\n\n    // Handle captured pieces restoration\n    if (move.capturedPiece) {\n      const capturerColor = move.piece.color;\n      this.game.capturedPieces[capturerColor].pop();\n      UI.updateCapturedUI(this.game);\n    } else if (move.specialMove && move.specialMove.type === 'enPassant') {\n      const capturerColor = move.piece.color;\n      this.game.capturedPieces[capturerColor].pop();\n      UI.updateCapturedUI(this.game);\n    }\n\n    this.game.halfMoveClock = move.halfMoveClock;\n    while (this.game.positionHistory.length > move.positionHistoryLength) {\n      this.game.positionHistory.pop();\n    }\n\n    this.game.turn = this.game.turn === 'white' ? 'black' : 'white';\n    this.game.stats.totalMoves--;\n    UI.updateStatus(this.game);\n    UI.updateMoveHistoryUI(this.game);\n    UI.updateStatistics(this.game);\n\n    if (this.game.moveHistory.length > 0) {\n      const lastMove = this.game.moveHistory[this.game.moveHistory.length - 1];\n      this.game.lastMoveHighlight = { from: lastMove.from, to: lastMove.to };\n    } else {\n      this.game.lastMoveHighlight = null;\n    }\n\n    this.game.selectedSquare = null;\n    this.game.validMoves = null;\n\n    UI.renderBoard(this.game);\n    UI.updateMoveHistoryUI(this.game);\n    UI.updateStatus(this.game);\n    this.game.log(`Zug ${move.piece.color === 'white' ? 'Wei' : 'Schwarz'} zurckgenommen`);\n\n    // Update 3D board if active\n    if (window.battleChess3D && window.battleChess3D.enabled) {\n      window.battleChess3D.updateFromGameState(this.game);\n    }\n\n    if (this.game.updateBestMoves) this.game.updateBestMoves();\n    this.updateUndoRedoButtons();\n  }\n\n  async redoMove() {\n    if (this.redoStack.length === 0 || this.game.phase !== PHASES.PLAY) {\n      return;\n    }\n\n    const move = this.redoStack.pop();\n\n    this.game.selectedSquare = move.from;\n    this.game.validMoves = this.game.getValidMoves(\n      move.from.r,\n      move.from.c,\n      this.game.board[move.from.r][move.from.c]\n    );\n\n    await this.executeMove(move.from, move.to, true);\n    this.updateUndoRedoButtons();\n  }\n\n  updateUndoRedoButtons() {\n    const undoBtn = document.getElementById('undo-btn');\n    const redoBtn = document.getElementById('redo-btn');\n\n    if (undoBtn) {\n      undoBtn.disabled = this.game.moveHistory.length === 0 || this.game.phase !== PHASES.PLAY;\n      undoBtn.textContent = ` Rckgngig${this.game.moveHistory.length > 0 ? ` (${this.game.moveHistory.length})` : ''}`;\n    }\n\n    if (redoBtn) {\n      redoBtn.disabled = this.redoStack.length === 0 || this.game.phase !== PHASES.PLAY;\n      redoBtn.textContent = ` Wiederholen${this.redoStack.length > 0 ? ` (${this.redoStack.length})` : ''}`;\n    }\n  }\n\n  checkDraw() {\n    if (this.game.halfMoveClock >= 100) {\n      this.game.phase = PHASES.GAME_OVER;\n      UI.renderBoard(this.game);\n      UI.updateStatus(this.game);\n      this.game.log('Unentschieden (50-Zge-Regel)');\n      const overlay = document.getElementById('game-over-overlay');\n      const winnerText = document.getElementById('winner-text');\n      winnerText.textContent = 'Unentschieden (50-Zge-Regel)';\n      overlay.classList.remove('hidden');\n\n      // Save to statistics\n      if (this.game.gameController) {\n        this.game.gameController.saveGameToStatistics('draw', null);\n      }\n      return true;\n    }\n\n    const currentHash = this.getBoardHash();\n    const occurrences = this.game.positionHistory.filter(h => h === currentHash).length;\n    if (occurrences >= 3) {\n      this.game.phase = PHASES.GAME_OVER;\n      UI.renderBoard(this.game);\n      UI.updateStatus(this.game);\n      this.game.log('Unentschieden (Stellungswiederholung)');\n      const overlay = document.getElementById('game-over-overlay');\n      const winnerText = document.getElementById('winner-text');\n      winnerText.textContent = 'Unentschieden (Stellungswiederholung)';\n      overlay.classList.remove('hidden');\n\n      // Save to statistics\n      if (this.game.gameController) {\n        this.game.gameController.saveGameToStatistics('draw', null);\n      }\n      return true;\n    }\n\n    if (this.isInsufficientMaterial()) {\n      this.game.phase = PHASES.GAME_OVER;\n      UI.renderBoard(this.game);\n      UI.updateStatus(this.game);\n      this.game.log('Unentschieden (Ungengendes Material)');\n      const overlay = document.getElementById('game-over-overlay');\n      const winnerText = document.getElementById('winner-text');\n      winnerText.textContent = 'Unentschieden (Ungengendes Material)';\n      overlay.classList.remove('hidden');\n\n      // Save to statistics\n      if (this.game.gameController) {\n        this.game.gameController.saveGameToStatistics('draw', null);\n      }\n      return true;\n    }\n\n    return false;\n  }\n\n  isInsufficientMaterial() {\n    const pieces = [];\n    for (let r = 0; r < BOARD_SIZE; r++) {\n      for (let c = 0; c < BOARD_SIZE; c++) {\n        if (this.game.board[r][c]) {\n          pieces.push(this.game.board[r][c]);\n        }\n      }\n    }\n\n    const whitePieces = pieces.filter(p => p.color === 'white');\n    const blackPieces = pieces.filter(p => p.color === 'black');\n    const whiteNonKings = whitePieces.filter(p => p.type !== 'k');\n    const blackNonKings = blackPieces.filter(p => p.type !== 'k');\n\n    if (pieces.length === 2) return true;\n\n    if (pieces.length === 3) {\n      const nonKings = pieces.filter(p => p.type !== 'k');\n      if (nonKings.length === 1 && (nonKings[0].type === 'n' || nonKings[0].type === 'b')) {\n        return true;\n      }\n    }\n\n    if (pieces.length === 4) {\n      if (whiteNonKings.length === 2 && blackNonKings.length === 0) {\n        if (whiteNonKings.every(p => p.type === 'n')) return true;\n      }\n      if (blackNonKings.length === 2 && whiteNonKings.length === 0) {\n        if (blackNonKings.every(p => p.type === 'n')) return true;\n      }\n    }\n\n    if (\n      pieces.length === 4 &&\n            whiteNonKings.length === 1 &&\n            blackNonKings.length === 1 &&\n            whiteNonKings[0].type === 'b' &&\n            blackNonKings[0].type === 'b'\n    ) {\n      let whiteBishopSquare = null;\n      let blackBishopSquare = null;\n\n      for (let r = 0; r < BOARD_SIZE; r++) {\n        for (let c = 0; c < BOARD_SIZE; c++) {\n          const piece = this.game.board[r][c];\n          if (piece && piece.type === 'b') {\n            if (piece.color === 'white') whiteBishopSquare = { r, c };\n            else blackBishopSquare = { r, c };\n          }\n        }\n      }\n\n      if (whiteBishopSquare && blackBishopSquare) {\n        const whiteSquareColor = (whiteBishopSquare.r + whiteBishopSquare.c) % 2;\n        const blackSquareColor = (blackBishopSquare.r + blackBishopSquare.c) % 2;\n        if (whiteSquareColor === blackSquareColor) return true;\n      }\n    }\n\n    const allNonKings = pieces.filter(p => p.type !== 'k');\n    if (allNonKings.length > 0 && allNonKings.every(p => p.type === 'b')) {\n      const bishopSquareColors = new Set();\n      for (let r = 0; r < BOARD_SIZE; r++) {\n        for (let c = 0; c < BOARD_SIZE; c++) {\n          const piece = this.game.board[r][c];\n          if (piece && piece.type === 'b') {\n            bishopSquareColors.add((r + c) % 2);\n          }\n        }\n      }\n      if (bishopSquareColors.size === 1) return true;\n    }\n\n    return false;\n  }\n\n  getBoardHash() {\n    let hash = '';\n    for (let r = 0; r < BOARD_SIZE; r++) {\n      for (let c = 0; c < BOARD_SIZE; c++) {\n        const piece = this.game.board[r][c];\n        if (piece) {\n          hash += `${piece.color[0]}${piece.type}${r}${c};`;\n        }\n      }\n    }\n    return hash;\n  }\n\n  saveGame() {\n    const gameState = {\n      board: this.game.board,\n      phase: this.game.phase,\n      turn: this.game.turn,\n      points: this.game.points,\n      selectedShopPiece: this.game.selectedShopPiece,\n      whiteCorridor: this.game.whiteCorridor,\n      blackCorridor: this.game.blackCorridor,\n      isAI: this.game.isAI,\n      difficulty: this.game.difficulty,\n      moveHistory: this.game.moveHistory,\n      halfMoveClock: this.game.halfMoveClock,\n      positionHistory: this.game.positionHistory,\n      capturedPieces: this.game.capturedPieces,\n      drawOffered: this.game.drawOffered,\n      drawOfferedBy: this.game.drawOfferedBy,\n    };\n    localStorage.setItem('schach9x9_save_autosave', JSON.stringify(gameState));\n    this.game.log('Spiel gespeichert! ');\n  }\n\n  loadGame() {\n    const savedData = localStorage.getItem('schach9x9_save_autosave');\n    if (!savedData) {\n      this.game.log('Kein gespeichertes Spiel gefunden.');\n      return false;\n    }\n\n    try {\n      const state = JSON.parse(savedData);\n\n      this.game.board = state.board;\n      this.game.phase = state.phase;\n      this.game.turn = state.turn;\n      this.game.points = state.points;\n      this.game.selectedShopPiece = state.selectedShopPiece;\n      this.game.whiteCorridor = state.whiteCorridor;\n      this.game.blackCorridor = state.blackCorridor;\n      this.game.isAI = state.isAI;\n      this.game.difficulty = state.difficulty;\n      this.game.moveHistory = state.moveHistory;\n      this.game.halfMoveClock = state.halfMoveClock;\n      this.game.positionHistory = state.positionHistory;\n      this.game.capturedPieces = state.capturedPieces || { white: [], black: [] };\n\n      document.getElementById('ai-toggle').checked = this.game.isAI;\n      document.getElementById('difficulty-select').value = this.game.difficulty;\n\n      UI.renderBoard(this.game);\n      UI.updateStatus(this.game);\n      UI.updateShopUI(this.game);\n      UI.updateMoveHistoryUI(this.game);\n      UI.updateCapturedUI(this.game);\n\n      this.game.drawOffered = state.drawOffered || false;\n      this.game.drawOfferedBy = state.drawOfferedBy || null;\n      const drawOverlay = document.getElementById('draw-offer-overlay');\n      if (drawOverlay) {\n        if (this.game.drawOffered) {\n          const message = document.getElementById('draw-offer-message');\n          const offeringColor = this.game.drawOfferedBy === 'white' ? 'Wei' : 'Schwarz';\n          if (message)\n            message.textContent = `${offeringColor} bietet Remis an. Mchtest du annehmen?`;\n          drawOverlay.classList.remove('hidden');\n        } else {\n          drawOverlay.classList.add('hidden');\n        }\n      }\n\n      if (this.game.phase === PHASES.SETUP_WHITE_PIECES || this.game.phase === PHASES.SETUP_BLACK_PIECES) {\n        UI.showShop(this.game, true);\n      } else {\n        UI.showShop(this.game, false);\n      }\n\n      if (this.game.phase === PHASES.PLAY) {\n        document.getElementById('move-history-panel').classList.remove('hidden');\n        document.getElementById('captured-pieces-panel').classList.remove('hidden');\n        if (this.game.updateBestMoves) this.game.updateBestMoves();\n      }\n\n      this.game.log('Spiel geladen! ');\n      return true;\n    } catch (e) {\n      console.error('Fehler beim Laden:', e);\n      this.game.log('Fehler beim Laden des Spielstands.');\n      return false;\n    }\n  }\n\n  calculateMaterialAdvantage() {\n    let whiteMaterial = 0;\n    let blackMaterial = 0;\n\n    for (let r = 0; r < BOARD_SIZE; r++) {\n      for (let c = 0; c < BOARD_SIZE; c++) {\n        const piece = this.game.board[r][c];\n        if (piece) {\n          const value = this.getMaterialValue(piece);\n          if (piece.color === 'white') {\n            whiteMaterial += value;\n          } else {\n            blackMaterial += value;\n          }\n        }\n      }\n    }\n\n    return whiteMaterial - blackMaterial;\n  }\n\n  getMaterialValue(piece) {\n    return PIECE_VALUES[piece.type] || 0;\n  }\n\n  enterReplayMode() {\n    if (this.game.replayMode || this.game.moveHistory.length === 0) return;\n\n    this.game.savedGameState = {\n      board: JSON.parse(JSON.stringify(this.game.board)),\n      turn: this.game.turn,\n      selectedSquare: this.game.selectedSquare,\n      validMoves: this.game.validMoves,\n      lastMoveHighlight: this.game.lastMoveHighlight,\n    };\n\n    this.game.replayMode = true;\n    this.game.replayPosition = this.game.moveHistory.length - 1;\n    this.game.stopClock();\n\n    document.getElementById('replay-status').classList.remove('hidden');\n    document.getElementById('replay-exit').classList.remove('hidden');\n    document.getElementById('undo-btn').disabled = true;\n\n    this.updateReplayUI();\n  }\n\n  exitReplayMode() {\n    if (!this.game.replayMode) return;\n\n    this.game.board = this.game.savedGameState.board;\n    this.game.turn = this.game.savedGameState.turn;\n    this.game.selectedSquare = this.game.savedGameState.selectedSquare;\n    this.game.validMoves = this.game.savedGameState.validMoves;\n    this.game.lastMoveHighlight = this.game.savedGameState.lastMoveHighlight;\n\n    this.game.replayMode = false;\n    this.game.replayPosition = -1;\n    this.game.savedGameState = null;\n\n    document.getElementById('replay-status').classList.add('hidden');\n    document.getElementById('replay-exit').classList.add('hidden');\n    document.getElementById('undo-btn').disabled =\n            this.game.moveHistory.length === 0 || this.game.phase !== PHASES.PLAY;\n\n    UI.renderBoard(this.game);\n\n    if (this.game.clockEnabled && this.game.phase === PHASES.PLAY) {\n      this.game.startClock();\n    }\n  }\n\n  replayFirst() {\n    if (!this.game.replayMode) this.enterReplayMode();\n    this.game.replayPosition = -1;\n    this.updateReplayUI();\n  }\n\n  replayPrevious() {\n    if (!this.game.replayMode) this.enterReplayMode();\n    if (this.game.replayPosition > -1) {\n      this.game.replayPosition--;\n      this.updateReplayUI();\n    }\n  }\n\n  replayNext() {\n    if (!this.game.replayMode) this.enterReplayMode();\n    if (this.game.replayPosition < this.game.moveHistory.length - 1) {\n      this.game.replayPosition++;\n      this.updateReplayUI();\n    }\n  }\n\n  replayLast() {\n    if (!this.game.replayMode) this.enterReplayMode();\n    this.game.replayPosition = this.game.moveHistory.length - 1;\n    this.updateReplayUI();\n  }\n\n  updateReplayUI() {\n    this.reconstructBoardAtMove(this.game.replayPosition);\n    document.getElementById('replay-move-num').textContent = this.game.replayPosition + 1;\n\n    document.getElementById('replay-first').disabled = this.game.replayPosition === -1;\n    document.getElementById('replay-prev').disabled = this.game.replayPosition === -1;\n    document.getElementById('replay-next').disabled =\n            this.game.replayPosition === this.game.moveHistory.length - 1;\n    document.getElementById('replay-last').disabled =\n            this.game.replayPosition === this.game.moveHistory.length - 1;\n\n    UI.renderBoard(this.game);\n  }\n\n  reconstructBoardAtMove(moveIndex) {\n    if (this.game.savedGameState) {\n      this.game.board = JSON.parse(JSON.stringify(this.game.savedGameState.board));\n      for (let i = this.game.moveHistory.length - 1; i > moveIndex; i--) {\n        const move = this.game.moveHistory[i];\n        this.undoMoveForReplay(move);\n      }\n    }\n\n    if (moveIndex >= 0) {\n      const move = this.game.moveHistory[moveIndex];\n      this.game.lastMoveHighlight = {\n        from: move.from,\n        to: move.to,\n      };\n    } else {\n      this.game.lastMoveHighlight = null;\n    }\n  }\n\n  undoMoveForReplay(move) {\n    const piece = this.game.board[move.to.r][move.to.c];\n    if (!piece) return;\n\n    this.game.board[move.from.r][move.from.c] = piece;\n    this.game.board[move.to.r][move.to.c] = move.capturedPiece\n      ? { type: move.capturedPiece.type, color: move.capturedPiece.color, hasMoved: true }\n      : null;\n\n    piece.hasMoved = move.piece.hasMoved;\n\n    if (move.specialMove) {\n      if (move.specialMove.type === 'castling') {\n        const rookFrom = move.specialMove.rookFrom;\n        const rookTo = move.specialMove.rookTo;\n        const rook = this.game.board[rookTo.r][rookTo.c];\n        if (rook) {\n          this.game.board[rookFrom.r][rookFrom.c] = rook;\n          this.game.board[rookTo.r][rookTo.c] = null;\n          rook.hasMoved = false;\n        }\n      } else if (move.specialMove.type === 'enPassant') {\n        const capturedPos = move.specialMove.capturedPawnPos;\n        this.game.board[capturedPos.r][capturedPos.c] = {\n          type: 'p',\n          color: move.specialMove.capturedPawn.color,\n          hasMoved: true,\n        };\n      } else if (move.specialMove.type === 'promotion') {\n        piece.type = 'p';\n      }\n    }\n  }\n\n  setTheme(themeName) {\n    this.game.currentTheme = themeName;\n    this.applyTheme(themeName);\n    localStorage.setItem('chess_theme', themeName);\n  }\n\n  applyTheme(themeName) {\n    document.body.setAttribute('data-theme', themeName);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/parallel-benchmark.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/performance-benchmark.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'evaluatePosition' is defined but never used.","line":7,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n/**\n * Performance Benchmark for Schach 9x9 AI Engine\n * Measures AI performance on various positions\n */\n\nimport { getBestMove, evaluatePosition, setProgressCallback } from './aiEngine.js';\nimport { BOARD_SIZE } from './config.js';\n\n// Disable progress callback to avoid spam\nsetProgressCallback(null);\n\n// Create empty board\nfunction createEmptyBoard() {\n  const board = [];\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    board[r] = [];\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      board[r][c] = null;\n    }\n  }\n  return board;\n}\n\n// Midgame tactical position\nfunction createTacticalPosition() {\n  const board = createEmptyBoard();\n\n  // White\n  board[8][4] = { type: 'k', color: 'white', hasMoved: true };\n  board[5][4] = { type: 'q', color: 'white', hasMoved: true };\n  board[6][3] = { type: 'r', color: 'white', hasMoved: true };\n  board[7][5] = { type: 'n', color: 'white', hasMoved: true };\n  board[7][3] = { type: 'p', color: 'white', hasMoved: true };\n\n  // Black\n  board[0][4] = { type: 'k', color: 'black', hasMoved: true };\n  board[2][4] = { type: 'q', color: 'black', hasMoved: true };\n  board[3][5] = { type: 'r', color: 'black', hasMoved: true };\n  board[2][2] = { type: 'n', color: 'black', hasMoved: true };\n  board[3][4] = { type: 'p', color: 'black', hasMoved: true };\n\n  return board;\n}\n\n// Run benchmark\nfunction runBenchmark() {\n  console.log('='.repeat(60));\n  console.log(' AI Performance Benchmark - Schach 9x9');\n  console.log('='.repeat(60));\n  console.log('');\n\n  const position = createTacticalPosition();\n  const depths = [2, 3, 4, 5, 6];\n\n  console.log('Position: Tactical Midgame');\n  console.log('-'.repeat(60));\n  console.log('');\n\n  for (const depth of depths) {\n    const startTime = Date.now();\n\n    try {\n      const move = getBestMove(position, 'white', depth, 'medium', 5);\n      const endTime = Date.now();\n      const timeMs = endTime - startTime;\n\n      console.log(`Depth ${depth}:`);\n      console.log(`  Time: ${timeMs}ms`);\n      if (move) {\n        console.log(`  Move: (${move.from.r},${move.from.c}) -> (${move.to.r},${move.to.c})`);\n      }\n      console.log('');\n    } catch (error) {\n      console.error(`  Error at depth ${depth}:`, error.message);\n      console.log('');\n    }\n  }\n\n  console.log('='.repeat(60));\n  console.log(' Benchmark Complete');\n  console.log('='.repeat(60));\n}\n\n// Run benchmark\nrunBenchmark();\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/pieces3D.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/puzzleGenerator.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/puzzleManager.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'BOARD_SIZE' is defined but never used.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BOARD_SIZE } from './config.js';\nimport { PuzzleGenerator } from './puzzleGenerator.js';\n\nexport class PuzzleManager {\n  constructor() {\n    this.puzzles = [\n      {\n        id: 'mate-in-1-001',\n        title: 'Puzzle 1: Der Gnadensto',\n        description: 'Wei zieht und setzt in 1 Zug matt.',\n        difficulty: 'Einfach',\n        // White King at 2,2 (index 20); Black King at 0,2 (index 2); White Rook at 1,7 (index 16)\n        // Index 0-1: .. .. (2)\n        // Index 2: bk\n        // Index 3-15: (13 squares)\n        // Index 16: wr\n        // Index 17-19: (3 squares)\n        // Index 20: wk\n        setupStr: '....bk..........................wr......wk..................................................................................................................w',\n        solution: [\n          { from: { r: 1, c: 7 }, to: { r: 0, c: 7 } }\n        ]\n      },\n      {\n        id: 'mate-in-2-001',\n        title: 'Puzzle 2: Taktischer Schlag',\n        description: 'Wei am Zug. Matt in 2.',\n        difficulty: 'Mittel',\n        // Black King at 0,4 (index 4); White King at 2,4 (index 22); Rook at 6,4 (index 58); Rook at 2,4? Wait, Rooks at 6,4 and 2,4 was the old description.\n        // Let's use: King at 0,4 (B), 2,4 (W). Rooks at 6,4 and 2,0.\n        // Index 4: bk\n        // Index 22: wk\n        // Index 58: wr\n        // Index 18: wr (2,0)\n        setupStr: '........bk....................wr......wk..........................................................wr........................................................w',\n        solution: [\n          { from: { r: 6, c: 4 }, to: { r: 1, c: 4 } },\n          { from: { r: 2, c: 0 }, to: { r: 0, c: 0 } } // Adjust solution to match\n        ]\n      },\n      {\n        id: 'mate-in-1-arch',\n        title: 'Puzzle 3: Die Kraft des Erzbischofs',\n        description: 'Wei zieht. Setze matt mit dem Erzbischof.',\n        difficulty: 'Mittel',\n        // White King at 2,3 (index 21); Archbishop at 2,2 (index 20); Black King at 0,3 (index 3)\n        setupStr: '......bk........................awkb........................................................................................................................w',\n        solution: [\n          { from: { r: 2, c: 2 }, to: { r: 1, c: 4 } }\n        ]\n      }\n    ];\n\n    this.currentPuzzleIndex = 0;\n  }\n\n  getPuzzle(id) {\n    return this.puzzles.find(p => p.id === id);\n  }\n\n  loadPuzzle(game, index = 0) {\n    if (index < 0 || index >= this.puzzles.length) return false;\n\n    this.currentPuzzleIndex = index;\n    const puzzle = this.puzzles[index];\n\n    // Reset game to a clean state\n    game.phase = 'play';\n    game.mode = 'puzzle';\n    game.points = 0;\n    game.capturedPieces = { white: [], black: [] };\n    game.moveHistory = [];\n    game.puzzleState = {\n      active: true,\n      currentMoveIndex: 0,\n      puzzleId: puzzle.id,\n      solved: false\n    };\n\n    // Apply setup from string or function\n    if (puzzle.setupStr) {\n      const { board, turn } = PuzzleGenerator.stringToBoard(puzzle.setupStr);\n      game.board = board;\n      game.turn = turn;\n    } else if (puzzle.setup) {\n      puzzle.setup(game);\n    }\n\n    return puzzle;\n  }\n\n  checkMove(game, move) {\n    if (!game.puzzleState || !game.puzzleState.active) return false;\n\n    const puzzle = this.puzzles[this.currentPuzzleIndex];\n    const expectedMove = puzzle.solution[game.puzzleState.currentMoveIndex];\n\n    // Simple coordinate check\n    const isCorrectParams =\n            move.from.r === expectedMove.from.r &&\n            move.from.c === expectedMove.from.c &&\n            move.to.r === expectedMove.to.r &&\n            move.to.c === expectedMove.to.c;\n\n    if (isCorrectParams) {\n      game.puzzleState.currentMoveIndex++;\n      if (game.puzzleState.currentMoveIndex >= puzzle.solution.length) {\n        game.puzzleState.solved = true;\n        game.puzzleState.active = false;\n        return 'solved';\n      }\n      return 'continue';\n    } else {\n      return 'wrong';\n    }\n  }\n\n  nextPuzzle(game) {\n    const nextIndex = this.currentPuzzleIndex + 1;\n    if (nextIndex < this.puzzles.length) {\n      return this.loadPuzzle(game, nextIndex);\n    }\n    return null;\n  }\n\n  /**\n     * Dynamically generates a puzzle from a game state\n     */\n  generateAndLoad(game, depth = 2) {\n    const solution = PuzzleGenerator.findMateSequence(game.board, game.turn, depth);\n    if (!solution) return null;\n\n    const puzzle = {\n      id: 'gen-' + Date.now(),\n      title: 'Generiertes Puzzle',\n      description: `Setze matt in ${depth} Zgen.`,\n      difficulty: depth === 1 ? 'Einfach' : 'Mittel',\n      setupStr: PuzzleGenerator.boardToString(game.board, game.turn),\n      solution: solution.filter((_, i) => i % 2 === 0) // Only our moves\n    };\n\n    // Add to list and load\n    this.puzzles.push(puzzle);\n    return this.loadPuzzle(game, this.puzzles.length - 1);\n  }\n}\n\nexport const puzzleManager = new PuzzleManager();\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/sounds.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/statisticsManager.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/storage.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'BOARD_SIZE' is defined but never used.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":20},{"ruleId":"no-unused-vars","severity":1,"message":"'PHASES' is defined but never used.","line":7,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Storage Manager for Schach 9x9\n * Handles saving and loading of game state\n * @module storage\n */\n\nimport { BOARD_SIZE, PHASES } from './config.js';\n\nexport class StorageManager {\n  constructor() {\n    this.storageKey = 'schach9x9_save_';\n    this.autoSaveKey = 'autosave';\n  }\n\n  /**\n     * Save the game state\n     * @param {Game} game - The game instance\n     * @param {string} slotName - Name of the save slot (default: 'autosave')\n     */\n  saveGame(game, slotName = 'autosave') {\n    try {\n      const gameState = {\n        timestamp: Date.now(),\n        mode: game.mode,\n        difficulty: game.difficulty,\n        isAI: game.isAI,\n        savedAt: new Date().toISOString(),\n        // Core State\n        board: game.board,\n        turn: game.turn,\n        phase: game.phase,\n        points: game.points, // Setup phase points\n        // History & Captures\n        moveHistory: game.moveHistory, // Assumes serializable\n        capturedPieces: game.capturedPieces,\n        // Time\n        whiteTime: game.whiteTime,\n        blackTime: game.blackTime,\n        clockEnabled: game.clockEnabled,\n        // Meta\n        lastMove: game.lastMove\n      };\n\n      const key = this.storageKey + slotName;\n      const json = JSON.stringify(gameState);\n      localStorage.setItem(key, json);\n      console.log(`[Storage] Game saved to ${key} (${json.length} bytes)`);\n      return true;\n    } catch (error) {\n      console.error('[Storage] Failed to save game:', error);\n      return false;\n    }\n  }\n\n  /**\n     * Load a game state\n     * @param {string} slotName - Name of the save slot\n     * @returns {object|null} The deserialized game state or null\n     */\n  loadGame(slotName = 'autosave') {\n    const key = this.storageKey + slotName;\n    const json = localStorage.getItem(key);\n\n    if (!json) {\n      console.warn(`[Storage] No save found for ${key}`);\n      return null;\n    }\n\n    try {\n      const state = JSON.parse(json);\n      console.log(`[Storage] Game loaded from ${key}`);\n      return state;\n    } catch (error) {\n      console.error('[Storage] Failed to parse save game:', error);\n      throw new Error('CORRUPT_SAVE');\n    }\n  }\n\n  /**\n     * Check if a save exists\n     */\n  hasSave(slotName = 'autosave') {\n    return localStorage.getItem(this.storageKey + slotName) !== null;\n  }\n\n  /**\n     * Apply a saved state to a game instance\n     * Note: This modifies the game in-place. Alternatively, create a new Game.\n     * @param {Game} game - The game object to hydrate\n     * @param {object} state - The loaded state object\n     */\n  loadStateIntoGame(game, state) {\n    if (!state) return false;\n\n    // Restore basic types\n    game.mode = state.mode;\n    game.difficulty = state.difficulty;\n    game.isAI = state.isAI;\n    game.turn = state.turn;\n    game.phase = state.phase;\n    game.points = state.points || 0;\n\n    // Restore deep structures (JSON.parse creates new objects, which is fine)\n    game.board = state.board;\n    game.moveHistory = state.moveHistory || [];\n    game.capturedPieces = state.capturedPieces || { white: [], black: [] };\n\n    // Restore Clock\n    game.whiteTime = state.whiteTime;\n    game.blackTime = state.blackTime;\n    game.clockEnabled = state.clockEnabled;\n\n    game.lastMove = state.lastMove || null;\n\n    // Reset specialized state\n    game.selectedSquare = null;\n    game.validMoves = null;\n\n    return true;\n  }\n}\n\nexport const storageManager = new StorageManager();\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/tutorController.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'pawns' is assigned a value but never used.","line":599,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":599,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PHASES, BOARD_SIZE } from './gameEngine.js';\nimport * as UI from './ui.js';\nimport { logger } from './logger.js';\nimport { debounce } from './utils.js';\n\nexport class TutorController {\n  constructor(game) {\n    this.game = game;\n    // Debounce the heavy calculation part\n    this.debouncedGetTutorHints = debounce(() => {\n      this.game.bestMoves = this.getTutorHints();\n    }, 300);\n\n    this.evalHistory = [];\n  }\n\n  updateBestMoves() {\n    // Disable tutor in classic mode (AI vs AI) to save performance\n    if (this.game.mode === 'classic') {\n      this.game.bestMoves = [];\n      return;\n    }\n\n    if (this.game.phase === PHASES.PLAY && (!this.game.isAI || this.game.turn === 'white')) {\n      const originalWarn = console.warn;\n      console.warn = () => { };\n\n      try {\n        // Use debounced version to avoid blocking the main thread too often\n        this.debouncedGetTutorHints();\n      } finally {\n        console.warn = originalWarn;\n      }\n    } else {\n      this.game.bestMoves = [];\n    }\n  }\n\n  isTutorMove(from, to) {\n    if (!this.game.bestMoves || this.game.bestMoves.length === 0) return false;\n    return this.game.bestMoves.some(\n      hint =>\n        hint.move.from.r === from.r &&\n                hint.move.from.c === from.c &&\n                hint.move.to.r === to.r &&\n                hint.move.to.c === to.c\n    );\n  }\n\n  getTutorHints() {\n    if (this.game.phase !== PHASES.PLAY) {\n      return [];\n    }\n\n    // Only show hints when it's the human player's turn\n    if (this.game.isAI && this.game.turn === 'black') {\n      return []; // Don't give hints for AI\n    }\n\n    const moves = this.game.getAllLegalMoves(this.game.turn);\n\n    if (moves.length === 0) return [];\n\n    // Quick heuristic scoring for initial filtering (fast, no deep search)\n    const quickScored = [];\n    for (const move of moves) {\n      const fromPiece = this.game.board[move.from.r][move.from.c];\n      if (!fromPiece || fromPiece.color !== this.game.turn) continue;\n\n      const targetPiece = this.game.board[move.to.r][move.to.c];\n      if (targetPiece && targetPiece.color === this.game.turn) continue;\n\n      // Quick heuristic: captures > center control > other\n      let heuristic = 0;\n      if (targetPiece) {\n        const values = { p: 1, n: 3, b: 3, r: 5, q: 9, e: 12, a: 7, c: 8, k: 100 };\n        heuristic += values[targetPiece.type] * 100; // Prioritize captures\n      }\n      // Center control bonus\n      if (move.to.r >= 3 && move.to.r <= 5 && move.to.c >= 3 && move.to.c <= 5) {\n        heuristic += 20;\n      }\n\n      quickScored.push({ move, heuristic });\n    }\n\n    // Sort by heuristic and take top 8 candidates for deep evaluation (reduced from 15)\n    quickScored.sort((a, b) => b.heuristic - a.heuristic);\n    const topCandidates = quickScored.slice(0, Math.min(8, quickScored.length));\n\n    // Evaluate top candidates with shallow Minimax (depth 2 for better accuracy)\n    const evaluatedMoves = [];\n    const depth = 2; // Depth 2 for better tactical awareness\n\n    for (const { move } of topCandidates) {\n      const fromPiece = this.game.board[move.from.r][move.from.c];\n      const validForPiece = this.game.getValidMoves(move.from.r, move.from.c, fromPiece);\n      const isReallyValid = validForPiece.some(v => v.r === move.to.r && v.c === move.to.c);\n\n      if (!isReallyValid) continue;\n\n      const score = this.game.minimax(move, depth, true, -Infinity, Infinity);\n      const displayScore = -score;\n      const notation = this.getMoveNotation(move);\n\n      evaluatedMoves.push({\n        move,\n        score: displayScore,\n        notation,\n      });\n    }\n\n    // Sort by score (best first)\n    evaluatedMoves.sort((a, b) => b.score - a.score);\n\n    // Log only summary\n    if (evaluatedMoves.length > 0) {\n      logger.debug(`Tutor: Evaluated ${evaluatedMoves.length}/${moves.length} moves, best: ${evaluatedMoves[0].notation} (${evaluatedMoves[0].score})`);\n    }\n\n    // Get best score for relative comparison\n    const bestScore = evaluatedMoves.length > 0 ? evaluatedMoves[0].score : 0;\n\n    // Return top 3 with analysis\n    return evaluatedMoves.slice(0, 3).map(hint => {\n      const analysis = this.analyzeMoveWithExplanation(hint.move, hint.score, bestScore);\n      return {\n        ...hint,\n        analysis,\n      };\n    });\n  }\n\n  getMoveNotation(move) {\n    const piece = this.game.board[move.from.r][move.from.c];\n\n    // Handle null piece gracefully\n    if (!piece) {\n      const fromNotation = String.fromCharCode(97 + move.from.c) + (BOARD_SIZE - move.from.r);\n      const toNotation = String.fromCharCode(97 + move.to.c) + (BOARD_SIZE - move.to.r);\n      return `Zug ${fromNotation}${toNotation}`;\n    }\n\n    const targetPiece = this.game.board[move.to.r][move.to.c];\n    const pieceSymbol = UI.getPieceText(piece);\n    const fromNotation = String.fromCharCode(97 + move.from.c) + (BOARD_SIZE - move.from.r);\n    const toNotation = String.fromCharCode(97 + move.to.c) + (BOARD_SIZE - move.to.r);\n\n    // Get piece names in German\n    const pieceNames = {\n      p: 'Bauer',\n      n: 'Springer',\n      b: 'Lufer',\n      r: 'Turm',\n      q: 'Dame',\n      k: 'Knig',\n      a: 'Erzbischof',\n      c: 'Kanzler',\n      e: 'Engel', // Angel piece\n    };\n    const pieceName = pieceNames[piece.type];\n\n    if (targetPiece) {\n      const targetName = pieceNames[targetPiece.type];\n      return `${pieceSymbol} ${pieceName} schlgt ${targetName} (${fromNotation}${toNotation})`;\n    } else {\n      return `${pieceSymbol} ${pieceName} nach ${toNotation}`;\n    }\n  }\n\n  showTutorSuggestions() {\n    UI.showTutorSuggestions(this.game);\n  }\n\n  getPieceName(type) {\n    const names = {\n      p: 'Bauer',\n      n: 'Springer',\n      b: 'Lufer',\n      r: 'Turm',\n      q: 'Dame',\n      k: 'Knig',\n      a: 'Erzbischof',\n      c: 'Kanzler',\n      e: 'Engel', // Angel piece\n    };\n    return names[type] || type;\n  }\n\n  getThreatenedPieces(pos, attackerColor) {\n    const threatened = [];\n    const piece = this.game.board[pos.r][pos.c];\n    if (!piece) return threatened;\n\n    const moves = this.game.getValidMoves(pos.r, pos.c, piece);\n\n    moves.forEach(move => {\n      const targetPiece = this.game.board[move.r][move.c];\n      if (targetPiece && targetPiece.color !== attackerColor) {\n        threatened.push({\n          piece: targetPiece,\n          pos: { r: move.r, c: move.c },\n          type: targetPiece.type,\n          name: this.getPieceName(targetPiece.type),\n        });\n      }\n    });\n\n    return threatened;\n  }\n\n  detectTacticalPatterns(move) {\n    const patterns = [];\n    const from = move.from;\n    const to = move.to;\n    const piece = this.game.board[from.r][from.c];\n\n    if (!piece) return patterns;\n\n    // Simulate the move temporarily\n    const capturedPiece = this.game.board[to.r][to.c];\n    this.game.board[to.r][to.c] = piece;\n    this.game.board[from.r][from.c] = null;\n\n    try {\n      const opponentColor = piece.color === 'white' ? 'black' : 'white';\n\n      // 1. FORK - Attacks 2+ valuable pieces\n      const threatened = this.getThreatenedPieces(to, piece.color);\n      const valuableThreatened = threatened.filter(t => t.type !== 'p');\n\n      if (valuableThreatened.length >= 2) {\n        const pieces = valuableThreatened.map(t => t.name).join(' und ');\n        patterns.push({\n          type: 'fork',\n          severity: 'high',\n          explanation: ` Gabelangriff! Bedroht: ${pieces}`,\n        });\n      }\n\n      // 2. CAPTURE - Taking material\n      if (capturedPiece) {\n        const pieceName = this.getPieceName(capturedPiece.type);\n        patterns.push({\n          type: 'capture',\n          severity: 'medium',\n          explanation: ` Schlgt ${pieceName}`,\n        });\n      }\n\n      // 3. CHECK - Threatening opponent's king\n      if (this.game.isInCheck(opponentColor)) {\n        patterns.push({\n          type: 'check',\n          severity: 'high',\n          explanation: ' Schach! Bedroht gegnerischen Knig',\n        });\n      }\n\n      // 4. PIN - Piece is pinning an opponent piece\n      const pinned = this.detectPins(to, piece.color);\n      if (pinned.length > 0) {\n        const pinnedPiece = pinned[0];\n        patterns.push({\n          type: 'pin',\n          severity: 'high',\n          explanation: ` Fesselung! ${pinnedPiece.pinnedName} kann nicht ziehen`,\n        });\n      }\n\n      // 5. DISCOVERED ATTACK - Moving reveals an attack\n      const discoveredAttacks = this.detectDiscoveredAttacks(from, to, piece.color);\n      if (discoveredAttacks.length > 0) {\n        const target = discoveredAttacks[0];\n        patterns.push({\n          type: 'discovered',\n          severity: 'high',\n          explanation: ` Abzugsangriff auf ${target.name}!`,\n        });\n      }\n\n      // 6. DEFENSE - Defending a threatened piece\n      const defendedPieces = this.getDefendedPieces(to, piece.color);\n      if (defendedPieces.length > 0 && defendedPieces.some(d => d.wasThreatened)) {\n        const defended = defendedPieces.find(d => d.wasThreatened);\n        patterns.push({\n          type: 'defense',\n          severity: 'medium',\n          explanation: ` Verteidigt bedrohten ${defended.name}`,\n        });\n      }\n    } finally {\n      // Restore board\n      this.game.board[from.r][from.c] = piece;\n      this.game.board[to.r][to.c] = capturedPiece;\n    }\n\n    return patterns;\n  }\n\n  /**\n     * Detect if a piece at the given position is pinning an opponent piece\n     * Returns array of pinned pieces\n     */\n  detectPins(pos, attackerColor) {\n    const pinned = [];\n    const piece = this.game.board[pos.r][pos.c];\n\n    if (!piece || !['r', 'b', 'q', 'a', 'c'].includes(piece.type)) {\n      return pinned; // Only sliding pieces can pin\n    }\n\n    const opponentColor = attackerColor === 'white' ? 'black' : 'white';\n\n    // Check all directions this piece can move\n    const moves = this.game.getValidMoves(pos.r, pos.c, piece);\n\n    for (const move of moves) {\n      const targetPiece = this.game.board[move.r][move.c];\n      if (!targetPiece || targetPiece.color !== opponentColor) continue;\n\n      // Check if there's a more valuable piece behind this one in the same line\n      const dr = Math.sign(move.r - pos.r);\n      const dc = Math.sign(move.c - pos.c);\n\n      let r = move.r + dr;\n      let c = move.c + dc;\n\n      while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {\n        const behindPiece = this.game.board[r][c];\n        if (behindPiece) {\n          if (behindPiece.color === opponentColor && behindPiece.type === 'k') {\n            // Found a pin!\n            pinned.push({\n              pinnedPos: { r: move.r, c: move.c },\n              pinnedPiece: targetPiece,\n              pinnedName: this.getPieceName(targetPiece.type),\n              behindPiece: behindPiece,\n              behindName: this.getPieceName(behindPiece.type),\n            });\n          }\n          break; // Stop at first piece\n        }\n        r += dr;\n        c += dc;\n      }\n    }\n\n    return pinned;\n  }\n\n  /**\n     * Detect discovered attacks - attacks revealed by moving a piece\n     */\n  detectDiscoveredAttacks(from, to, attackerColor) {\n    const discovered = [];\n    const opponentColor = attackerColor === 'white' ? 'black' : 'white';\n\n    // Check all our sliding pieces to see if moving from->to reveals an attack\n    for (let r = 0; r < BOARD_SIZE; r++) {\n      for (let c = 0; c < BOARD_SIZE; c++) {\n        const piece = this.game.board[r][c];\n        if (!piece || piece.color !== attackerColor) continue;\n        if (!['r', 'b', 'q', 'a', 'c'].includes(piece.type)) continue;\n        if (r === from.r && c === from.c) continue; // Skip the moving piece\n\n        // Check if 'from' is blocking this piece's attack\n        const dr = Math.sign(from.r - r);\n        const dc = Math.sign(from.c - c);\n\n        // Must be on same line\n        if (dr === 0 && dc === 0) continue;\n\n        // Check if piece can move in this direction\n        const canMoveInDirection = this.canPieceMove(piece.type, dr, dc);\n        if (!canMoveInDirection) continue;\n\n        // Trace the line and see if 'from' was blocking an attack\n        let checkR = r + dr;\n        let checkC = c + dc;\n        let foundFrom = false;\n\n        while (checkR >= 0 && checkR < BOARD_SIZE && checkC >= 0 && checkC < BOARD_SIZE) {\n          if (checkR === from.r && checkC === from.c) {\n            foundFrom = true;\n            checkR += dr;\n            checkC += dc;\n            continue;\n          }\n\n          const targetPiece = this.game.board[checkR][checkC];\n          if (targetPiece) {\n            if (foundFrom && targetPiece.color === opponentColor && targetPiece.type !== 'p') {\n              discovered.push({\n                attackingPiece: piece,\n                target: targetPiece,\n                name: this.getPieceName(targetPiece.type),\n              });\n            }\n            break;\n          }\n\n          checkR += dr;\n          checkC += dc;\n        }\n      }\n    }\n\n    return discovered;\n  }\n\n  /**\n     * Helper to check if a piece type can move in a given direction\n     */\n  canPieceMove(type, dr, dc) {\n    if (type === 'r' || type === 'c') {\n      // Rook/Chancellor: orthogonal\n      return (dr === 0) !== (dc === 0);\n    }\n    if (type === 'b' || type === 'a') {\n      // Bishop/Archbishop: diagonal\n      return Math.abs(dr) === Math.abs(dc) && dr !== 0;\n    }\n    if (type === 'q') {\n      // Queen: both\n      return true;\n    }\n    return false;\n  }\n\n  /**\n     * Detect threats to own pieces after making a move\n     */\n  detectThreatsAfterMove(move) {\n    const threats = [];\n    const from = move.from;\n    const to = move.to;\n    const piece = this.game.board[from.r][from.c];\n\n    if (!piece) return threats;\n\n    // Simulate the move\n    const capturedPiece = this.game.board[to.r][to.c];\n    this.game.board[to.r][to.c] = piece;\n    this.game.board[from.r][from.c] = null;\n\n    try {\n      const opponentColor = piece.color === 'white' ? 'black' : 'white';\n\n      // Check if any of our pieces are now under attack and undefended\n      for (let r = 0; r < BOARD_SIZE; r++) {\n        for (let c = 0; c < BOARD_SIZE; c++) {\n          const ownPiece = this.game.board[r][c];\n          if (!ownPiece || ownPiece.color !== piece.color) continue;\n          if (ownPiece.type === 'p') continue; // Don't warn about pawns\n\n          // Is this piece under attack?\n          const isUnderAttack = this.game.isSquareUnderAttack(r, c, opponentColor);\n          if (isUnderAttack) {\n            // Is it defended?\n            const defenders = this.countDefenders(r, c, piece.color);\n            const attackers = this.countAttackers(r, c, opponentColor);\n\n            if (attackers > defenders) {\n              threats.push({\n                piece: ownPiece,\n                pos: { r, c },\n                warning: ` ${this.getPieceName(ownPiece.type)} wird ungeschtzt!`,\n              });\n            }\n          }\n        }\n      }\n    } finally {\n      // Restore board\n      this.game.board[from.r][from.c] = piece;\n      this.game.board[to.r][to.c] = capturedPiece;\n    }\n\n    return threats;\n  }\n\n  /**\n     * Count how many pieces defend a square\n     */\n  countDefenders(r, c, defenderColor) {\n    let count = 0;\n    for (let pr = 0; pr < BOARD_SIZE; pr++) {\n      for (let pc = 0; pc < BOARD_SIZE; pc++) {\n        const piece = this.game.board[pr][pc];\n        if (!piece || piece.color !== defenderColor) continue;\n\n        const moves = this.game.getValidMoves(pr, pc, piece);\n        if (moves.some(m => m.r === r && m.c === c)) {\n          count++;\n        }\n      }\n    }\n    return count;\n  }\n\n  /**\n     * Count how many pieces attack a square\n     */\n  countAttackers(r, c, attackerColor) {\n    let count = 0;\n    for (let pr = 0; pr < BOARD_SIZE; pr++) {\n      for (let pc = 0; pc < BOARD_SIZE; pc++) {\n        const piece = this.game.board[pr][pc];\n        if (!piece || piece.color !== attackerColor) continue;\n\n        const moves = this.game.getValidMoves(pr, pc, piece);\n        if (moves.some(m => m.r === r && m.c === c)) {\n          count++;\n        }\n      }\n    }\n    return count;\n  }\n\n\n  getDefendedPieces(pos, defenderColor) {\n    const defended = [];\n    const piece = this.game.board[pos.r][pos.c];\n    if (!piece) return defended;\n\n    const moves = this.game.getValidMoves(pos.r, pos.c, piece);\n\n    moves.forEach(move => {\n      const targetPiece = this.game.board[move.r][move.c];\n      if (targetPiece && targetPiece.color === defenderColor) {\n        // Check if this piece is threatened by opponent\n        const opponentColor = defenderColor === 'white' ? 'black' : 'white';\n        const wasThreatened = this.game.isSquareUnderAttack(move.r, move.c, opponentColor);\n\n        defended.push({\n          piece: targetPiece,\n          pos: { r: move.r, c: move.c },\n          type: targetPiece.type,\n          name: this.getPieceName(targetPiece.type),\n          wasThreatened,\n        });\n      }\n    });\n\n    return defended;\n  }\n\n  analyzeStrategicValue(move) {\n    const strategic = [];\n    const to = move.to;\n    const from = move.from;\n    const piece = this.game.board[from.r][from.c];\n\n    if (!piece) return strategic;\n\n    // Center control (middle 3x3 area)\n    const centerSquares = [\n      [3, 3],\n      [3, 4],\n      [3, 5],\n      [4, 3],\n      [4, 4],\n      [4, 5],\n      [5, 3],\n      [5, 4],\n      [5, 5],\n    ];\n    const isCenter = centerSquares.some(c => c[0] === to.r && c[1] === to.c);\n\n    if (isCenter) {\n      strategic.push({\n        type: 'center_control',\n        explanation: ' Kontrolliert das Zentrum',\n      });\n    }\n\n    // Development - moving a piece for the first time (except pawns)\n    if (!piece.hasMoved && piece.type !== 'p' && piece.type !== 'k') {\n      strategic.push({\n        type: 'development',\n        explanation: ' Entwickelt neue Figur',\n      });\n    }\n\n    // Castling\n    if (move.specialMove && move.specialMove.type === 'castling') {\n      strategic.push({\n        type: 'castling',\n        explanation: ' Rochade - Sichert Knig',\n      });\n    }\n\n    return strategic;\n  }\n\n  getScoreDescription(score) {\n    // Score is in centipawns (100 = 1 pawn advantage)\n    const pawns = score / 100;\n\n    if (score >= 900) {\n      return { label: ' Gewinnstellung', color: '#10b981', emoji: '' };\n    } else if (score >= 500) {\n      return { label: ' Groer Vorteil', color: '#22c55e', emoji: '' };\n    } else if (score >= 200) {\n      return { label: ' Klarer Vorteil', color: '#4ade80', emoji: '' };\n    } else if (score >= 50) {\n      return { label: ' Leichter Vorteil', color: '#86efac', emoji: '' };\n    } else if (score >= -50) {\n      return { label: ' Ausgeglichen', color: '#94a3b8', emoji: '' };\n    } else if (score >= -200) {\n      return { label: ' Leichter Nachteil', color: '#fca5a5', emoji: '' };\n    } else if (score >= -500) {\n      return { label: ' Schwieriger', color: '#f87171', emoji: '' };\n    } else if (score >= -900) {\n      return { label: ' Groer Nachteil', color: '#ef4444', emoji: '' };\n    } else {\n      return { label: ' Verloren', color: '#dc2626', emoji: '' };\n    }\n  }\n\n  analyzeMoveWithExplanation(move, score, bestScore) {\n    const tacticalExplanations = [];\n    const strategicExplanations = [];\n    const warnings = [];\n    let category = 'normal';\n\n    // Calculate difference from best move (relative quality)\n    // score and bestScore are from perspective of player (higher is better)\n    const diff = score - bestScore;\n    const diffPawns = (diff / 100).toFixed(1);\n\n    // Categorize based on relative score\n    let qualityLabel = '';\n    if (diff >= -0.5) {\n      // Top tier move\n      if (score >= 300) {\n        category = 'excellent';\n        qualityLabel = ' Gewinnzug! Diese Stellung ist entscheidend.';\n      } else if (diff >= -0.1) {\n        category = 'excellent';\n        qualityLabel = ' Bester Zug';\n      } else {\n        category = 'good';\n        qualityLabel = ` Guter Zug (minimal schwcher: ${Math.abs(parseFloat(diffPawns))} Bauern)`;\n      }\n    } else if (diff >= -1.5) {\n      category = 'normal';\n      qualityLabel = ` Solider Zug (${Math.abs(parseFloat(diffPawns))} Bauern schwcher als bester Zug)`;\n    } else if (diff >= -3.0) {\n      category = 'questionable';\n      qualityLabel = ` Fragwrdig (${Math.abs(parseFloat(diffPawns))} Bauern schlechter)`;\n      warnings.push('Es gibt deutlich bessere Zge! berlege nochmal.');\n    } else {\n      category = 'mistake';\n      qualityLabel = ` Fehler (${Math.abs(parseFloat(diffPawns))} Bauern Nachteil)`;\n      warnings.push(' Dieser Zug verschenkt Material oder Position!');\n    }\n\n    // Detect tactical patterns\n    const patterns = this.detectTacticalPatterns(move);\n    patterns.forEach(pattern => {\n      tacticalExplanations.push(pattern.explanation);\n    });\n\n    // Analyze strategic value\n    const strategic = this.analyzeStrategicValue(move);\n    strategic.forEach(s => {\n      strategicExplanations.push(s.explanation);\n    });\n\n    // Check for threats to own pieces after this move\n    const threats = this.detectThreatsAfterMove(move);\n    if (threats.length > 0) {\n      threats.forEach(threat => {\n        warnings.push(threat.warning);\n      });\n    }\n\n    return {\n      move,\n      score,\n      category,\n      qualityLabel,\n      tacticalExplanations,\n      strategicExplanations,\n      warnings,\n      tacticalPatterns: patterns,\n      strategicValue: strategic,\n      scoreDiff: diff,\n    };\n  }\n\n  /**\n     * Handles player move for \"Guess the Move\" and Blunder Warnings\n     */\n  handlePlayerMove(from, to) {\n    if (this.game.phase !== PHASES.PLAY) return;\n\n    // Get the move from legal moves\n    const moves = this.game.getAllLegalMoves(this.game.turn);\n    const move = moves.find(m => m.from.r === from.r && m.from.c === from.c && m.to.r === to.r && m.to.c === to.c);\n\n    if (!move) return;\n\n    // 1. Guess the Move Logic\n    if (this.game.tutorMode === 'guess_the_move') {\n      const bestMoves = this.game.bestMoves || [];\n      if (bestMoves.length > 0) {\n        const isBest = bestMoves.some(hint =>\n          hint.move.from.r === from.r && hint.move.from.c === from.c &&\n                    hint.move.to.r === to.r && hint.move.to.c === to.c\n        );\n\n        if (isBest) {\n          this.game.tutorPoints += 10;\n          UI.showToast('Richtig geraten! +10 Tutor-Punkte', 'success');\n        } else {\n          UI.showToast('Nicht der beste Zug, aber das Spiel geht weiter.', 'neutral');\n        }\n      }\n    }\n\n    // 2. Blunder Detection\n    // This needs to be checked AFTER the move is made to see the evaluation drop\n    // Actually, we should check it IN executeMove or right after.\n    // We'll call this from moveController.executeMove after evalScore is calculated.\n  }\n\n  checkBlunder(moveRecord) {\n    if (!moveRecord || this.game.mode === 'puzzle') return;\n\n    const currentEval = moveRecord.evalScore;\n    const prevEval = this.game.lastEval || 0;\n    const turn = moveRecord.piece.color;\n\n    // Advantage drop (from perspective of current player)\n    // If White moved, eval should increase. If it decreased significantly, it's a blunder.\n    // White: drop = prevEval - currentEval\n    // Black: drop = currentEval - prevEval\n    const drop = turn === 'white' ? (prevEval - currentEval) : (currentEval - prevEval);\n\n    if (drop >= 200) { // 2.0 evaluation drop is a blunder\n      const analysis = this.analyzeMoveWithExplanation(moveRecord, currentEval, turn === 'white' ? prevEval : -prevEval);\n      this.showBlunderWarning(analysis);\n    }\n\n    this.game.lastEval = currentEval;\n  }\n\n  showBlunderWarning(analysis) {\n    const warnings = analysis.warnings.join('\\n');\n    const explanation = analysis.tacticalExplanations.join('\\n') || 'Kein konkretes taktisches Motiv erkannt, aber die Stellung verschlechtert sich deutlich.';\n\n    UI.showModal(' Schwerer Fehler (Blunder)',\n      `Dieser Zug verschlechtert deine Stellung um ${(analysis.scoreDiff / -100).toFixed(1)} Bauern.\\n\\n${warnings}\\n\\n${explanation}\\n\\nMchtest du den Zug zurcknehmen?`,\n      [\n        { text: 'Nein, weiterspielen', class: 'btn-secondary' },\n        { text: 'Ja, Zug rckgngig machen', class: 'btn-primary', callback: () => this.game.undoMove() }\n      ]\n    );\n  }\n  getSetupTemplates() {\n    const points = this.game.initialPoints;\n\n    // Templates for 12 points\n    const templates12 = [\n      {\n        id: 'fortress_12',\n        name: ' Die Festung',\n        description: 'Defensiv mit Turm und Lufern.',\n        pieces: ['r', 'b', 'b', 'p'], // 5+3+3+1 = 12\n        cost: 12\n      },\n      {\n        id: 'rush_12',\n        name: ' Der Ansturm',\n        description: 'Aggressiv mit Dame und Bauern.',\n        pieces: ['q', 'p', 'p', 'p'], // 9+1+1+1 = 12\n        cost: 12\n      },\n      {\n        id: 'flexible_12',\n        name: ' Flexibel',\n        description: 'Ausgewogen mit Springer und Lufer.',\n        pieces: ['n', 'n', 'b', 'p', 'p', 'p'], // 3+3+3+1+1+1 = 12\n        cost: 12\n      },\n      {\n        id: 'swarm_12',\n        name: ' Der Schwarm',\n        description: 'Viele leichte Figuren.',\n        pieces: ['n', 'b', 'p', 'p', 'p', 'p', 'p'], // 3+3+1+1+1+1+1+1 = 12\n        cost: 12\n      }\n    ];\n\n    // Templates for 15 points\n    const templates15 = [\n      {\n        id: 'fortress_15',\n        name: ' Die Festung',\n        description: 'Defensive Strategie: 2 Trme kontrollieren wichtige Linien, Lufer untersttzt. Ideal gegen aggressive Gegner.',\n        pieces: ['r', 'r', 'b', 'p', 'p'], // 5+5+3+1+1 = 15\n        cost: 15\n      },\n      {\n        id: 'rush_15',\n        name: ' Der Ansturm',\n        description: 'Offensive Strategie: Dame + 2 Springer fr frhen Angriffsdruck. Fr erfahrene Spieler, die schnell zuschlagen wollen.',\n        pieces: ['q', 'n', 'n'], // 9+3+3 = 15\n        cost: 15\n      },\n      {\n        id: 'flexible_15',\n        name: ' Flexibel',\n        description: 'Ausgewogene Strategie: Erzbischof (Lufer+Springer-Hybrid) bietet Vielseitigkeit. Anpassbar  an jede Situation.',\n        pieces: ['a', 'r', 'b'], // 7+5+3 = 15\n        cost: 15\n      },\n      {\n        id: 'swarm_15',\n        name: ' Der Schwarm',\n        description: 'Zahlenberlegenheit: Viele leichte Figuren fr Feldkontrolle und Flexibilitt. Schwer fr Gegner zu verteidigen.',\n        pieces: ['n', 'n', 'b', 'b', 'p', 'p', 'p'], // 3+3+3+3+1+1+1 = 15\n        cost: 15\n      }\n    ];\n\n    // Templates for 18 points\n    const templates18 = [\n      {\n        id: 'fortress_18',\n        name: ' Die Festung',\n        description: 'Maximale Defensive mit 2 Trmen und Erzbischof.',\n        pieces: ['r', 'r', 'a', 'p'], // 5+5+7+1 = 18\n        cost: 18\n      },\n      {\n        id: 'rush_18',\n        name: ' Der Ansturm',\n        description: 'Doppelte Damen fr maximalen Druck.',\n        pieces: ['q', 'q'], // 9+9 = 18\n        cost: 18\n      },\n      {\n        id: 'flexible_18',\n        name: ' Flexibel',\n        description: 'Kanzler, Dame und Bauer fr Vielseitigkeit.',\n        pieces: ['c', 'q', 'p'], // 8+9+1 = 18\n        cost: 18\n      },\n      {\n        id: 'swarm_18',\n        name: ' Der Schwarm',\n        description: 'Erzbischof mit vielen leichten Figuren.',\n        pieces: ['a', 'n', 'n', 'b', 'p', 'p'], // 7+3+3+3+1+1 = 18\n        cost: 18\n      }\n    ];\n\n    // Return templates matching the current game's point budget\n    if (points === 12) return templates12;\n    if (points === 18) return templates18;\n    return templates15; // Default to 15 points\n  }\n\n  applySetupTemplate(templateId) {\n    const template = this.getSetupTemplates().find(t => t.id === templateId);\n    if (!template) return;\n\n    // Determine current corridor\n    const isWhite = this.game.phase === PHASES.SETUP_WHITE_PIECES;\n    const corridor = isWhite ? this.game.whiteCorridor : this.game.blackCorridor;\n    if (!corridor) return;\n\n    // Clear existing pieces in corridor (except King)\n    // And refund points\n    for (let r = corridor.rowStart; r < Math.min(corridor.rowStart + 3, BOARD_SIZE); r++) {\n      for (let c = corridor.colStart; c < Math.min(corridor.colStart + 3, BOARD_SIZE); c++) {\n        // Bounds check\n        if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) continue;\n\n        const piece = this.game.board[r][c];\n        if (piece && piece.type !== 'k') {\n          this.game.board[r][c] = null;\n        }\n      }\n    }\n\n    // Reset points\n    this.game.points = this.game.initialPoints;\n\n    // --- Smarter Placement Logic ---\n\n    // 1. Define Rows based on color (Back, Middle, Front)\n    let frontRow, middleRow, backRow;\n    if (isWhite) {\n      // White is at bottom (rows 6,7,8). Front is 6 (closest to center).\n      frontRow = corridor.rowStart;     // 6\n      middleRow = corridor.rowStart + 1; // 7\n      backRow = corridor.rowStart + 2;   // 8\n    } else {\n      // Black is at top (rows 0,1,2). Front is 2 (closest to center).\n      frontRow = corridor.rowStart + 2; // 2\n      middleRow = corridor.rowStart + 1; // 1\n      backRow = corridor.rowStart;      // 0\n    }\n\n    // Helper to get available squares in a specific row\n    const getAvailableInRow = (r) => {\n      if (r < 0 || r >= BOARD_SIZE) return [];\n      const squares = [];\n      for (let c = corridor.colStart; c < corridor.colStart + 3; c++) {\n        // Check if square is empty or has a piece we can overwrite (not King)\n        const piece = this.game.board[r][c];\n        if (!piece || piece.type !== 'k') {\n          squares.push({ r, c });\n        }\n      }\n      return squares;\n    };\n\n    const frontSquares = getAvailableInRow(frontRow);\n    let middleSquares = getAvailableInRow(middleRow);\n    let backSquares = getAvailableInRow(backRow);\n\n    // Helper to place a piece in the first available slot from a list\n    const placeInSlots = (pieceType, slots) => {\n      if (slots.length > 0) {\n        const sq = slots.shift();\n        this.placePiece(sq.r, sq.c, pieceType, isWhite);\n        return true;\n      }\n      return false;\n    };\n\n    // Helper to place in specific priority: Back -> Middle -> Front\n    const placeAnywhere = (pieceType) => {\n      if (placeInSlots(pieceType, backSquares)) return;\n      if (placeInSlots(pieceType, middleSquares)) return;\n      if (placeInSlots(pieceType, frontSquares)) return;\n    };\n\n    // Categorize pieces from template\n    const pawns = template.pieces.filter(p => p === 'p');\n    const rooks = template.pieces.filter(p => p === 'r' || p === 'c'); // Rooks and Chancellors prefer corners\n    const bishops = template.pieces.filter(p => p === 'b' || p === 'a'); // Bishops/Archbishops prefer diagonals\n    const knights = template.pieces.filter(p => p === 'n');\n    const queens = template.pieces.filter(p => p === 'q');\n    const others = template.pieces.filter(p => !['p', 'r', 'c', 'b', 'a', 'n', 'q'].includes(p));\n\n    // --- Execution Phase ---\n\n    // 1. Pawns -> Front Row Shield\n    pawns.forEach(p => {\n      if (!placeInSlots(p, frontSquares)) {\n        // Overflow to middle if front is full\n        if (!placeInSlots(p, middleSquares)) {\n          placeInSlots(p, backSquares);\n        }\n      }\n    });\n\n    // 2. Rooks/Chancellors -> Back Row Corners\n    rooks.forEach(p => {\n      // Sort backSquares to find corners (cols 0 and 2 relative to corridor)\n      const corners = backSquares.filter(sq => sq.c === corridor.colStart || sq.c === corridor.colStart + 2);\n      if (corners.length > 0) {\n        // Take a corner\n        const sq = corners[0];\n        // Remove from backSquares\n        backSquares = backSquares.filter(s => s !== sq);\n        this.placePiece(sq.r, sq.c, p, isWhite);\n      } else {\n        placeAnywhere(p);\n      }\n    });\n\n    // 3. Bishops/Archbishops -> Back Row Center or Middle Row\n    bishops.forEach(p => {\n      // Try Back Row Center first (Col 1 relative to corridor)\n      const centerBack = backSquares.find(sq => sq.c === corridor.colStart + 1);\n      if (centerBack) {\n        backSquares = backSquares.filter(s => s !== centerBack);\n        this.placePiece(centerBack.r, centerBack.c, p, isWhite);\n      } else {\n        // Try Middle Row Corners (for fianchetto style)\n        const cornersMiddle = middleSquares.filter(sq => sq.c === corridor.colStart || sq.c === corridor.colStart + 2);\n        if (cornersMiddle.length > 0) {\n          const sq = cornersMiddle[0];\n          middleSquares = middleSquares.filter(s => s !== sq);\n          this.placePiece(sq.r, sq.c, p, isWhite);\n        } else {\n          placeAnywhere(p);\n        }\n      }\n    });\n\n    // 4. Queens -> Best available (Back Center preference)\n    queens.forEach(p => {\n      // Try Back Row Center if still open\n      const centerBack = backSquares.find(sq => sq.c === corridor.colStart + 1);\n      if (centerBack) {\n        backSquares = backSquares.filter(s => s !== centerBack);\n        this.placePiece(centerBack.r, centerBack.c, p, isWhite);\n      } else {\n        placeAnywhere(p);\n      }\n    });\n\n    // 5. Knights -> Middle Row (Central control)\n    knights.forEach(p => {\n      if (!placeInSlots(p, middleSquares)) {\n        placeAnywhere(p);\n      }\n    });\n\n    // 6. Others (Angels, etc.) -> Anywhere\n    others.forEach(p => {\n      placeAnywhere(p);\n    });\n\n    // Update UI\n    UI.renderBoard(this.game);\n    UI.updateShopUI(this.game);\n\n    // Log\n    this.game.log(`Tutor: Aufstellung \"${template.name}\" angewendet.`);\n  }\n\n  placePiece(r, c, type, isWhite) {\n    this.game.board[r][c] = {\n      type: type,\n      color: isWhite ? 'white' : 'black',\n      hasMoved: false\n    };\n\n    // Deduct points\n    const getVal = (type) => {\n      const map = { q: 9, c: 8, a: 7, r: 5, n: 3, b: 3, p: 1, e: 12 };\n      return map[type] || 0;\n    };\n    this.game.points -= getVal(type);\n  }\n}\n\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/tutorial.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/ui.js","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Identifier 'showModal' has already been declared","line":1748,"column":17,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// ui.js\n/**\n * UI-Modul fr Schach9x9.\n * Beinhaltet DOM-Manipulation, Event-Listener und Rendering.\n * @module ui\n */\nimport { BOARD_SIZE, PHASES, PIECE_VALUES } from './config.js';\nimport { debounce } from './utils.js';\nimport { particleSystem } from './effects.js';\n\n// ... (keep existing code until updateMoveHistoryUI)\n\nexport function updateMoveHistoryUI(game) {\n  const historyEl = document.getElementById('move-history');\n  if (!historyEl) return;\n\n  try {\n    historyEl.innerHTML = '';\n    game.moveHistory.forEach((move, index) => {\n      const moveEl = document.createElement('div');\n      moveEl.className = 'move-entry';\n\n      // Standard Algebraic Notation (SAN)\n      const pieceSymbols = { p: '', n: 'N', b: 'B', r: 'R', q: 'Q', k: 'K', a: 'A', c: 'C', e: 'E' };\n      const pieceChar = pieceSymbols[move.piece.type];\n\n      const fromFile = String.fromCharCode(97 + move.from.c);\n      const fromRank = BOARD_SIZE - move.from.r;\n      const toFile = String.fromCharCode(97 + move.to.c);\n      const toRank = BOARD_SIZE - move.to.r;\n\n      let moveText = '';\n\n      if (move.specialMove && move.specialMove.type === 'castling') {\n        moveText = move.specialMove.isKingside ? 'O-O' : 'O-O-O';\n      } else {\n        moveText += pieceChar;\n\n        // Disambiguation (simplified: always show file if pawn capture, else just piece)\n        // Real SAN is complex, but let's do a decent approximation\n        if (move.piece.type === 'p' && move.capturedPiece) {\n          moveText += fromFile;\n        }\n\n        if (move.capturedPiece || (move.specialMove && move.specialMove.type === 'enPassant')) {\n          moveText += 'x';\n        }\n\n        moveText += toFile + toRank;\n\n        if (move.specialMove && move.specialMove.type === 'promotion') {\n          const promoSymbol = pieceSymbols[move.specialMove.promotedTo] || '';\n          moveText += `=${promoSymbol}`;\n        }\n      }\n\n      // Check/Checkmate indication would need game state history or re-evaluation\n      // For now, we omit +/# unless we store it in moveRecord\n\n      moveEl.textContent = `${index + 1}. ${moveText}`;\n      historyEl.appendChild(moveEl);\n    });\n\n    // Scroll to bottom\n    historyEl.scrollTop = historyEl.scrollHeight;\n\n    // Update undo button state\n    const undoBtn = document.getElementById('undo-btn');\n    if (undoBtn) {\n      undoBtn.disabled = game.moveHistory.length === 0 || game.phase !== PHASES.PLAY;\n    }\n  } catch (error) {\n    console.error('Error updating move history:', error);\n  }\n}\n\nexport function updateCapturedUI(game) {\n  const whiteContainer = document.getElementById('captured-white');\n  const blackContainer = document.getElementById('captured-black');\n\n  if (!whiteContainer || !blackContainer) return;\n\n  whiteContainer.innerHTML = '';\n  blackContainer.innerHTML = '';\n\n  // Calculate material value\n  let whiteMaterial = 0; // Material ON BOARD\n  let blackMaterial = 0;\n\n  // We can calculate from board or from captured pieces.\n  // Calculating from board is safer.\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const p = game.board[r][c];\n      if (p) {\n        const val = PIECE_VALUES[p.type] || 0;\n        if (p.color === 'white') whiteMaterial += val;\n        else blackMaterial += val;\n      }\n    }\n  }\n\n  const materialDiff = whiteMaterial - blackMaterial;\n\n  // White's captured pieces (Black pieces captured by White)\n  game.capturedPieces.white.forEach(p => {\n    const el = document.createElement('div');\n    el.className = 'captured-piece';\n    el.innerHTML = getPieceSymbol(p);\n    whiteContainer.appendChild(el);\n  });\n\n  // Add material advantage indicator\n  if (materialDiff > 0) {\n    const adv = document.createElement('div');\n    adv.className = 'material-advantage white-adv';\n    adv.textContent = `+${materialDiff}`;\n    whiteContainer.appendChild(adv);\n  }\n\n  // Black's captured pieces (White pieces captured by Black)\n  game.capturedPieces.black.forEach(p => {\n    const el = document.createElement('div');\n    el.className = 'captured-piece';\n    el.innerHTML = getPieceSymbol(p);\n    blackContainer.appendChild(el);\n  });\n\n  if (materialDiff < 0) {\n    const adv = document.createElement('div');\n    adv.className = 'material-advantage black-adv';\n    adv.textContent = `+${Math.abs(materialDiff)}`;\n    blackContainer.appendChild(adv);\n  }\n}\n\n/**\n * Initialisiert das Schachbrett im DOM und fgt Event-Listener hinzu.\n * @param {object} game - Die Game-Instanz\n */\nexport function initBoardUI(game) {\n  const boardEl = document.getElementById('board');\n  boardEl.innerHTML = '';\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const cell = document.createElement('div');\n      cell.className = `cell ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;\n      if (c === 2 || c === 5) cell.classList.add('border-right');\n      if (r === 2 || r === 5) cell.classList.add('border-bottom');\n      cell.dataset.r = r;\n      cell.dataset.c = c;\n      cell.addEventListener('click', () => game.handleCellClick(r, c));\n\n      // Drag & Drop fr Figuren\n      cell.draggable = true;\n\n      cell.addEventListener('dragstart', e => {\n        // Nur im PLAY-Phase und nicht whrend Replay oder AI-Zug\n        if (game.phase !== PHASES.PLAY || game.replayMode || game.isAnimating) {\n          e.preventDefault();\n          return false;\n        }\n\n        // Prfe ob es eine Figur gibt und ob es der Spieler am Zug ist\n        const piece = game.board[r][c];\n        if (!piece) {\n          e.preventDefault();\n          return false;\n        }\n\n        // Prfe ob es die Figur des aktuellen Spielers ist\n        if (game.isAI && game.turn === 'black') {\n          e.preventDefault();\n          return false;\n        }\n\n        if (piece.color !== game.turn) {\n          e.preventDefault();\n          return false;\n        }\n\n        // Speichere die Startposition\n        e.dataTransfer.setData('text/plain', `${r},${c}`);\n        e.dataTransfer.effectAllowed = 'move';\n\n        // Visuelles Feedback: Zelle wird halbtransparent\n        cell.classList.add('dragging');\n\n        // Erstelle ein Drag-Bild\n        const dragImage = cell.cloneNode(true);\n        dragImage.style.opacity = '0.8';\n        dragImage.style.transform = 'rotate(5deg)';\n        document.body.appendChild(dragImage);\n        dragImage.style.position = 'absolute';\n        dragImage.style.top = '-1000px';\n        e.dataTransfer.setDragImage(dragImage, cell.offsetWidth / 2, cell.offsetHeight / 2);\n        setTimeout(() => document.body.removeChild(dragImage), 0);\n\n        // Zeige mgliche Zge\n        const validMoves = game.getValidMoves(r, c, piece);\n        validMoves.forEach(move => {\n          const targetCell = document.querySelector(\n            `.cell[data-r=\"${move.r}\"][data-c=\"${move.c}\"]`\n          );\n          if (targetCell) {\n            targetCell.classList.add('drag-target');\n          }\n        });\n      });\n\n      cell.addEventListener('dragend', () => {\n        // Entferne alle Drag-Markierungen\n        cell.classList.remove('dragging');\n        document\n          .querySelectorAll('.cell.drag-target')\n          .forEach(c => c.classList.remove('drag-target'));\n        document.querySelectorAll('.cell.drag-over').forEach(c => c.classList.remove('drag-over'));\n      });\n\n      cell.addEventListener('dragover', e => {\n        e.preventDefault();\n        e.dataTransfer.dropEffect = 'move';\n\n        // Prfe ob es ein gltiges Ziel ist\n        const data = e.dataTransfer.getData('text/plain');\n        if (!data) return;\n\n        const [fromR, fromC] = data.split(',').map(Number);\n        const piece = game.board[fromR][fromC];\n        if (!piece) return;\n\n        const validMoves = game.getValidMoves(fromR, fromC, piece);\n        const isValidTarget = validMoves.some(move => move.r === r && move.c === c);\n\n        if (isValidTarget) {\n          cell.classList.add('drag-over');\n        }\n      });\n\n      cell.addEventListener('dragleave', () => {\n        cell.classList.remove('drag-over');\n      });\n\n      cell.addEventListener('drop', e => {\n        e.preventDefault();\n        cell.classList.remove('drag-over');\n\n        const data = e.dataTransfer.getData('text/plain');\n        if (!data) return;\n\n        const [fromR, fromC] = data.split(',').map(Number);\n\n        // Prfe ob es ein gltiger Zug ist\n        const piece = game.board[fromR][fromC];\n        if (!piece || piece.color !== game.turn) return;\n\n        const validMoves = game.getValidMoves(fromR, fromC, piece);\n        const isValidMove = validMoves.some(move => move.r === r && move.c === c);\n\n        if (isValidMove) {\n          // Fhre den Zug aus\n          game.selectedSquare = { r: fromR, c: fromC };\n          game.validMoves = validMoves;\n          game.handleCellClick(r, c);\n        }\n      });\n\n      // Hover-Effekte fr mgliche Zge\n      cell.addEventListener(\n        'mouseenter',\n        debounce(() => {\n          if (game.phase === PHASES.PLAY && !game.replayMode) {\n            const piece = game.board[r][c];\n            if (piece) {\n              // Zeige mgliche Zge dieser Figur beim Hover\n              const hoverMoves = game.getValidMoves(r, c, piece);\n              hoverMoves.forEach(move => {\n                const targetCell = document.querySelector(\n                  `.cell[data-r=\"${move.r}\"][data-c=\"${move.c}\"]`\n                );\n                if (targetCell) {\n                  targetCell.classList.add('hover-move');\n                }\n              });\n              // Markiere die Figur selbst\n              cell.classList.add('hover-piece');\n            }\n          }\n        }, 50)\n      );\n\n      cell.addEventListener('mouseleave', () => {\n        // Entferne alle Hover-Markierungen\n        document\n          .querySelectorAll('.cell.hover-move')\n          .forEach(c => c.classList.remove('hover-move'));\n        document\n          .querySelectorAll('.cell.hover-piece')\n          .forEach(c => c.classList.remove('hover-piece'));\n      });\n\n      boardEl.appendChild(cell);\n    }\n  }\n\n  // Add coordinate labels\n  // Column labels (a-i)\n  const colLabels = document.createElement('div');\n  colLabels.className = 'col-labels';\n  for (let c = 0; c < BOARD_SIZE; c++) {\n    const label = document.createElement('span');\n    label.textContent = String.fromCharCode(97 + c);\n    label.className = 'coord-label';\n    colLabels.appendChild(label);\n  }\n\n  // Row labels (9-1)\n  const rowLabels = document.createElement('div');\n  rowLabels.className = 'row-labels';\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    const label = document.createElement('span');\n    label.textContent = (BOARD_SIZE - r).toString();\n    label.className = 'coord-label';\n    rowLabels.appendChild(label);\n  }\n\n  const boardWrapper = document.getElementById('board-wrapper');\n  if (boardWrapper) {\n    // Clean up existing labels\n    boardWrapper.querySelectorAll('.col-labels, .row-labels').forEach(el => el.remove());\n\n    // Insert new labels\n    boardWrapper.appendChild(colLabels);\n    boardWrapper.appendChild(rowLabels);\n  }\n  // shop listeners etc. can be added by the main script.\n}\n\n/**\n * Rendert das Schachbrett und die Figuren im DOM.\n * @param {object} game - Die Game-Instanz\n */\n\n/**\n * Gibt das SVG-Symbol fr eine Figur zurck.\n * @param {object} piece - Die Figur\n * @returns {string} HTML-String des SVGs\n */\nexport function getPieceSymbol(piece) {\n  if (!piece) return '';\n  // Lazy-Loading: SVG nur beim ersten Mal in den DOM einfgen, dann cachen\n  // Wir nutzen hier ein globales Cache-Objekt oder hngen es an window,\n  // aber sauberer ist es, es im Modul-Scope zu halten.\n  if (!window._svgCache) window._svgCache = {};\n  const key = piece.color + piece.type;\n  if (!window._svgCache[key]) {\n    const wrapper = document.createElement('div');\n    wrapper.className = 'piece-svg';\n    wrapper.innerHTML = window.PIECE_SVGS[piece.color][piece.type];\n    window._svgCache[key] = wrapper.innerHTML;\n  }\n  return window._svgCache[key];\n}\n\nexport function getPieceText(piece) {\n  if (!piece) return '';\n  const symbols = {\n    white: {\n      p: '',\n      n: '',\n      b: '',\n      r: '',\n      q: '',\n      k: '',\n      a: 'A',\n      c: 'C',\n      e: 'E',\n    },\n    black: {\n      p: '',\n      n: '',\n      b: '',\n      r: '',\n      q: '',\n      k: '',\n      a: 'A',\n      c: 'C',\n      e: 'E',\n    },\n  };\n  return symbols[piece.color][piece.type];\n}\n\n/**\n * Rendert das Schachbrett und die Figuren im DOM.\n * @param {object} game - Die Game-Instanz\n */\nexport function renderBoard(game) {\n  // Performance-Optimierung: Initialisiere previousBoardState beim ersten Aufruf\n  if (!game._previousBoardState) {\n    game._previousBoardState = Array(BOARD_SIZE)\n      .fill(null)\n      .map(() => Array(BOARD_SIZE).fill(null));\n    game._forceFullRender = true;\n  }\n\n  // CRITICAL: Clear all corridor highlighting first to handle phase transitions\n  // This ensures old corridor highlights are removed when phase changes\n  document.querySelectorAll('.cell.selectable-corridor').forEach(cell => {\n    cell.classList.remove('selectable-corridor');\n  });\n\n  // Bestimme welche Zellen sich gendert haben\n  const changedCells = [];\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const currentPiece = game.board[r][c];\n      const previousPiece = game._previousBoardState[r][c];\n\n      // Prfe ob sich die Figur gendert hat\n      const pieceChanged =\n        (!currentPiece && previousPiece) ||\n        (currentPiece && !previousPiece) ||\n        (currentPiece &&\n          previousPiece &&\n          (currentPiece.type !== previousPiece.type || currentPiece.color !== previousPiece.color));\n\n      if (game._forceFullRender || pieceChanged) {\n        changedCells.push({ r, c });\n        game._previousBoardState[r][c] = currentPiece\n          ? { type: currentPiece.type, color: currentPiece.color }\n          : null;\n      }\n    }\n  }\n\n  // Rendere nur genderte Zellen (oder alle beim ersten Mal)\n  const cellsToRender = game._forceFullRender\n    ? Array.from({ length: BOARD_SIZE * BOARD_SIZE }, (_, i) => ({\n      r: Math.floor(i / BOARD_SIZE),\n      c: i % BOARD_SIZE,\n    }))\n    : changedCells;\n\n  game._forceFullRender = false;\n\n  for (const { r, c } of cellsToRender) {\n    const cell = document.querySelector(`.cell[data-r=\"${r}\"][data-c=\"${c}\"]`);\n    if (!cell) continue;\n\n    const piece = game.board[r][c];\n    const pieceSymbol = getPieceSymbol(piece);\n\n    // Nur innerHTML aktualisieren wenn sich die Figur gendert hat\n    if (cell.innerHTML !== pieceSymbol) {\n      cell.innerHTML = pieceSymbol;\n    }\n\n    // Clear highlights\n    cell.classList.remove(\n      'highlight',\n      'corridor',\n      'valid-move',\n      'last-move',\n      'tutor-move',\n      'threatened'\n    );\n\n    // Always clear corridor highlighting, will be re-added below based on phase\n    cell.classList.remove('selectable-corridor');\n\n    if (game.selectedSquare && game.selectedSquare.r === r && game.selectedSquare.c === c) {\n      cell.classList.add('highlight');\n    }\n\n    // Highlight valid moves\n    if (game.validMoves) {\n      const move = game.validMoves.find(m => m.r === r && m.c === c);\n      if (move) {\n        cell.classList.add('valid-move');\n        if (game.isTutorMove && game.isTutorMove(game.selectedSquare, { r, c })) {\n          cell.classList.add('tutor-move');\n        }\n      }\n    }\n\n    // Highlight last move\n    if (game.lastMoveHighlight) {\n      if (\n        (game.lastMoveHighlight.from.r === r && game.lastMoveHighlight.from.c === c) ||\n        (game.lastMoveHighlight.to.r === r && game.lastMoveHighlight.to.c === c)\n      ) {\n        cell.classList.add('last-move');\n      }\n    }\n\n    // Markiere bedrohte Figuren (nur im PLAY-Phase)\n    if (game.phase === PHASES.PLAY && piece) {\n      const opponentColor = piece.color === 'white' ? 'black' : 'white';\n      if (game.isSquareUnderAttack && game.isSquareUnderAttack(r, c, opponentColor)) {\n        cell.classList.add('threatened');\n      }\n    }\n  }\n\n  // Apply corridor highlighting to ALL cells (not just changed cells)\n  // This must be done outside the cellsToRender loop to handle phase transitions\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const cell = document.querySelector(`.cell[data-r=\"${r}\"][data-c=\"${c}\"]`);\n      if (!cell) continue;\n\n      // Apply corridor highlighting based on current phase\n\n      // 1. King Setup Phase (Choosing a corridor)\n      // Only show options if it's a human player's turn\n      const isSetupWhite = game.phase === PHASES.SETUP_WHITE_KING;\n      const isSetupBlack = game.phase === PHASES.SETUP_BLACK_KING;\n      const isHumanTurn = isSetupWhite || (isSetupBlack && !game.isAI);\n\n      if (isHumanTurn) {\n        const isWhite = isSetupWhite;\n        const rowStart = isWhite ? 6 : 0;\n        // Highlight all three 3x3 corridors for king placement\n        if (r >= rowStart && r < rowStart + 3) {\n          // Corridor 1: columns 0-2, Corridor 2: columns 3-5, Corridor 3: columns 6-8\n          const inCorridor = (c >= 0 && c <= 2) || (c >= 3 && c <= 5) || (c >= 6 && c <= 8);\n          if (inCorridor) {\n            cell.classList.add('selectable-corridor');\n          }\n        }\n      }\n\n      // 2. Piece Setup Phase (Selected corridor highlighting)\n      // Only highlight the corridor for the player currently setting up pieces\n      // AND allow seeing own corridor while waiting for opponent king setup\n\n      if (game.whiteCorridor && (game.phase === PHASES.SETUP_WHITE_PIECES || game.phase === PHASES.SETUP_BLACK_KING)) {\n        if (\n          r >= game.whiteCorridor.rowStart &&\n          r < game.whiteCorridor.rowStart + 3 &&\n          c >= game.whiteCorridor.colStart &&\n          c < game.whiteCorridor.colStart + 3\n        ) {\n          cell.classList.add('selectable-corridor');\n        }\n      }\n\n      if (game.blackCorridor && game.phase === PHASES.SETUP_BLACK_PIECES) {\n        if (\n          r >= game.blackCorridor.rowStart &&\n          r < game.blackCorridor.rowStart + 3 &&\n          c >= game.blackCorridor.colStart &&\n          c < game.blackCorridor.colStart + 3\n        ) {\n          cell.classList.add('selectable-corridor');\n        }\n      }\n    }\n  }\n\n  // Auch alle Zellen aktualisieren wenn sich Highlights gendert haben knnten\n  if (\n    game._lastSelectedSquare !== game.selectedSquare ||\n    game._lastValidMoves !== game.validMoves ||\n    game._lastMoveHighlight !== game.lastMoveHighlight\n  ) {\n    // Update highlights fr alle Zellen\n    for (let r = 0; r < BOARD_SIZE; r++) {\n      for (let c = 0; c < BOARD_SIZE; c++) {\n        const cell = document.querySelector(`.cell[data-r=\"${r}\"][data-c=\"${c}\"]`);\n        if (!cell) continue;\n\n        cell.classList.remove('highlight', 'valid-move', 'tutor-move', 'last-move', 'threatened');\n\n        // Always clear corridor highlighting, will be re-added below based on phase\n        cell.classList.remove('selectable-corridor');\n\n        // Re-apply corridor highlighting for setup phases\n\n        // 1. King Setup Phase\n        const isSetupWhite = game.phase === PHASES.SETUP_WHITE_KING;\n        const isSetupBlack = game.phase === PHASES.SETUP_BLACK_KING;\n        const isHumanTurn = isSetupWhite || (isSetupBlack && !game.isAI);\n\n        if (isHumanTurn) {\n          const isWhite = isSetupWhite;\n          const rowStart = isWhite ? 6 : 0;\n          // Highlight all three 3x3 corridors for king placement\n          if (r >= rowStart && r < rowStart + 3) {\n            // Corridor 1: columns 0-2, Corridor 2: columns 3-5, Corridor 3: columns 6-8\n            const inCorridor = (c >= 0 && c <= 2) || (c >= 3 && c <= 5) || (c >= 6 && c <= 8);\n            if (inCorridor) {\n              cell.classList.add('selectable-corridor');\n            }\n          }\n        }\n\n        // 2. Selected Corridor Highlighting\n        if (game.whiteCorridor && (game.phase === PHASES.SETUP_WHITE_PIECES || game.phase === PHASES.SETUP_BLACK_KING)) {\n          if (\n            r >= game.whiteCorridor.rowStart &&\n            r < game.whiteCorridor.rowStart + 3 &&\n            c >= game.whiteCorridor.colStart &&\n            c < game.whiteCorridor.colStart + 3\n          ) {\n            cell.classList.add('selectable-corridor');\n          }\n        }\n\n        if (game.blackCorridor && game.phase === PHASES.SETUP_BLACK_PIECES) {\n          if (\n            r >= game.blackCorridor.rowStart &&\n            r < game.blackCorridor.rowStart + 3 &&\n            c >= game.blackCorridor.colStart &&\n            c < game.blackCorridor.colStart + 3\n          ) {\n            cell.classList.add('selectable-corridor');\n          }\n        }\n\n        if (game.selectedSquare && game.selectedSquare.r === r && game.selectedSquare.c === c) {\n          cell.classList.add('highlight');\n        }\n\n        if (game.validMoves) {\n          const move = game.validMoves.find(m => m.r === r && m.c === c);\n          if (move) {\n            cell.classList.add('valid-move');\n            if (game.isTutorMove && game.isTutorMove(game.selectedSquare, { r, c })) {\n              cell.classList.add('tutor-move');\n            }\n          }\n        }\n\n        if (game.lastMoveHighlight) {\n          if (\n            (game.lastMoveHighlight.from.r === r && game.lastMoveHighlight.from.c === c) ||\n            (game.lastMoveHighlight.to.r === r && game.lastMoveHighlight.to.c === c)\n          ) {\n            cell.classList.add('last-move');\n          }\n        }\n\n        // Markiere bedrohte Figuren\n        const piece = game.board[r][c];\n        if (game.phase === PHASES.PLAY && piece) {\n          const opponentColor = piece.color === 'white' ? 'black' : 'white';\n          if (game.isSquareUnderAttack && game.isSquareUnderAttack(r, c, opponentColor)) {\n            cell.classList.add('threatened');\n          }\n        }\n      }\n    }\n\n    game._lastSelectedSquare = game.selectedSquare ? { ...game.selectedSquare } : null;\n    game._lastValidMoves = game.validMoves ? [...game.validMoves] : null;\n    game._lastMoveHighlight = game.lastMoveHighlight ? { ...game.lastMoveHighlight } : null;\n  }\n}\n\n/**\n * Aktualisiert die Statusanzeige im UI.\n * @param {object} game - Die Game-Instanz\n */\nexport function updateStatus(game) {\n  const statusEl = document.getElementById('status-display');\n  if (!statusEl) return;\n\n  let text = '';\n  switch (game.phase) {\n    case PHASES.SETUP_WHITE_KING:\n      text = 'Wei: Whle einen Korridor fr den Knig';\n      break;\n    case PHASES.SETUP_BLACK_KING:\n      text = 'Schwarz: Whle einen Korridor fr den Knig';\n      break;\n    case PHASES.SETUP_WHITE_PIECES:\n      text = 'Wei: Kaufe Truppen';\n      break;\n    case PHASES.SETUP_BLACK_PIECES:\n      text = 'Schwarz: Kaufe Truppen';\n      break;\n    case PHASES.PLAY:\n      text = `Spiel luft - ${game.turn === 'white' ? 'Wei' : 'Schwarz'} am Zug`;\n      break;\n    case PHASES.ANALYSIS:\n      text = ` Analyse-Modus - ${game.turn === 'white' ? 'Wei' : 'Schwarz'} am Zug`;\n      break;\n    case PHASES.GAME_OVER:\n      text = `Spiel vorbei! ${game.turn === 'white' ? 'Wei' : 'Schwarz'} hat gewonnen!`;\n      break;\n  }\n  statusEl.textContent = text;\n}\n\nexport function updateClockUI(game) {\n  const whiteClockEl = document.getElementById('clock-white');\n  const blackClockEl = document.getElementById('clock-black');\n\n  if (whiteClockEl && blackClockEl) {\n    whiteClockEl.classList.remove('active', 'low-time');\n    blackClockEl.classList.remove('active', 'low-time');\n\n    if (game.turn === 'white') {\n      whiteClockEl.classList.add('active');\n      if (game.whiteTime < 30) whiteClockEl.classList.add('low-time');\n    } else {\n      blackClockEl.classList.add('active');\n      if (game.blackTime < 30) blackClockEl.classList.add('low-time');\n    }\n  }\n}\n\nexport function updateClockDisplay(game) {\n  const formatTime = seconds => {\n    const mins = Math.floor(seconds / 60);\n    const secs = Math.floor(seconds % 60);\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  const whiteEl = document.getElementById('clock-white');\n  const blackEl = document.getElementById('clock-black');\n\n  if (whiteEl) whiteEl.textContent = formatTime(game.whiteTime);\n  if (blackEl) blackEl.textContent = formatTime(game.blackTime);\n}\n\nexport function showShop(game, show) {\n  const panel = document.getElementById('shop-panel');\n  if (show) {\n    panel.classList.remove('hidden');\n    // Ensure we are in setup mode UI-wise\n    document.body.classList.add('setup-mode');\n  } else {\n    panel.classList.add('hidden');\n    document.body.classList.remove('setup-mode');\n  }\n  updateShopUI(game);\n}\n\nexport function updateShopUI(game) {\n  const pointsDisplay = document.getElementById('points-display');\n  if (pointsDisplay) pointsDisplay.textContent = game.points;\n\n  // Update tutor points\n  const tutorPointsDisplay = document.getElementById('tutor-points-display');\n  if (tutorPointsDisplay) tutorPointsDisplay.textContent = game.tutorPoints || 0;\n\n  // Disable buttons if too expensive\n  document.querySelectorAll('.shop-item').forEach(btn => {\n    const cost = parseInt(btn.dataset.cost);\n    if (cost > game.points) {\n      btn.classList.add('disabled');\n      btn.style.opacity = '0.5';\n      btn.style.pointerEvents = 'none';\n    } else {\n      btn.classList.remove('disabled');\n      btn.style.opacity = '1';\n      btn.style.pointerEvents = 'auto';\n    }\n  });\n\n  const finishBtn = document.getElementById('finish-setup-btn');\n  if (finishBtn) {\n    finishBtn.disabled = false;\n  }\n\n  const statusDisplay = document.getElementById('selected-piece-display');\n  if (statusDisplay) {\n    if (game.selectedShopPiece) {\n      statusDisplay.textContent = `Platziere: ${getPieceText({ type: game.selectedShopPiece, color: game.turn })} (${PIECE_VALUES[game.selectedShopPiece]} Pkt)`;\n    } else {\n      statusDisplay.textContent = 'Whle eine Figur zum Kaufen';\n    }\n  }\n\n  // Update tutor recommendations section\n  updateTutorRecommendations(game);\n}\n\nfunction updateTutorRecommendations(game) {\n  const toggleBtn = document.getElementById('toggle-tutor-recommendations');\n  const container = document.getElementById('tutor-recommendations-container');\n\n  if (!toggleBtn || !container) return;\n\n  // Check if we're in setup phase and tutor is available\n  const inSetupPhase = game.phase === PHASES.SETUP_WHITE_PIECES || game.phase === PHASES.SETUP_BLACK_PIECES;\n  const tutorSection = document.getElementById('tutor-recommendations-section');\n\n  if (!inSetupPhase || !game.tutorController || !game.tutorController.getSetupTemplates) {\n    if (tutorSection) tutorSection.classList.add('hidden');\n    return;\n  }\n\n  if (tutorSection) tutorSection.classList.remove('hidden');\n\n  // Setup toggle button handler (only once)\n  if (!toggleBtn.dataset.initialized) {\n    toggleBtn.addEventListener('click', () => {\n      const isHidden = container.classList.contains('hidden');\n      container.classList.toggle('hidden');\n      toggleBtn.textContent = isHidden ? ' KI-Empfehlungen ausblenden' : ' KI-Empfehlungen anzeigen';\n    });\n    toggleBtn.dataset.initialized = 'true';\n  }\n\n  // Populate templates if empty or needs refresh\n  if (container.children.length === 0) {\n    const templates = game.tutorController.getSetupTemplates();\n    container.innerHTML = '';\n\n    templates.forEach(template => {\n      const card = document.createElement('div');\n      card.className = 'setup-template-card';\n\n      // Build pieces preview using SVGs if available\n      const piecesPreview = template.pieces.map(pieceType => {\n        const color = game.phase === PHASES.SETUP_WHITE_PIECES ? 'white' : 'black';\n        if (window.PIECE_SVGS && window.PIECE_SVGS[color] && window.PIECE_SVGS[color][pieceType]) {\n          return `<span class=\"template-piece-icon\">${window.PIECE_SVGS[color][pieceType]}</span>`;\n        } else {\n          // Fallback to text symbols\n          const symbols = {\n            p: '', n: '', b: '', r: '', q: '',\n            k: '', a: '', c: '', e: ''\n          };\n          return `<span class=\"template-piece-icon\">${symbols[pieceType] || pieceType}</span>`;\n        }\n      }).join('');\n\n      card.innerHTML = `\n        <div class=\"template-name\">${template.name}</div>\n        <div class=\"template-description\">${template.description}</div>\n        <div class=\"template-pieces\">\n          <span>Enthlt:</span>\n          ${piecesPreview}\n        </div>\n      `;\n\n      card.addEventListener('click', () => {\n        if (confirm(`Mchtest du die Aufstellung \"${template.name}\" anwenden?\\n\\nDeine aktuelle Aufstellung wird berschrieben und deine Punkte werden zurckgesetzt.`)) {\n          game.tutorController.applySetupTemplate(template.id);\n          // Refresh the shop UI to reflect the changes\n          updateShopUI(game);\n        }\n      });\n\n      container.appendChild(card);\n    });\n  }\n}\n\nexport function showPromotionUI(game, r, c, color, moveRecord, callback) {\n  const overlay = document.getElementById('promotion-overlay');\n  const optionsContainer = document.getElementById('promotion-options');\n  optionsContainer.innerHTML = '';\n\n  const options = [\n    { type: 'e', symbol: 'E' }, // Angel\n    { type: 'q', symbol: color === 'white' ? '' : '' },\n    { type: 'c', symbol: 'C' }, // Chancellor\n    { type: 'a', symbol: 'A' }, // Archbishop\n    { type: 'r', symbol: color === 'white' ? '' : '' },\n    { type: 'b', symbol: color === 'white' ? '' : '' },\n    { type: 'n', symbol: color === 'white' ? '' : '' },\n  ];\n\n  options.forEach(opt => {\n    const btn = document.createElement('div');\n    btn.className = 'promotion-option';\n    btn.innerHTML = `<div class=\"piece-svg\">${window.PIECE_SVGS[color][opt.type]}</div>`;\n    btn.onclick = () => {\n      // Update board directly\n      if (game.board[r][c]) {\n        game.board[r][c].type = opt.type;\n\n        // Update move record with promotion info\n        if (moveRecord) {\n          moveRecord.specialMove = { type: 'promotion', promotedTo: opt.type };\n        }\n\n        if (game.log) game.log(`${color === 'white' ? 'Weier' : 'Schwarzer'} Bauer befrdert!`);\n        overlay.classList.add('hidden');\n        renderBoard(game); // Re-render to show new piece\n        // We need to trigger the callback to finish the move\n        if (callback) callback();\n      }\n    };\n    optionsContainer.appendChild(btn);\n  });\n\n  overlay.classList.remove('hidden');\n}\n\nexport async function animateMove(game, from, to, piece) {\n  game.isAnimating = true;\n  return new Promise(resolve => {\n    // Get the cells\n    const fromCell = document.querySelector(`.cell[data-r=\"${from.r}\"][data-c=\"${from.c}\"]`);\n    const toCell = document.querySelector(`.cell[data-r=\"${to.r}\"][data-c=\"${to.c}\"]`);\n\n    if (!fromCell || !toCell) {\n      game.isAnimating = false;\n      resolve();\n      return;\n    }\n\n    // Get the piece element or create one if missing (e.g. if board re-rendered)\n    let pieceElement = fromCell.querySelector('.piece-svg');\n    if (!pieceElement) {\n      // Create a temporary one\n      const wrapper = document.createElement('div');\n      wrapper.className = 'piece-svg';\n      wrapper.innerHTML = getPieceSymbol(piece);\n      pieceElement = wrapper;\n      fromCell.appendChild(wrapper);\n    }\n\n    // Clone the piece for animation\n    const clone = pieceElement.cloneNode(true);\n    clone.className = 'animating-piece'; // Use specific class for styling if needed\n    clone.style.position = 'fixed';\n    clone.style.zIndex = '10000';\n    clone.style.pointerEvents = 'none';\n    clone.style.transition = 'none'; // Disable transitions initially\n\n    // Get positions\n    const fromRect = fromCell.getBoundingClientRect();\n    clone.style.left = fromRect.left + 'px';\n    clone.style.top = fromRect.top + 'px';\n    clone.style.width = fromRect.width + 'px';\n    clone.style.height = fromRect.height + 'px';\n    clone.style.display = 'flex';\n    clone.style.justifyContent = 'center';\n    clone.style.alignItems = 'center';\n\n    document.body.appendChild(clone);\n\n    // Hide original piece temporarily\n    const originalOpacity = pieceElement.style.opacity;\n    pieceElement.style.opacity = '0';\n\n    // Force reflow\n    clone.offsetHeight;\n\n    // Animate\n    // Calculate distance for dynamic duration? Or fixed?\n    // Fixed is usually more consistent for chess.\n    clone.style.transition = 'transform 0.25s cubic-bezier(0.2, 0.8, 0.2, 1)';\n\n    const toRect = toCell.getBoundingClientRect();\n    const deltaX = toRect.left - fromRect.left;\n    const deltaY = toRect.top - fromRect.top;\n\n    clone.style.transform = `translate(${deltaX}px, ${deltaY}px)`;\n\n    // Spawn particles if capture (we need to know if it's a capture)\n    // We can check if toCell has a piece of opposite color\n    const targetPiece = game.board[to.r][to.c];\n    const isCapture = targetPiece && targetPiece.color !== piece.color;\n\n    setTimeout(() => {\n      if (document.body.contains(clone)) {\n        document.body.removeChild(clone);\n      }\n\n      // Restore opacity (though board might be re-rendered anyway)\n      if (pieceElement) pieceElement.style.opacity = originalOpacity;\n\n      if (isCapture) {\n        const centerX = toRect.left + toRect.width / 2;\n        const centerY = toRect.top + toRect.height / 2;\n        const color = targetPiece.color === 'white' ? '#e2e8f0' : '#1e293b';\n        particleSystem.spawn(centerX, centerY, 'CAPTURE', color);\n      }\n\n      // Move particles (dust)\n      // const fromCenterX = fromRect.left + fromRect.width / 2;\n      // const fromCenterY = fromRect.top + fromRect.height / 2;\n      // particleSystem.spawn(fromCenterX, fromCenterY, 'MOVE', '#888');\n\n      game.isAnimating = false;\n      resolve();\n    }, 250); // Match transition duration\n  });\n}\n\nexport function animateCheck(game, color) {\n  // Find King\n  let kingPos = null;\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const piece = game.board[r][c];\n      if (piece && piece.color === color && piece.type === 'k') {\n        kingPos = { r, c };\n        break;\n      }\n    }\n    if (kingPos) break;\n  }\n\n  if (!kingPos) return;\n\n  const kingCell = document.querySelector(`.cell[data-r=\"${kingPos.r}\"][data-c=\"${kingPos.c}\"]`);\n  if (kingCell) {\n    kingCell.classList.add('in-check');\n    setTimeout(() => {\n      kingCell.classList.remove('in-check');\n    }, 2000);\n  }\n}\n\nexport function animateCheckmate(game, color) {\n  // Find King\n  let kingPos = null;\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const piece = game.board[r][c];\n      if (piece && piece.color === color && piece.type === 'k') {\n        kingPos = { r, c };\n        break;\n      }\n    }\n    if (kingPos) break;\n  }\n\n  if (!kingPos) return;\n\n  const kingCell = document.querySelector(`.cell[data-r=\"${kingPos.r}\"][data-c=\"${kingPos.c}\"]`);\n  if (kingCell) {\n    kingCell.classList.add('checkmate');\n    setTimeout(() => {\n      kingCell.classList.remove('checkmate');\n    }, 3000);\n  }\n}\n\nexport function updateStatistics(game) {\n  // Update move count\n  const movesEl = document.getElementById('stat-moves');\n  if (movesEl) movesEl.textContent = game.stats.totalMoves;\n\n  // Update captures\n  game.stats.captures = (game.capturedPieces?.white?.length || 0) + (game.capturedPieces?.black?.length || 0);\n  const capturesEl = document.getElementById('stat-captures');\n  if (capturesEl) capturesEl.textContent = game.stats.captures;\n\n  // Update accuracy (only for human player)\n  const accuracyEl = document.getElementById('stat-accuracy');\n  if (accuracyEl) {\n    if (game.stats.playerMoves > 0) {\n      const accuracy = Math.round((game.stats.playerBestMoves / game.stats.playerMoves) * 100);\n      accuracyEl.textContent = accuracy + '%';\n    } else {\n      accuracyEl.textContent = '--%';\n    }\n  }\n\n  // Update best moves count\n  const bestMovesEl = document.getElementById('stat-best-moves');\n  if (bestMovesEl) bestMovesEl.textContent = game.stats.playerBestMoves;\n\n  // Update material advantage\n  if (game.calculateMaterialAdvantage) {\n    const materialAdvantage = game.calculateMaterialAdvantage();\n    const materialEl = document.getElementById('stat-material');\n    if (materialEl) {\n      materialEl.textContent = materialAdvantage > 0 ? '+' + materialAdvantage : materialAdvantage;\n      materialEl.classList.remove('positive', 'negative');\n      if (materialAdvantage > 0) {\n        materialEl.classList.add('positive');\n      } else if (materialAdvantage < 0) {\n        materialEl.classList.add('negative');\n      }\n    }\n  }\n}\n\n/**\n * Zeigt das Statistik-Overlay an.\n * @param {object} game - Die Game-Instanz\n */\nexport function showStatisticsOverlay(game) {\n  const overlay = document.getElementById('stats-overlay');\n  if (overlay) {\n    updateStatistics(game);\n    overlay.classList.remove('hidden');\n  }\n}\n\n/**\n * Rendert den Evaluationsgraphen basierend auf der Zughistorie.\n * @param {object} game - Die Game-Instanz\n */\nexport function renderEvalGraph(game) {\n  // Optimization: Don't render if animating to save CPU performance\n  if (game.isAnimating) return;\n\n  const container = document.getElementById('eval-graph-container');\n  const svg = document.getElementById('eval-graph');\n  if (!container || !svg) return;\n\n  // Show container if in analysis or game over phase\n  if (game.phase === PHASES.ANALYSIS || game.phase === PHASES.GAME_OVER) {\n    container.classList.remove('hidden');\n  } else {\n    // container.classList.add('hidden'); // Optional: show always\n  }\n\n  const history = game.moveHistory;\n  if (history.length === 0) {\n    svg.innerHTML = '';\n    return;\n  }\n\n  // Extract scores, handle missing scores (fallback to 0)\n  // Include move 0 (initial position) if possible, but moveHistory starts from first move.\n  // We'll treat the start as 0.\n  const scores = [0, ...history.map(m => m.evalScore || 0)];\n\n  const width = 1000;\n  const height = 100;\n  const centerY = height / 2;\n  const maxEval = 1000; // Cap evaluation at 10.00 pawns for the graph\n\n  // Calculate points\n  const points = scores.map((score, i) => {\n    const x = (i / (scores.length - 1)) * width;\n    // Map score to Y: +1000 -> 0, 0 -> 50, -1000 -> 100\n    const normalizedScore = Math.max(-maxEval, Math.min(maxEval, score));\n    const y = centerY - (normalizedScore / maxEval) * (height / 2);\n    return { x, y, score, index: i - 1 };\n  });\n\n  // Generate SVG content\n  let svgContent = `\n    <defs>\n      <linearGradient id=\"eval-gradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n        <stop offset=\"0%\" style=\"stop-color:#4ade80;stop-opacity:1\" />\n        <stop offset=\"50%\" style=\"stop-color:#4f9cf9;stop-opacity:1\" />\n        <stop offset=\"100%\" style=\"stop-color:#f87171;stop-opacity:1\" />\n      </linearGradient>\n      <linearGradient id=\"area-gradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n        <stop offset=\"0%\" style=\"stop-color:#4ade80;stop-opacity:0.3\" />\n        <stop offset=\"50%\" style=\"stop-color:#4f9cf9;stop-opacity:0.1\" />\n        <stop offset=\"100%\" style=\"stop-color:#f87171;stop-opacity:0.3\" />\n      </linearGradient>\n    </defs>\n    \n    <line x1=\"0\" y1=\"${centerY}\" x2=\"${width}\" y2=\"${centerY}\" class=\"eval-zero-line\" />\n  `;\n\n  // Draw area\n  if (points.length > 1) {\n    let areaPath = `M ${points[0].x} ${centerY} `;\n    points.forEach(p => {\n      areaPath += `L ${p.x} ${p.y} `;\n    });\n    areaPath += `L ${points[points.length - 1].x} ${centerY} Z`;\n    svgContent += `<path d=\"${areaPath}\" class=\"eval-area\" />`;\n\n    // Draw line\n    let linePath = `M ${points[0].x} ${points[0].y} `;\n    for (let i = 1; i < points.length; i++) {\n      // Cubic Bezier for smooth curves (optional)\n      // For now, simple lines are clearer for chess evaluation\n      linePath += `L ${points[i].x} ${points[i].y} `;\n    }\n    svgContent += `<path d=\"${linePath}\" class=\"eval-line\" />`;\n  }\n\n  // Draw interactive points\n  points.forEach((p, i) => {\n    // Only draw every N points if history is very long to avoid DOM bloat\n    const skipFrequency = Math.ceil(points.length / 50);\n    if (i % skipFrequency === 0 || i === points.length - 1) {\n      svgContent += `\n        <circle cx=\"${p.x}\" cy=\"${p.y}\" r=\"3\" class=\"eval-point\" data-index=\"${p.index}\">\n          <title>Zug ${i}: ${(p.score / 100).toFixed(2)}</title>\n        </circle>\n      `;\n    }\n  });\n\n  svg.innerHTML = svgContent;\n\n  // Use event delegation for better performance with many points\n  if (!svg.dataset.hasListener) {\n    svg.addEventListener('click', (e) => {\n      const point = e.target.closest('.eval-point');\n      if (!point) return;\n\n      const index = parseInt(point.dataset.index);\n      if (index >= 0 && game.gameController && game.gameController.jumpToMove) {\n        game.gameController.jumpToMove(index);\n      } else if (index === -1 && game.gameController && game.gameController.jumpToStart) {\n        game.gameController.jumpToStart();\n      }\n    });\n    svg.dataset.hasListener = 'true';\n  }\n}\n\nexport function showTutorSuggestions(game) {\n  const tutorPanel = document.getElementById('tutor-panel');\n  const suggestionsEl = document.getElementById('tutor-suggestions');\n\n  // If old UI elements don't exist, use modal overlay instead\n  if (!tutorPanel || !suggestionsEl) {\n    // Get tutor hints\n    if (!game.tutorController || !game.tutorController.getTutorHints) {\n      alert('Tutor nicht verfgbar!');\n      return;\n    }\n\n    const hints = game.tutorController.getTutorHints();\n    if (hints.length === 0) {\n      alert('Keine Tipps verfgbar! Spiele erst ein paar Zge.');\n      return;\n    }\n\n    // Create modal overlay\n    let overlay = document.getElementById('tutor-overlay');\n    if (!overlay) {\n      overlay = document.createElement('div');\n      overlay.id = 'tutor-overlay';\n      overlay.className = 'modal-overlay';\n      overlay.innerHTML = `\n        <div class=\"modal-content\" style=\"max-width: 500px; text-align: left;\">\n          <div class=\"menu-header\">\n            <h2> KI-Tipps</h2>\n            <button id=\"close-tutor-btn\" class=\"close-icon-btn\"></button>\n          </div>\n          <div id=\"tutor-hints-body\" style=\"max-height: 60vh; overflow-y: auto;\"></div>\n        </div>\n      `;\n      document.body.appendChild(overlay);\n      document.getElementById('close-tutor-btn').addEventListener('click', () => {\n        overlay.classList.add('hidden');\n      });\n    }\n\n    const body = document.getElementById('tutor-hints-body');\n    body.innerHTML = '';\n\n    hints.forEach((hint, index) => {\n      const div = document.createElement('div');\n      div.style.cssText = 'background: rgba(255,255,255,0.05); padding: 15px; border-radius: 12px; margin-bottom: 10px; border-left: 4px solid ' + (hint.analysis.scoreDiff > -0.5 ? '#10b981' : '#f59e0b') + '; cursor: pointer; transition: background 0.2s;';\n      div.onmouseover = () => { div.style.background = 'rgba(255,255,255,0.1)'; };\n      div.onmouseout = () => { div.style.background = 'rgba(255,255,255,0.05)'; };\n\n      div.innerHTML = `\n        <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;\">\n          <strong style=\"font-size: 1.1em;\">${index + 1}. ${hint.notation}</strong>\n          <span style=\"font-size: 0.9em; color: ${hint.analysis.scoreDiff > -0.5 ? '#10b981' : '#f59e0b'}\">${hint.analysis.qualityLabel}</span>\n        </div>\n        <div style=\"font-size: 0.9em; color: #ccc;\">\n          ${hint.analysis.tacticalExplanations.map(e => `<div>${e}</div>`).join('')}\n          ${hint.analysis.strategicExplanations.map(e => `<div>${e}</div>`).join('')}\n        </div>\n      `;\n\n      div.addEventListener('click', () => {\n        overlay.classList.add('hidden');\n        game.executeMove(hint.move.from, hint.move.to);\n      });\n\n      body.appendChild(div);\n    });\n\n    overlay.classList.remove('hidden');\n    return;\n  }\n\n  // Original code for old UI\n  // Clear previous highlights and arrows\n  document.querySelectorAll('.suggestion-highlight').forEach(el => {\n    el.classList.remove('suggestion-highlight');\n  });\n  if (game.arrowRenderer) {\n    game.arrowRenderer.clearArrows();\n  }\n\n  suggestionsEl.innerHTML = '';\n\n  // Check for Setup Phase\n  if (game.phase === PHASES.SETUP_WHITE_PIECES || game.phase === PHASES.SETUP_BLACK_PIECES) {\n    if (game.tutorController && game.tutorController.getSetupTemplates) {\n      const templates = game.tutorController.getSetupTemplates();\n\n      const header = document.createElement('h3');\n      header.textContent = ' Empfohlene Aufstellungen';\n      header.style.marginBottom = '1rem';\n      suggestionsEl.appendChild(header);\n\n      templates.forEach(template => {\n        const el = document.createElement('div');\n        el.className = 'setup-template';\n        el.style.cssText = `\n            background: rgba(34, 197, 94, 0.1);\n            border: 1px solid rgba(34, 197, 94, 0.3);\n            border-radius: 8px;\n            padding: 1rem;\n            margin-bottom: 1rem;\n            cursor: pointer;\n            transition: all 0.2s;\n        `;\n        el.onmouseover = () => { el.style.background = 'rgba(34, 197, 94, 0.2)'; };\n        el.onmouseout = () => { el.style.background = 'rgba(34, 197, 94, 0.1)'; };\n\n        el.innerHTML = `\n            <div style=\"font-weight: bold; margin-bottom: 0.5rem; font-size: 1.1rem;\">${template.name}</div>\n            <div style=\"font-size: 0.9rem; color: #cbd5e1; margin-bottom: 0.5rem;\">${template.description}</div>\n            <div style=\"font-size: 0.8rem; color: #94a3b8;\">Kosten: ${template.cost} Punkte</div>\n            <div style=\"font-size: 0.8rem; color: #64748b; margin-top: 0.5rem; display: flex; align-items: center; gap: 0.25rem;\">\n                <span>Enthlt:</span>\n                ${template.pieces.map(p => `<span style=\"display: inline-block; width: 28px; height: 28px;\">${window.PIECE_SVGS ? window.PIECE_SVGS[game.phase === PHASES.SETUP_WHITE_PIECES ? 'white' : 'black'][p] : p}</span>`).join('')}\n            </div>\n        `;\n\n        el.onclick = () => {\n          if (confirm(`Mchtest du die Aufstellung \"${template.name}\" anwenden? Deine aktuelle Aufstellung wird berschrieben.`)) {\n            game.tutorController.applySetupTemplate(template.id);\n            // Close panel? Or keep open? Keep open to see result.\n            // Maybe flash success?\n          }\n        };\n\n        suggestionsEl.appendChild(el);\n      });\n\n      tutorPanel.classList.remove('hidden');\n      return;\n    }\n  }\n\n  // Get tutor hints\n  if (!game.getTutorHints) return;\n  const hints = game.getTutorHints();\n\n  if (hints.length === 0) {\n    suggestionsEl.innerHTML = '<p style=\"padding: 1rem; color: #94a3b8;\">Keine Vorschlge verfgbar.</p>';\n    tutorPanel.classList.remove('hidden');\n    return;\n  }\n\n  const header = document.createElement('h3');\n  header.innerHTML = `\n     Tutor Vorschlge\n    <span style=\"font-size: 0.8rem; font-weight: normal; color: #94a3b8; display: block; margin-top: 0.25rem;\">\n      Beste Zge fr ${game.turn === 'white' ? 'Wei' : 'Schwarz'}\n    </span>\n  `;\n  suggestionsEl.appendChild(header);\n\n  // Display each hint with analysis\n  hints.forEach((hint, index) => {\n    // Use pre-calculated analysis if available, otherwise calculate (fallback)\n    const analysis = hint.analysis || game.analyzeMoveWithExplanation(hint.move, hint.score);\n\n    const suggEl = document.createElement('div');\n    suggEl.className = `tutor-suggestion ${analysis.category}`;\n    suggEl.style.cssText = `\n      margin-bottom: 1rem;\n      cursor: pointer;\n      transition: all 0.2s ease;\n    `;\n\n    // Move overview (always visible)\n    const overview = document.createElement('div');\n    overview.className = 'suggestion-overview';\n    overview.style.cssText = `\n      display: flex;\n      align-items: center;\n      gap: 0.75rem;\n      font-weight: 600;\n      padding: 0.75rem;\n      background: rgba(15, 23, 42, 0.6);\n      border-radius: 8px;\n    `;\n\n    const rankBadge = index === 0 ? '' : index === 1 ? '' : '';\n\n    // Get descriptive score label\n    const scoreDesc = game.getScoreDescription ? game.getScoreDescription(hint.score) : null;\n    const scoreDisplay = scoreDesc\n      ? `<span style=\"color: ${scoreDesc.color};\">${scoreDesc.emoji} ${scoreDesc.label}</span>`\n      : `<span style=\"color: ${hint.score > 0 ? '#22c55e' : '#888'};\">${(hint.score / 100).toFixed(1)}</span>`;\n\n    overview.innerHTML = `\n      <span style=\"font-size: 1.2rem;\">${rankBadge}</span>\n      <span style=\"flex: 1;\">${hint.notation}</span>\n      ${scoreDisplay}\n    `;\n    suggEl.appendChild(overview);\n\n    // Quality Label (New)\n    if (analysis.qualityLabel) {\n      const qualityEl = document.createElement('div');\n      qualityEl.style.cssText = `\n        font-size: 0.9rem;\n        margin-top: 0.5rem;\n        padding: 0 0.75rem;\n        font-weight: 500;\n        color: ${analysis.category === 'excellent' ? '#fbbf24' : analysis.category === 'good' ? '#4ade80' : '#94a3b8'};\n      `;\n      qualityEl.textContent = analysis.qualityLabel;\n      suggEl.appendChild(qualityEl);\n    }\n\n    // Action buttons\n    const actionsEl = document.createElement('div');\n    actionsEl.className = 'suggestion-actions';\n    actionsEl.style.cssText = `\n      display: flex;\n      gap: 0.5rem;\n      margin-top: 0.75rem;\n      padding: 0 0.75rem;\n    `;\n\n    // Try This Move button\n    const tryBtn = document.createElement('button');\n    tryBtn.className = 'try-move-btn';\n    tryBtn.style.cssText = `\n      flex: 1;\n      padding: 0.5rem 1rem;\n      background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);\n      color: white;\n      border: none;\n      border-radius: 6px;\n      font-weight: 600;\n      cursor: pointer;\n      transition: all 0.2s ease;\n      font-size: 0.85rem;\n    `;\n    tryBtn.innerHTML = ' Diesen Zug probieren';\n    tryBtn.onmouseover = () => {\n      tryBtn.style.transform = 'translateY(-2px)';\n      tryBtn.style.boxShadow = '0 4px 12px rgba(79, 70, 229, 0.4)';\n    };\n    tryBtn.onmouseout = () => {\n      tryBtn.style.transform = '';\n      tryBtn.style.boxShadow = '';\n    };\n    tryBtn.onclick = e => {\n      e.stopPropagation(); // Prevent suggestion click handler\n      const fromPos = hint.move.from;\n      const toPos = hint.move.to;\n\n      // Execute the move\n      if (game.executeMove) {\n        game.executeMove(fromPos, toPos);\n\n        // Close tutor panel after move\n        const tutorPanel = document.getElementById('tutor-panel');\n        if (tutorPanel) {\n          tutorPanel.classList.add('hidden');\n        }\n      }\n    };\n\n    actionsEl.appendChild(tryBtn);\n    suggEl.appendChild(actionsEl);\n\n    // Explanations section (expandable)\n    const hasTactical = analysis.tacticalExplanations && analysis.tacticalExplanations.length > 0;\n    const hasStrategic = analysis.strategicExplanations && analysis.strategicExplanations.length > 0;\n    const hasWarnings = analysis.warnings && analysis.warnings.length > 0;\n\n    if (hasTactical || hasStrategic || hasWarnings) {\n      const detailsEl = document.createElement('div');\n      detailsEl.className = 'suggestion-details';\n      detailsEl.style.cssText = `\n        margin-top: 0.75rem;\n        padding: 0.75rem;\n        background: rgba(0, 0, 0, 0.3);\n        border-radius: 6px;\n        font-size: 0.85rem;\n      `;\n\n      // Tactical Explanations\n      if (hasTactical) {\n        const tactDiv = document.createElement('div');\n        tactDiv.className = 'suggestion-tactical';\n        tactDiv.style.marginBottom = '0.5rem';\n        analysis.tacticalExplanations.forEach(expl => {\n          const explItem = document.createElement('div');\n          explItem.style.cssText = `\n            color: #fca5a5;\n            font-weight: 500;\n            margin: 0.25rem 0;\n            padding-left: 0.5rem;\n            border-left: 2px solid #ef4444;\n          `;\n          explItem.textContent = expl;\n          tactDiv.appendChild(explItem);\n        });\n        detailsEl.appendChild(tactDiv);\n      }\n\n      // Strategic Explanations\n      if (hasStrategic) {\n        const stratDiv = document.createElement('div');\n        stratDiv.className = 'suggestion-strategic';\n        analysis.strategicExplanations.forEach(expl => {\n          const explItem = document.createElement('div');\n          explItem.style.cssText = `\n            color: #cbd5e1;\n            margin: 0.25rem 0;\n            padding-left: 0.5rem;\n          `;\n          explItem.textContent = expl;\n          stratDiv.appendChild(explItem);\n        });\n        detailsEl.appendChild(stratDiv);\n      }\n\n      // Warnings\n      if (hasWarnings) {\n        const warnDiv = document.createElement('div');\n        warnDiv.className = 'suggestion-warnings';\n        warnDiv.style.marginTop = '0.5rem';\n        analysis.warnings.forEach(warn => {\n          const warnItem = document.createElement('div');\n          warnItem.style.cssText = `\n            color: #f59e0b;\n            background: rgba(245, 158, 11, 0.1);\n            padding: 0.25rem 0.5rem;\n            border-radius: 4px;\n            margin: 0.25rem 0;\n          `;\n          warnItem.textContent = warn; // Warning already has emoji\n          warnDiv.appendChild(warnItem);\n        });\n        detailsEl.appendChild(warnDiv);\n      }\n\n      suggEl.appendChild(detailsEl);\n    }\n\n    // Click handler to highlight move on board\n    suggEl.addEventListener('click', () => {\n      // Remove previous selection\n      document.querySelectorAll('.tutor-suggestion').forEach(el => {\n        el.style.borderLeft = '';\n      });\n\n      // Highlight this suggestion\n      const color =\n        analysis.category === 'excellent'\n          ? '#fbbf24'\n          : analysis.category === 'good'\n            ? '#22c55e'\n            : '#4f9cf9';\n      suggEl.style.borderLeft = `4px solid ${color}`;\n\n      // Clear previous highlights\n      document.querySelectorAll('.suggestion-highlight').forEach(el => {\n        el.classList.remove('suggestion-highlight');\n      });\n\n      // Draw arrow if available\n      const quality = index === 0 ? 'gold' : index === 1 ? 'silver' : 'bronze';\n      if (game.arrowRenderer) {\n        game.arrowRenderer.highlightMove(\n          hint.move.from.r,\n          hint.move.from.c,\n          hint.move.to.r,\n          hint.move.to.c,\n          quality\n        );\n      }\n\n      // Highlight cells\n      const fromCell = document.querySelector(\n        `.cell[data-r=\"${hint.move.from.r}\"][data-c=\"${hint.move.from.c}\"]`\n      );\n      const toCell = document.querySelector(\n        `.cell[data-r=\"${hint.move.to.r}\"][data-c=\"${hint.move.to.c}\"]`\n      );\n      if (fromCell) fromCell.classList.add('suggestion-highlight');\n      if (toCell) toCell.classList.add('suggestion-highlight');\n    });\n\n    suggestionsEl.appendChild(suggEl);\n  });\n\n  tutorPanel.classList.remove('hidden');\n}\n\nexport function updateReplayUI(game) {\n  // Update move number display\n  const moveNumEl = document.getElementById('replay-move-num');\n  if (moveNumEl) moveNumEl.textContent = game.replayPosition + 1;\n\n  // Update button states\n  const firstBtn = document.getElementById('replay-first');\n  const prevBtn = document.getElementById('replay-prev');\n  const nextBtn = document.getElementById('replay-next');\n  const lastBtn = document.getElementById('replay-last');\n\n  if (firstBtn) firstBtn.disabled = game.replayPosition === -1;\n  if (prevBtn) prevBtn.disabled = game.replayPosition === -1;\n  if (nextBtn) nextBtn.disabled = game.replayPosition === game.moveHistory.length - 1;\n  if (lastBtn) lastBtn.disabled = game.replayPosition === game.moveHistory.length - 1;\n\n  renderBoard(game);\n}\n\nexport function enterReplayMode(game) {\n  if (game.replayMode || game.moveHistory.length === 0) return;\n\n  // Save current game state\n  game.savedGameState = {\n    board: JSON.parse(JSON.stringify(game.board)),\n    turn: game.turn,\n    selectedSquare: game.selectedSquare,\n    validMoves: game.validMoves,\n    lastMoveHighlight: game.lastMoveHighlight,\n  };\n\n  game.replayMode = true;\n  game.replayPosition = game.moveHistory.length - 1;\n  if (game.stopClock) game.stopClock();\n\n  // Update UI\n  document.getElementById('replay-status').classList.remove('hidden');\n  document.getElementById('replay-exit').classList.remove('hidden');\n  const undoBtn = document.getElementById('undo-btn');\n  if (undoBtn) undoBtn.disabled = true;\n\n  updateReplayUI(game);\n}\n\n\nexport function exitReplayMode(game) {\n  if (!game.replayMode) return;\n\n  // Restore game state\n  if (game.savedGameState) {\n    game.board = game.savedGameState.board;\n    game.turn = game.savedGameState.turn;\n    game.selectedSquare = game.savedGameState.selectedSquare;\n    game.validMoves = game.savedGameState.validMoves;\n    game.lastMoveHighlight = game.savedGameState.lastMoveHighlight;\n  }\n\n  game.replayMode = false;\n  game.replayPosition = -1;\n  game.savedGameState = null;\n\n  // Update UI\n  document.getElementById('replay-status').classList.add('hidden');\n  document.getElementById('replay-exit').classList.add('hidden');\n  const undoBtn = document.getElementById('undo-btn');\n  if (undoBtn) undoBtn.disabled = game.moveHistory.length === 0 || game.phase !== PHASES.PLAY;\n\n  renderBoard(game);\n\n  // Restart clock if needed\n  if (game.clockEnabled && game.phase === PHASES.PLAY && game.startClock) {\n    game.startClock();\n  }\n}\n\n/**\n * Zeigt ein modales Dialogfenster an.\n * @param {string} title - Der Titel des Modals\n * @param {string} message - Die Nachricht\n * @param {Array<{text: string, class: string, callback: Function}>} actions - Buttons\n */\nexport function showModal(title, message, actions = []) {\n  const modal = document.getElementById('generic-modal');\n  const titleEl = document.getElementById('modal-title');\n  const messageEl = document.getElementById('modal-message');\n  const actionsEl = document.getElementById('modal-actions');\n\n  if (!modal || !titleEl || !messageEl || !actionsEl) return;\n\n  titleEl.textContent = title;\n  messageEl.textContent = message;\n  actionsEl.innerHTML = '';\n\n  actions.forEach(action => {\n    const btn = document.createElement('button');\n    btn.textContent = action.text;\n    btn.className = action.class || 'btn-secondary';\n    btn.onclick = () => {\n      if (action.callback) action.callback();\n      closeModal();\n    };\n    actionsEl.appendChild(btn);\n  });\n\n  modal.style.display = 'flex';\n}\n\nexport function closeModal() {\n  const modal = document.getElementById('generic-modal');\n  if (modal) modal.style.display = 'none';\n}\n\n\n// --- Puzzle UI Helpers ---\n\nexport function showPuzzleOverlay(puzzle) {\n  const overlay = document.getElementById('puzzle-overlay');\n  if (!overlay) return;\n\n  document.getElementById('puzzle-title').textContent = puzzle.title;\n  document.getElementById('puzzle-description').textContent = puzzle.description;\n\n  const statusEl = document.getElementById('puzzle-status');\n  statusEl.textContent = 'Wei am Zug';\n  statusEl.className = 'puzzle-status';\n\n  // Hide next button, show exit\n  document.getElementById('puzzle-next-btn').classList.add('hidden');\n  document.getElementById('puzzle-exit-btn').classList.remove('hidden');\n\n  overlay.classList.remove('hidden');\n}\n\nexport function hidePuzzleOverlay() {\n  const overlay = document.getElementById('puzzle-overlay');\n  if (overlay) overlay.classList.add('hidden');\n}\n\nexport function updatePuzzleStatus(status, message) {\n  const statusEl = document.getElementById('puzzle-status');\n  if (!statusEl) return;\n\n  statusEl.textContent = message;\n  statusEl.className = `puzzle-status ${status}`; // status: 'success', 'error', 'neutral'\n\n  if (status === 'success') {\n    document.getElementById('puzzle-next-btn').classList.remove('hidden');\n  }\n}\n/**\n * Zeigt ein generisches Modal an.\n * @param {string} title - Modal Titel\n * @param {string} message - Modal Nachricht\n * @param {Array} actions - Liste von Buttons {text, class, callback}\n */\nexport function showModal(title, message, actions = []) {\n  const modal = document.getElementById('generic-modal');\n  const titleEl = document.getElementById('modal-title');\n  const messageEl = document.getElementById('modal-message');\n  const actionsEl = document.getElementById('modal-actions');\n\n  if (!modal || !titleEl || !messageEl || !actionsEl) return;\n\n  titleEl.textContent = title;\n  messageEl.textContent = message;\n  actionsEl.innerHTML = '';\n\n  if (actions.length === 0) {\n    actions.push({ text: 'OK', class: 'btn-primary' });\n  }\n\n  actions.forEach(action => {\n    const btn = document.createElement('button');\n    btn.textContent = action.text;\n    btn.className = `btn ${action.class || 'btn-secondary'}`;\n    btn.style.padding = '8px 16px';\n    btn.style.borderRadius = '8px';\n    btn.style.cursor = 'pointer';\n    btn.style.border = 'none';\n    btn.style.fontWeight = '600';\n\n    btn.addEventListener('click', () => {\n      modal.style.display = 'none';\n      if (action.callback) action.callback();\n    });\n    actionsEl.appendChild(btn);\n  });\n\n  modal.style.display = 'flex';\n}\n\n/**\n * Zeigt eine kurze Toast-Nachricht an.\n * @param {string} message - Nachricht\n * @param {string} type - 'success', 'error', 'neutral'\n */\nexport function showToast(message, type = 'neutral') {\n  let container = document.getElementById('toast-container');\n  if (!container) {\n    container = document.createElement('div');\n    container.id = 'toast-container';\n    document.body.appendChild(container);\n  }\n\n  const toast = document.createElement('div');\n  toast.className = `toast ${type}`;\n\n  const icon = type === 'success' ? '' : type === 'error' ? '' : '';\n  toast.innerHTML = `<span>${icon}</span> <span>${message}</span>`;\n\n  container.appendChild(toast);\n\n  // Fade out and remove\n  setTimeout(() => {\n    toast.classList.add('fade-out');\n    setTimeout(() => toast.remove(), 300);\n  }, 3000);\n}\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/js/utils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/service-worker.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/aiController.deep.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'BOARD_SIZE' is defined but never used.","line":2,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":28},{"ruleId":"no-dupe-keys","severity":2,"message":"Duplicate key 'r'.","line":242,"column":25,"nodeType":"ObjectExpression","messageId":"unexpected","endLine":242,"endColumn":26}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\nimport { PHASES, BOARD_SIZE } from '../js/gameEngine.js';\n\n// Mock UI module\nconst mockUI = {\n  renderBoard: jest.fn(), showModal: jest.fn(),\n  updateAnalysisUI: jest.fn(),\n  renderEvalGraph: jest.fn(),\n};\njest.unstable_mockModule('../js/ui.js', () => mockUI);\n\n// Mock Logger\njest.unstable_mockModule('../js/logger.js', () => ({\n  logger: {\n    info: jest.fn(),\n    debug: jest.fn(),\n    error: jest.fn()\n  }\n}));\n\n// Mock Worker global\nclass MockWorker {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.onmessage = null;\n  }\n  postMessage = jest.fn();\n  terminate = jest.fn();\n}\nglobal.Worker = MockWorker;\n\n// Mock Fetch\nglobal.fetch = jest.fn(() =>\n  Promise.resolve({\n    json: () => Promise.resolve({ 'e2-e4': 'e7-e5' })\n  })\n);\n\n// Import AIController\nconst { AIController } = await import('../js/aiController.js');\n\ndescribe('AIController Deep Logic', () => {\n  let game, controller;\n\n  beforeEach(() => {\n    game = {\n      board: Array(9).fill(null).map(() => Array(9).fill(null)),\n      phase: PHASES.PLAY,\n      turn: 'black',\n      difficulty: 'medium',\n      moveHistory: [],\n      positionHistory: [],\n      blackCorridor: { rowStart: 0, colStart: 3 },\n      points: 15,\n      drawOffered: false,\n      drawOfferedBy: null,\n      mode: 'pve',\n      placeKing: jest.fn(),\n      placeShopPiece: jest.fn(() => { game.points -= 1; }), // Decrement to avoid infinite loop\n      finishSetupPhase: jest.fn(),\n      resign: jest.fn(),\n      offerDraw: jest.fn(),\n      acceptDraw: jest.fn(),\n      declineDraw: jest.fn(),\n      executeMove: jest.fn(),\n      log: jest.fn(),\n      isInsufficientMaterial: jest.fn(() => false),\n      getBoardHash: jest.fn(() => 'hash'),\n      calculateMaterialAdvantage: jest.fn(() => 0),\n      renderBoard: jest.fn(), showModal: jest.fn(),\n      findKing: jest.fn(() => ({ r: 1, c: 4 })) // Add findKing mock\n    };\n\n    controller = new AIController(game);\n\n    document.body.innerHTML = `\n            <div id=\"spinner-overlay\"></div>\n            <div id=\"ai-depth\"></div>\n            <div id=\"ai-nodes\"></div>\n            <div id=\"ai-best-move\"></div>\n            <div id=\"progress-fill\"></div>\n            <div id=\"eval-bar\"></div>\n            <div id=\"eval-score\"></div>\n            <div id=\"top-moves-content\"></div>\n        `;\n\n    jest.clearAllMocks();\n  });\n\n  describe('Setup Phase', () => {\n    test('aiSetupKing should place king randomly in corridor', () => {\n      controller.aiSetupKing();\n      expect(game.placeKing).toHaveBeenCalledWith(1, expect.any(Number), 'black');\n      expect(mockUI.renderBoard).toHaveBeenCalled();\n    });\n\n    test('aiSetupPieces should buy pieces until points are spent', () => {\n      controller.aiSetupPieces();\n      expect(game.placeShopPiece).toHaveBeenCalled();\n      expect(game.finishSetupPhase).toHaveBeenCalled();\n    });\n  });\n\n  describe('Resignation & Draw Logic', () => {\n    test('aiShouldResign should return true if score is hopeless', () => {\n      // Mock evaluatePosition to return hopeless score for black\n      const realEval = controller.evaluatePosition;\n      controller.evaluatePosition = jest.fn(() => -2000);\n\n      expect(controller.aiShouldResign()).toBe(true);\n\n      controller.evaluatePosition = realEval;\n    });\n\n    test('aiShouldResign should return true if material disadvantage is high', () => {\n      game.calculateMaterialAdvantage.mockReturnValue(20); // White +20\n      expect(controller.aiShouldResign()).toBe(true);\n    });\n\n    test('aiEvaluateDrawOffer should accept if losing', () => {\n      game.drawOffered = true;\n      game.drawOfferedBy = 'white';\n      const realEval = controller.evaluatePosition;\n      controller.evaluatePosition = jest.fn(() => -300); // AI is losing\n\n      controller.aiEvaluateDrawOffer();\n      expect(game.acceptDraw).toHaveBeenCalled();\n\n      controller.evaluatePosition = realEval;\n    });\n\n    test('aiShouldOfferDraw should return true if repetition imminent', () => {\n      game.positionHistory = ['hash', 'hash'];\n      game.getBoardHash.mockReturnValue('hash');\n\n      expect(controller.aiShouldOfferDraw()).toBe(true);\n    });\n  });\n\n  describe('AI Move & Progress', () => {\n    test('aiMove should initiate workers (multi-worker)', () => {\n      controller.aiMove();\n      expect(controller.aiWorkers).toBeDefined();\n      expect(controller.aiWorkers.length).toBeGreaterThan(0);\n      // Check that at least one worker received the getBestMove message\n      const hasGetBestMove = controller.aiWorkers.some(w =>\n        w.postMessage.mock.calls.some(call =>\n          call[0] && call[0].type === 'getBestMove'\n        )\n      );\n      expect(hasGetBestMove).toBe(true);\n    });\n\n    test('updateAIProgress should update DOM elements', () => {\n      const data = {\n        depth: 3,\n        maxDepth: 5,\n        nodes: 1000,\n        bestMove: { from: { r: 6, c: 4 }, to: { r: 4, c: 4 } }\n      };\n      controller.updateAIProgress(data);\n\n      expect(document.getElementById('ai-depth').textContent).toContain('3/5');\n      expect(document.getElementById('ai-nodes').textContent).toContain('1.000');\n      expect(document.getElementById('ai-best-move').textContent).toContain('e3-e5'); // 9x9 board: r6->e3, r4->e5\n    });\n  });\n\n  describe('Analysis Mode', () => {\n    test('analyzePosition should post analyze message to worker', () => {\n      game.analysisMode = true;\n      game.turn = 'white';\n      controller.analyzePosition();\n\n      // With multi-worker, check if any worker received analyze message\n      if (controller.aiWorkers && controller.aiWorkers.length > 0) {\n        const hasAnalyze = controller.aiWorkers.some(w =>\n          w.postMessage.mock.calls.some(call =>\n            call[0] && call[0].type === 'analyze'\n          )\n        );\n        expect(hasAnalyze).toBe(true);\n      }\n    });\n\n    test('updateAnalysisUI should update eval bar and top moves', () => {\n      const analysis = {\n        score: 50,\n        topMoves: [\n          { from: { r: 6, c: 4 }, to: { r: 4, c: 4 }, score: 50 }\n        ]\n      };\n      controller.updateAnalysisUI(analysis);\n\n      expect(document.getElementById('eval-score').textContent).toBe('0.50');\n      expect(document.getElementById('top-moves-content').innerHTML).toContain('e3-e5');\n    });\n\n    test('highlightMove should add CSS classes to cells', () => {\n      document.body.innerHTML += `\n                <div class=\"cell\" data-r=\"6\" data-c=\"4\"></div>\n                <div class=\"cell\" data-r=\"4\" data-c=\"4\"></div>\n            `;\n      const move = { from: { r: 6, c: 4 }, to: { r: 4, c: 4 } };\n      controller.highlightMove(move);\n\n      expect(document.querySelector('.cell[data-r=\"6\"][data-c=\"4\"]').classList.contains('analysis-from')).toBe(true);\n      expect(document.querySelector('.cell[data-r=\"4\"][data-c=\"4\"]').classList.contains('analysis-to')).toBe(true);\n    });\n  });\n\n  describe('Search & Evaluation Logic', () => {\n    test('evaluateMove should simulate move and return score', () => {\n      game.board[6][4] = { type: 'p', color: 'white' };\n      const move = { from: { r: 6, c: 4 }, to: { r: 5, c: 4 } };\n\n      const score = controller.evaluateMove(move);\n      expect(score).toBeDefined();\n      // Verify board was restored\n      expect(game.board[6][4]).toBeDefined();\n      expect(game.board[5][4]).toBeNull();\n    });\n\n    test('minimax should recurse and return score', () => {\n      const move = { from: { r: 6, c: 4 }, to: { r: 5, c: 4 } };\n      game.board[6][4] = { type: 'p', color: 'white' };\n      game.getAllLegalMoves = jest.fn()\n        .mockReturnValueOnce([{ from: { r: 1, c: 4 }, to: { r: 2, c: 4 } }]) // White moves\n        .mockReturnValue([]); // Terminal\n\n      const score = controller.minimax(move, 1, false, -Infinity, Infinity);\n      expect(score).toBeDefined();\n    });\n\n    test('quiescenceSearch should handle captures', () => {\n      game.board[4][4] = { type: 'p', color: 'white' };\n      game.board[3][4] = { type: 'p', color: 'black' };\n\n      // Mock getAllLegalMoves to return a capture\n      game.getAllLegalMoves = jest.fn(() => [\n        { from: { r: 3, r: 4 }, to: { r: 4, c: 4 } }\n      ]);\n\n      const score = controller.quiescenceSearch(-Infinity, Infinity, true);\n      expect(score).toBeDefined();\n    });\n\n    test('evaluatePosition should consider piece-square tables and center control', () => {\n      game.board[4][4] = { type: 'p', color: 'black' }; // Center\n      const score = controller.evaluatePosition('black');\n      expect(score).toBeGreaterThan(100); // 100 for pawn + center bonus\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/aiController.extra.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'BOARD_SIZE' is defined but never used.","line":2,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":28},{"ruleId":"no-dupe-keys","severity":2,"message":"Duplicate key 'difficulty'.","line":64,"column":7,"nodeType":"ObjectExpression","messageId":"unexpected","endLine":64,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\nimport { PHASES, BOARD_SIZE } from '../js/gameEngine.js';\n\n// Setup JSDOM body \ndocument.body.innerHTML = `\n    <div id=\"spinner-overlay\" style=\"display: none;\"></div>\n    <div id=\"ai-depth\"></div>\n    <div id=\"ai-nodes\"></div>\n    <div id=\"ai-best-move\"></div>\n    <div id=\"progress-fill\"></div>\n    <div id=\"eval-bar\"></div>\n    <div id=\"eval-score\"></div>\n    <div id=\"top-moves-content\"></div>\n    <div id=\"ai-status\"></div>\n`;\n\n// Mock Worker\nclass MockWorker {\n  constructor(url) {\n    this.url = url;\n    this.onmessage = null;\n  }\n  postMessage = jest.fn();\n  terminate = jest.fn();\n}\nglobal.Worker = jest.fn().mockImplementation((url) => new MockWorker(url));\n\n// Mock fetch\nglobal.fetch = jest.fn(() => Promise.resolve({ ok: true, json: () => Promise.resolve({ e2e4: ['e2e5'] }) }));\n\nconst { AIController } = await import('../js/aiController.js');\n\ndescribe('AIController Ultimate Precision V5', () => {\n  let game, controller;\n\n  beforeEach(() => {\n    game = {\n      board: Array(9).fill(null).map(() => Array(9).fill(null)),\n      phase: PHASES.PLAY,\n      turn: 'black',\n      difficulty: 'medium',\n      moveHistory: [],\n      positionHistory: [],\n      blackCorridor: { rowStart: 0, colStart: 3 },\n      points: 15,\n      drawOffered: false,\n      drawOfferedBy: 'white',\n      mode: 'pve',\n      placeKing: jest.fn(),\n      placeShopPiece: jest.fn(() => game.points--),\n      finishSetupPhase: jest.fn(),\n      resign: jest.fn(),\n      offerDraw: jest.fn(),\n      acceptDraw: jest.fn(),\n      declineDraw: jest.fn(),\n      executeMove: jest.fn(),\n      log: jest.fn(),\n      isInsufficientMaterial: jest.fn(() => false),\n      getBoardHash: jest.fn(() => 'hash'),\n      calculateMaterialAdvantage: jest.fn(() => 0),\n      renderBoard: jest.fn(), showModal: jest.fn(),\n      continuousAnalysis: false,\n      analysisMode: false,\n      difficulty: 'medium',\n      getAllLegalMoves: jest.fn(() => []),\n      arrowRenderer: { clearArrows: jest.fn(), drawArrow: jest.fn() },\n      halfMoveClock: 0,\n      findKing: jest.fn(() => ({ r: 1, c: 4 })) // Add findKing mock\n    };\n    controller = new AIController(game);\n    jest.clearAllMocks();\n  });\n\n  test('aiMove - should resign (Line 68)', () => {\n    controller.evaluatePosition = jest.fn().mockReturnValue(-1500); // Hopeless\n    game.calculateMaterialAdvantage.mockReturnValue(-20); // Massive disadvantage\n    controller.aiMove();\n    expect(game.resign).toHaveBeenCalledWith('black');\n  });\n\n  test('aiMove - should offer draw (Line 74)', () => {\n    game.moveHistory = new Array(25).fill({});\n    controller.evaluatePosition = jest.fn().mockReturnValue(-150); // Bad but not hopeless\n    controller.aiMove();\n    expect(game.offerDraw).toHaveBeenCalledWith('black');\n  });\n\n  test('aiMove - bestMove null branch (multi-worker)', () => {\n    controller.aiMove();\n    // With multi-worker, we have aiWorkers array\n    expect(controller.aiWorkers).toBeDefined();\n    expect(controller.aiWorkers.length).toBeGreaterThan(0);\n\n    // Simulate first worker returning null\n    const firstWorker = controller.aiWorkers[0];\n    if (firstWorker.onmessage) {\n      firstWorker.onmessage({ data: { type: 'bestMove', data: null } });\n    }\n    expect(game.log).toHaveBeenCalledWith(expect.stringContaining('KI kann nicht ziehen'));\n  });\n\n  test('updateAIProgress - data null coverage (Line 163 reset)', () => {\n    controller.updateAIProgress(null);\n    // Should not crash after fix\n  });\n\n  test('highlightMove - arrowRenderer coverage (Line 682-683)', () => {\n    const move = { from: { r: 0, c: 0 }, to: { r: 0, c: 1 }, score: 100 };\n    controller.highlightMove(move);\n    expect(game.arrowRenderer.drawArrow).toHaveBeenCalled();\n  });\n\n  test('aiSetupPieces - affordable piece logic coverage', () => {\n    game.points = 1;\n    controller.aiSetupPieces();\n    expect(game.placeShopPiece).toHaveBeenCalled();\n  });\n\n  test('evaluatePosition - center bonus coverage (Line 450-452)', () => {\n    game.board[4][4] = { type: 'n', color: 'black' };\n    const score = controller.evaluatePosition('black');\n    expect(score).toBeGreaterThan(0);\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/aiEngine.extra.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'PHASES' is defined but never used.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":16},{"ruleId":"no-unused-vars","severity":1,"message":"'BOARD_SIZE' is defined but never used.","line":1,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PHASES, BOARD_SIZE } from '../js/gameEngine.js';\nimport * as AIEngine from '../js/aiEngine.js';\n\ndescribe('AIEngine Extra Coverage', () => {\n  test('getAllLegalMoves for special pieces (Knight jumps)', () => {\n    const board = Array(9).fill(null).map(() => Array(9).fill(null));\n    // Archbishop at center\n    board[4][4] = { type: 'a', color: 'white' };\n    // Place king so moves are legal\n    board[8][0] = { type: 'k', color: 'white' };\n\n    // Place some enemies and friends at knight jump distances\n    board[2][3] = { type: 'p', color: 'black' }; // Enemy\n    board[2][5] = { type: 'p', color: 'white' }; // Friend\n\n    const moves = AIEngine.getAllLegalMoves(board, 'white');\n    const toPositions = moves.map(m => `${m.to.r},${m.to.c}`);\n\n    expect(toPositions).toContain('2,3'); // Knight jump capture\n    expect(toPositions).not.toContain('2,5'); // Knight jump blocked by friend\n    expect(toPositions).toContain('3,2'); // Empty square jump\n  });\n\n  test('pawn double jump (hasMoved: false)', () => {\n    const board = Array(9).fill(null).map(() => Array(9).fill(null));\n    board[6][0] = { type: 'p', color: 'white', hasMoved: false };\n    board[8][4] = { type: 'k', color: 'white' };\n    const moves = AIEngine.getAllLegalMoves(board, 'white');\n    const toPositions = moves.map(m => `${m.to.r},${m.to.c}`);\n    expect(toPositions).toContain('4,0'); // Double jump\n  });\n\n  test('Angel (E) moves (Queen + Knight)', () => {\n    const board = Array(9).fill(null).map(() => Array(9).fill(null));\n    board[4][4] = { type: 'e', color: 'white' };\n    board[8][4] = { type: 'k', color: 'white' };\n    const moves = AIEngine.getAllLegalMoves(board, 'white');\n    const toPositions = moves.map(m => `${m.to.r},${m.to.c}`);\n    // Diagonals (Bishop-like)\n    expect(toPositions).toContain('0,0');\n    // Orthogonals (Rook-like)\n    expect(toPositions).toContain('4,0');\n    // Knight jumps\n    expect(toPositions).toContain('6,5');\n  });\n\n  test('evaluatePosition for various pieces', () => {\n    const board = Array(9).fill(null).map(() => Array(9).fill(null));\n    board[4][4] = { type: 'q', color: 'white' };\n    board[0][0] = { type: 'r', color: 'black' };\n    const score = AIEngine.evaluatePosition(board, 'white');\n    expect(score).toBeDefined();\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/aiEngine.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'setOpeningBook' is defined but never used.","line":15,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":17},{"ruleId":"no-unused-vars","severity":1,"message":"'BOARD_SIZE' is defined but never used.","line":17,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":38},{"ruleId":"no-unused-vars","severity":1,"message":"'AI_PIECE_VALUES' is defined but never used.","line":18,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tests for AI Engine\n */\n\nimport {\n  getBestMove,\n  evaluatePosition,\n  computeZobristHash,\n  getAllLegalMoves,\n  getTTSize,\n  setTTMaxSize,\n  testStoreTT,\n  testProbeTT,\n  clearTT,\n  setOpeningBook,\n} from '../js/aiEngine.js';\nimport { createEmptyBoard, BOARD_SIZE } from '../js/gameEngine.js';\nimport { AI_PIECE_VALUES } from '../js/config.js';\n\ndescribe('AI Engine', () => {\n  let board;\n\n  beforeEach(() => {\n    board = createEmptyBoard();\n  });\n\n  describe('evaluatePosition', () => {\n    test('should return 0 for empty board', () => {\n      expect(evaluatePosition(board, 'white')).toBe(0);\n    });\n\n    test('should value material correctly', () => {\n      // Place white pawn\n      board[4][4] = { type: 'p', color: 'white' };\n      // Place black pawn\n      board[2][2] = { type: 'p', color: 'black' };\n\n      // With new evaluation, passed pawn bonuses and PSTs result in a larger score\n      const score = evaluatePosition(board, 'white');\n      expect(score).toBeGreaterThan(0);\n      expect(score).toBeLessThan(200);\n    });\n\n    test('should favor material advantage', () => {\n      board[4][4] = { type: 'q', color: 'white' }; // 900 + 10 = 910\n      board[0][0] = { type: 'r', color: 'black' }; // 500 - 5 (edge) = 495\n\n      const score = evaluatePosition(board, 'white');\n      expect(score).toBeGreaterThan(300);\n    });\n  });\n\n  describe('getAllLegalMoves', () => {\n    test('should find moves for a single piece', () => {\n      board[4][4] = { type: 'r', color: 'white' };\n      const moves = getAllLegalMoves(board, 'white');\n      // Rook at 4,4 on 9x9 board:\n      // Up: 4, Down: 4, Left: 4, Right: 4 = 16 moves\n      expect(moves.length).toBe(16);\n    });\n  });\n\n  describe('getBestMove', () => {\n    test('should find a simple capture', () => {\n      // White rook can capture black pawn\n      board[4][4] = { type: 'r', color: 'white' };\n      board[4][6] = { type: 'p', color: 'black' };\n\n      const bestMove = getBestMove(board, 'white', 1, 'medium');\n\n      expect(bestMove).toEqual({\n        from: { r: 4, c: 4 },\n        to: { r: 4, c: 6 },\n      });\n    });\n\n    test('should avoid immediate capture', () => {\n      // White queen threatened by black rook\n      board[4][4] = { type: 'q', color: 'white' };\n      board[4][0] = { type: 'r', color: 'black' };\n\n      // Black to move, should capture queen\n      const bestMove = getBestMove(board, 'black', 1, 'medium');\n\n      expect(bestMove).toEqual({\n        from: { r: 4, c: 0 },\n        to: { r: 4, c: 4 },\n      });\n    });\n  });\n\n  describe('Zobrist Hashing', () => {\n    test('should produce same hash for same position', () => {\n      board[0][0] = { type: 'r', color: 'white' };\n      const hash1 = computeZobristHash(board, 'white');\n      const hash2 = computeZobristHash(board, 'white');\n      expect(hash1).toBe(hash2);\n    });\n\n    test('should produce different hash for different position', () => {\n      board[0][0] = { type: 'r', color: 'white' };\n      const hash1 = computeZobristHash(board, 'white');\n\n      board[0][1] = { type: 'p', color: 'black' };\n      const hash2 = computeZobristHash(board, 'white');\n\n      expect(hash1).not.toBe(hash2);\n    });\n\n    test('should produce different hash for different turn', () => {\n      board[0][0] = { type: 'r', color: 'white' };\n      const hash1 = computeZobristHash(board, 'white');\n      const hash2 = computeZobristHash(board, 'black');\n\n      expect(hash1).not.toBe(hash2);\n    });\n  });\n\n  describe('Transposition Table (LRU)', () => {\n    beforeEach(() => {\n      clearTT();\n    });\n\n    test('should evict oldest entry when full', () => {\n      setTTMaxSize(3);\n\n      // Add 3 entries\n      testStoreTT(1, 1, 100, 0, null);\n      testStoreTT(2, 1, 200, 0, null);\n      testStoreTT(3, 1, 300, 0, null);\n\n      expect(getTTSize()).toBe(3);\n\n      // Add 4th entry, should evict oldest (1)\n      testStoreTT(4, 1, 400, 0, null);\n\n      expect(getTTSize()).toBe(3);\n      expect(testProbeTT(1, 1, -Infinity, Infinity)).toBeNull(); // 1 should be gone\n      expect(testProbeTT(2, 1, -Infinity, Infinity)).not.toBeNull(); // 2 should be there\n      expect(testProbeTT(4, 1, -Infinity, Infinity)).not.toBeNull(); // 4 should be there\n    });\n\n    test('should update MRU on access', () => {\n      setTTMaxSize(3);\n\n      testStoreTT(1, 1, 100, 0, null);\n      testStoreTT(2, 1, 200, 0, null);\n      testStoreTT(3, 1, 300, 0, null);\n\n      // Access 1 (making it MRU)\n      testProbeTT(1, 1, -Infinity, Infinity);\n\n      // Add 4th entry.\n      // If 1 was updated to MRU, then 2 should be the LRU now (since 1 was accessed after 2 and 3).\n      // Wait:\n      // Insert 1 -> [1]\n      // Insert 2 -> [1, 2]\n      // Insert 3 -> [1, 2, 3]\n      // Access 1 -> [2, 3, 1] (1 moved to end)\n      // Insert 4 -> [3, 1, 4] (2 evicted)\n\n      testStoreTT(4, 1, 400, 0, null);\n\n      expect(testProbeTT(2, 1, -Infinity, Infinity)).toBeNull(); // 2 should be evicted\n      expect(testProbeTT(1, 1, -Infinity, Infinity)).not.toBeNull(); // 1 should still be there\n    });\n  });\n\n  describe('Advanced AI Scenarios', () => {\n    test('should find Mate in 1', () => {\n      // Setup Mate in 1 position\n      // White King at 2,2 (covers 1,1; 1,2; 1,3)\n      // Black King at 0,2\n      // White Rook at 1,7\n      // White to move: Rook to 0,7 is mate\n\n      board[2][2] = { type: 'k', color: 'white' };\n      board[0][2] = { type: 'k', color: 'black' };\n      board[1][7] = { type: 'r', color: 'white' };\n\n      const bestMove = getBestMove(board, 'white', 2, 'expert');\n\n      expect(bestMove).toEqual({\n        from: { r: 1, c: 7 },\n        to: { r: 0, c: 7 }\n      });\n    });\n\n    test('should avoid Stalemate when winning', () => {\n      // White King at 0,0\n      // Black King at 0,2\n      // White Queen at 1,1\n      // White to move. Queen to 0,1 would be stalemate.\n      // Queen to 1,7 is safe and keeps game going.\n\n      board[0][0] = { type: 'k', color: 'white' };\n      board[0][2] = { type: 'k', color: 'black' };\n      board[1][1] = { type: 'q', color: 'white' };\n\n      const bestMove = getBestMove(board, 'white', 2, 'expert');\n\n      // Should NOT move to 0,1\n      expect(bestMove.to).not.toEqual({ r: 0, c: 1 });\n    });\n\n    test('should use Quiescence Search to see capture chains', () => {\n      // Setup a position where a capture looks good but leads to material loss\n      // White Queen at 4,4\n      // Black Pawn at 3,3 (protected by Black Rook at 3,0)\n\n      board[4][4] = { type: 'q', color: 'white' };\n      board[3][3] = { type: 'p', color: 'black' };\n      board[3][0] = { type: 'r', color: 'black' };\n\n      // If depth is 1, AI might take pawn (gain 100) and miss the rook recapture (lose 900)\n      // Quiescence search should see the recapture\n\n      const bestMove = getBestMove(board, 'white', 1, 'expert');\n\n      // Should NOT capture the pawn\n      if (bestMove) {\n        expect(bestMove.to).not.toEqual({ r: 3, c: 3 });\n      }\n    });\n  });\n\n  describe('Move Ordering and Optimization', () => {\n    test('should prioritize captures in move ordering', () => {\n      // Setup position with capture available\n      board[4][4] = { type: 'r', color: 'white' };\n      board[4][6] = { type: 'q', color: 'black' }; // High value target\n      board[4][7] = { type: 'p', color: 'black' }; // Low value target\n\n      const bestMove = getBestMove(board, 'white', 2, 'expert');\n\n      // Should prefer capturing the queen\n      expect(bestMove.to).toEqual({ r: 4, c: 6 });\n    });\n\n    test('should evaluate center control', () => {\n      const centerBoard = createEmptyBoard();\n      centerBoard[4][4] = { type: 'n', color: 'white' }; // Knight in center\n\n      const cornerBoard = createEmptyBoard();\n      cornerBoard[0][0] = { type: 'n', color: 'white' }; // Knight in corner\n\n      const centerScore = evaluatePosition(centerBoard, 'white');\n      const cornerScore = evaluatePosition(cornerBoard, 'white');\n\n      // Center position should be valued higher\n      expect(centerScore).toBeGreaterThan(cornerScore);\n    });\n\n    test('should penalize doubled pawns', () => {\n      board[4][4] = { type: 'p', color: 'white' };\n      board[5][4] = { type: 'p', color: 'white' };\n      const scoreDoubled = evaluatePosition(board, 'white');\n\n      const normalBoard = createEmptyBoard();\n      normalBoard[4][4] = { type: 'p', color: 'white' };\n      normalBoard[4][5] = { type: 'p', color: 'white' }; // Same row, different col\n      const scoreNormal = evaluatePosition(normalBoard, 'white');\n\n      expect(scoreNormal).toBeGreaterThan(scoreDoubled);\n    });\n\n    test('should evaluate special pieces correctly', () => {\n      const bArch = createEmptyBoard();\n      bArch[4][4] = { type: 'a', color: 'white' };\n      expect(evaluatePosition(bArch, 'white')).toBeGreaterThan(600);\n\n      const bChan = createEmptyBoard();\n      bChan[4][4] = { type: 'c', color: 'white' };\n      expect(evaluatePosition(bChan, 'white')).toBeGreaterThan(700);\n\n      const bAngel = createEmptyBoard();\n      bAngel[4][4] = { type: 'e', color: 'white' };\n      expect(evaluatePosition(bAngel, 'white')).toBeGreaterThan(1000);\n    });\n  });\n\n  describe('Difficulty Levels and Randomized Behavior', () => {\n    test('beginner should make random moves most of the time', () => {\n      board[4][4] = { type: 'q', color: 'white' };\n      board[4][6] = { type: 'p', color: 'black' };\n\n      const moves = [];\n      for (let i = 0; i < 5; i++) {\n        const move = getBestMove(board, 'white', 2, 'beginner');\n        moves.push(move);\n      }\n      expect(moves.length).toBeGreaterThan(0);\n    });\n\n    test('easy should prefer captures', () => {\n      board[4][4] = { type: 'r', color: 'white' };\n      board[4][6] = { type: 'q', color: 'black' };\n      const move = getBestMove(board, 'white', 2, 'easy');\n      expect(move.to).toEqual({ r: 4, c: 6 });\n    });\n\n    test('Expert should reach target depth via ID', () => {\n      board[4][4] = { type: 'q', color: 'white' };\n      const move = getBestMove(board, 'white', 3, 'expert');\n      expect(move).toBeDefined();\n    });\n  });\n\n  test('should handle positions with no legal moves', () => {\n    // Stalemate-like position: just kings\n    const emptyBoard = createEmptyBoard();\n    emptyBoard[0][0] = { type: 'k', color: 'white' };\n    emptyBoard[8][8] = { type: 'k', color: 'black' };\n\n    const moves = getAllLegalMoves(emptyBoard, 'white');\n\n    // Kings should have some moves unless completely blocked\n    expect(moves.length).toBeGreaterThan(0);\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/angelPromotion.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'UI' is defined but never used.","line":23,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { jest } from '@jest/globals';\n\n// Mock AudioContext\nglobal.window.AudioContext = jest.fn().mockImplementation(() => ({\n  createGain: jest.fn().mockReturnValue({\n    connect: jest.fn(),\n    gain: {\n      value: 0,\n      linearRampToValueAtTime: jest.fn(),\n      setValueAtTime: jest.fn(),\n      exponentialRampToValueAtTime: jest.fn()\n    }\n  }),\n  createOscillator: jest.fn().mockReturnValue({ connect: jest.fn(), start: jest.fn(), stop: jest.fn(), frequency: { setValueAtTime: jest.fn(), exponentialRampToValueAtTime: jest.fn() }, type: 'sine' }),\n  currentTime: 0,\n  destination: {},\n}));\nglobal.window.webkitAudioContext = global.window.AudioContext;\n\nimport { Game, BOARD_SIZE } from '../js/gameEngine.js';\nimport { MoveController } from '../js/moveController.js';\nimport * as UI from '../js/ui.js';\n\njest.mock('../js/ui.js', () => ({\n  renderBoard: jest.fn(), showModal: jest.fn(),\n  updateCapturedUI: jest.fn(),\n  updateMoveHistoryUI: jest.fn(),\n  updateStatus: jest.fn(),\n  showPromotionUI: jest.fn(),\n  animateMove: jest.fn().mockResolvedValue(),\n  updateStatistics: jest.fn(),\n  updateClockDisplay: jest.fn(),\n  updateClockUI: jest.fn(),\n  animateCheck: jest.fn(),\n  animateCheckmate: jest.fn(),\n  renderEvalGraph: jest.fn(),\n}));\n\njest.mock('../js/sounds.js', () => ({\n  soundManager: {\n    playMove: jest.fn(),\n    playCapture: jest.fn(),\n    playCheck: jest.fn(),\n    playGameOver: jest.fn(),\n  }\n}));\n\ndescribe('Angel Piece and Promotion', () => {\n  let game;\n  let moveController;\n\n  beforeEach(() => {\n    // Setup JSDOM elements\n    document.body.innerHTML = `\n            <div id=\"game-over-overlay\" class=\"hidden\"></div>\n            <div id=\"winner-text\"></div>\n            <div id=\"promotion-overlay\" class=\"hidden\"></div>\n            <div id=\"promotion-options\"></div>\n        `;\n\n    game = new Game();\n    moveController = new MoveController(game);\n    game.gameController = { saveGameToStatistics: jest.fn() }; // Mock\n    game.log = jest.fn(); // Mock log\n    game.arrowRenderer = { clearArrows: jest.fn() }; // Mock arrow renderer\n\n    // Setup board for testing\n    game.board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));\n  });\n\n  test('Angel should move like a Queen', () => {\n    // Place Angel at center\n    game.board[4][4] = { type: 'e', color: 'white', hasMoved: false };\n\n    // Check diagonal move\n    const moves = game.getValidMoves(4, 4, game.board[4][4]);\n    const diagonalMove = moves.find(m => m.r === 0 && m.c === 0);\n    expect(diagonalMove).toBeDefined();\n\n    // Check orthogonal move\n    const orthogonalMove = moves.find(m => m.r === 4 && m.c === 0);\n    expect(orthogonalMove).toBeDefined();\n  });\n\n  test('Angel should move like a Knight', () => {\n    // Place Angel at center\n    game.board[4][4] = { type: 'e', color: 'white', hasMoved: false };\n\n    // Check knight jump\n    const moves = game.getValidMoves(4, 4, game.board[4][4]);\n    const knightMove = moves.find(m => m.r === 6 && m.c === 5);\n    expect(knightMove).toBeDefined();\n  });\n\n  test('Angel should capture enemy pieces', () => {\n    // Place Angel\n    game.board[4][4] = { type: 'e', color: 'white', hasMoved: false };\n\n    // Place enemy pawn for diagonal capture (Queen-like)\n    game.board[2][2] = { type: 'p', color: 'black', hasMoved: false };\n\n    // Place enemy pawn for knight capture\n    game.board[6][5] = { type: 'p', color: 'black', hasMoved: false };\n\n    const moves = game.getValidMoves(4, 4, game.board[4][4]);\n\n    // Check diagonal capture\n    expect(moves.find(m => m.r === 2 && m.c === 2)).toBeDefined();\n\n    // Check knight capture\n    expect(moves.find(m => m.r === 6 && m.c === 5)).toBeDefined();\n  });\n\n  test('Angel should be blocked by friendly pieces (Queen movement)', () => {\n    game.board[4][4] = { type: 'e', color: 'white', hasMoved: false };\n    // Place friendly piece in path\n    game.board[4][2] = { type: 'p', color: 'white', hasMoved: false };\n\n    const moves = game.getValidMoves(4, 4, game.board[4][4]);\n\n    // Should not be able to move to [4][2] or beyond [4][1], [4][0]\n    expect(moves.find(m => m.r === 4 && m.c === 2)).toBeUndefined();\n    expect(moves.find(m => m.r === 4 && m.c === 1)).toBeUndefined();\n  });\n\n  test('Angel should jump over pieces (Knight movement)', () => {\n    game.board[4][4] = { type: 'e', color: 'white', hasMoved: false };\n    // Place blocking pieces around\n    game.board[4][3] = { type: 'p', color: 'white', hasMoved: false };\n    game.board[3][4] = { type: 'p', color: 'white', hasMoved: false };\n\n    const moves = game.getValidMoves(4, 4, game.board[4][4]);\n\n    // Should still be able to jump to knight square\n    expect(moves.find(m => m.r === 2 && m.c === 3)).toBeDefined();\n  });\n\n  test('Angel should deliver check', () => {\n    // White Angel\n    game.board[4][4] = { type: 'e', color: 'white', hasMoved: false };\n    // Black King\n    game.board[0][4] = { type: 'k', color: 'black', hasMoved: false };\n\n    expect(game.isInCheck('black')).toBe(true);\n  });\n\n  test('Pawn should automatically promote to Angel', async () => {\n    // Place white pawn near end\n    game.board[1][0] = { type: 'p', color: 'white', hasMoved: true };\n    // Clear path\n    game.board[0][0] = null;\n\n    // Execute move\n    const from = { r: 1, c: 0 };\n    const to = { r: 0, c: 0 };\n\n    await moveController.executeMove(from, to);\n\n    // Check if piece at to is Angel\n    const promotedPiece = game.board[0][0];\n    expect(promotedPiece).not.toBeNull();\n    expect(promotedPiece.type).toBe('e');\n    expect(promotedPiece.color).toBe('white');\n  });\n\n  test('Black pawn should promote to Angel on last rank', async () => {\n    // Place black pawn near white's end\n    game.board[7][4] = { type: 'p', color: 'black', hasMoved: true };\n    game.board[8][4] = null;\n    game.turn = 'black';\n\n    await moveController.executeMove({ r: 7, c: 4 }, { r: 8, c: 4 });\n\n    const promotedPiece = game.board[8][4];\n    expect(promotedPiece).not.toBeNull();\n    expect(promotedPiece.type).toBe('e');\n    expect(promotedPiece.color).toBe('black');\n  });\n\n  describe('Angel Edge Cases', () => {\n    test('Angel can move from corner to opposite corner (Queen-like)', () => {\n      game.board[0][0] = { type: 'e', color: 'white', hasMoved: false };\n\n      const moves = game.getValidMoves(0, 0, game.board[0][0]);\n      const diagonalCorner = moves.find(m => m.r === 8 && m.c === 8);\n\n      expect(diagonalCorner).toBeDefined();\n    });\n\n    test('Angel can jump over pieces at board edge (Knight-like)', () => {\n      game.board[0][0] = { type: 'e', color: 'white', hasMoved: false };\n      // Place blocking pieces\n      game.board[0][1] = { type: 'p', color: 'white', hasMoved: false };\n      game.board[1][0] = { type: 'p', color: 'white', hasMoved: false };\n\n      const moves = game.getValidMoves(0, 0, game.board[0][0]);\n      // Knight jump from corner\n      const knightMove = moves.find(m => m.r === 2 && m.c === 1);\n\n      expect(knightMove).toBeDefined();\n    });\n\n    test('Angel in corner has both Queen and Knight moves', () => {\n      game.board[8][8] = { type: 'e', color: 'white', hasMoved: false };\n\n      const moves = game.getValidMoves(8, 8, game.board[8][8]);\n\n      // Should have diagonal moves (Queen-like)\n      const diagonalMove = moves.find(m => m.r === 7 && m.c === 7);\n      // Should have knight moves\n      const knightMove = moves.find(m => m.r === 6 && m.c === 7);\n\n      expect(diagonalMove).toBeDefined();\n      expect(knightMove).toBeDefined();\n      expect(moves.length).toBeGreaterThan(10);\n    });\n  });\n\n  describe('Angel Check and Checkmate Scenarios', () => {\n    test('Angel can deliver checkmate with King support', () => {\n      // Setup: White Angel and King vs Black King in corner\n      game.board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));\n      game.board[0][0] = { type: 'k', color: 'black', hasMoved: true };\n      game.board[1][2] = { type: 'e', color: 'white', hasMoved: true };\n      game.board[2][1] = { type: 'k', color: 'white', hasMoved: true };\n\n      expect(game.isInCheck('black')).toBe(true);\n      expect(game.isCheckmate('black')).toBe(true);\n    });\n\n    test('Angel cannot move if it would expose own King to check', () => {\n      // Setup: White Angel blocking check from Black Queen\n      game.board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));\n      game.board[4][4] = { type: 'k', color: 'white', hasMoved: true };\n      game.board[4][5] = { type: 'e', color: 'white', hasMoved: true };\n      game.board[4][8] = { type: 'q', color: 'black', hasMoved: true };\n      game.board[0][0] = { type: 'k', color: 'black', hasMoved: true };\n\n      const moves = game.getValidMoves(4, 5, game.board[4][5]);\n\n      // Angel can only move along the line between King and Queen\n      // or capture the Queen\n      const invalidMove = moves.find(m => m.r === 2 && m.c === 4);\n      expect(invalidMove).toBeUndefined();\n    });\n\n    test('Angel can block check with Queen-like move', () => {\n      game.board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));\n      game.board[4][4] = { type: 'k', color: 'white', hasMoved: true };\n      game.board[2][2] = { type: 'e', color: 'white', hasMoved: true };\n      game.board[0][4] = { type: 'r', color: 'black', hasMoved: true };\n      game.board[8][8] = { type: 'k', color: 'black', hasMoved: true };\n\n      const moves = game.getValidMoves(2, 2, game.board[2][2]);\n      // Can block at (1, 4), (2, 4), (3, 4)\n      const blockMove = moves.find(m => m.r === 2 && m.c === 4);\n\n      expect(blockMove).toBeDefined();\n    });\n\n    test('Angel can block check with Knight-like jump', () => {\n      game.board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));\n      // Setup: King at 0,0, Rook at 0,5 checking along rank 0\n      game.board[0][0] = { type: 'k', color: 'white', hasMoved: true };\n      game.board[0][5] = { type: 'r', color: 'black', hasMoved: true };\n\n      // Angel at 2,1 can jump to 0,2 (Knight move) to block\n      game.board[2][1] = { type: 'e', color: 'white', hasMoved: true };\n\n      // Add black king to avoid invalid board state\n      game.board[8][8] = { type: 'k', color: 'black', hasMoved: true };\n\n      const moves = game.getValidMoves(2, 1, game.board[2][1]);\n\n      // Knight jump to block at (0, 2)\n      // 0,2 is on the path between 0,0 and 0,5\n      const blockMove = moves.find(m => m.r === 0 && m.c === 2);\n\n      expect(blockMove).toBeDefined();\n    });\n  });\n\n  describe('Angel vs Angel', () => {\n    test('Angel can capture enemy Angel with Queen move', () => {\n      game.board[4][4] = { type: 'e', color: 'white', hasMoved: false };\n      game.board[4][7] = { type: 'e', color: 'black', hasMoved: false };\n\n      const moves = game.getValidMoves(4, 4, game.board[4][4]);\n      const captureMove = moves.find(m => m.r === 4 && m.c === 7);\n\n      expect(captureMove).toBeDefined();\n    });\n\n    test('Angel can capture enemy Angel with Knight jump', () => {\n      game.board[4][4] = { type: 'e', color: 'white', hasMoved: false };\n      game.board[6][5] = { type: 'e', color: 'black', hasMoved: false };\n\n      const moves = game.getValidMoves(4, 4, game.board[4][4]);\n      const captureMove = moves.find(m => m.r === 6 && m.c === 5);\n\n      expect(captureMove).toBeDefined();\n    });\n\n    test('Two Angels can coexist on the board', () => {\n      game.board[2][2] = { type: 'e', color: 'white', hasMoved: true };\n      game.board[6][6] = { type: 'e', color: 'black', hasMoved: true };\n\n      const whiteMoves = game.getValidMoves(2, 2, game.board[2][2]);\n      const blackMoves = game.getValidMoves(6, 6, game.board[6][6]);\n\n      expect(whiteMoves.length).toBeGreaterThan(0);\n      expect(blackMoves.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Angel Performance and Move Generation', () => {\n    test('Angel move generation should be fast', () => {\n      game.board[4][4] = { type: 'e', color: 'white', hasMoved: false };\n\n      const startTime = performance.now();\n      const moves = game.getValidMoves(4, 4, game.board[4][4]);\n      const endTime = performance.now();\n\n      expect(endTime - startTime).toBeLessThan(10); // Should take less than 10ms\n      expect(moves.length).toBeGreaterThan(20); // Angel has many moves\n    });\n\n    test('Angel should have maximum moves in center of empty board', () => {\n      game.board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));\n      game.board[4][4] = { type: 'e', color: 'white', hasMoved: false };\n      // Add kings to avoid game-over logic\n      game.board[0][0] = { type: 'k', color: 'black', hasMoved: true };\n      game.board[8][8] = { type: 'k', color: 'white', hasMoved: true };\n\n      const moves = game.getValidMoves(4, 4, game.board[4][4]);\n\n      // Queen moves: 4 directions  8 squares each (approx) + Knight moves: 8\n      // Total should be substantial\n      expect(moves.length).toBeGreaterThan(30);\n    });\n\n    test('Multiple promotions to Angel in same game', async () => {\n      // Promote first white pawn\n      game.board[1][0] = { type: 'p', color: 'white', hasMoved: true };\n      await moveController.executeMove({ r: 1, c: 0 }, { r: 0, c: 0 });\n      expect(game.board[0][0].type).toBe('e');\n\n      // Switch to black and promote\n      game.board[7][4] = { type: 'p', color: 'black', hasMoved: true };\n      game.turn = 'black';\n      await moveController.executeMove({ r: 7, c: 4 }, { r: 8, c: 4 });\n      expect(game.board[8][4].type).toBe('e');\n\n      // Promote second white pawn\n      game.board[1][8] = { type: 'p', color: 'white', hasMoved: true };\n      game.turn = 'white';\n      await moveController.executeMove({ r: 1, c: 8 }, { r: 0, c: 8 });\n      expect(game.board[0][8].type).toBe('e');\n\n      // Count Angels on board\n      let angelCount = 0;\n      for (let r = 0; r < BOARD_SIZE; r++) {\n        for (let c = 0; c < BOARD_SIZE; c++) {\n          if (game.board[r][c]?.type === 'e') angelCount++;\n        }\n      }\n      expect(angelCount).toBe(3);\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/arrows.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'jest' is defined but never used.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\n\nconst { ArrowRenderer } = await import('../js/arrows.js');\n\ndescribe('ArrowRenderer', () => {\n  let boardElement;\n  let renderer;\n\n  beforeEach(() => {\n    // Mock DOM\n    document.body.innerHTML = `\n            <div id=\"board-container\">\n                <div id=\"board\">\n                    <div class=\"cell\" style=\"width: 64px; height: 64px;\"></div>\n                </div>\n            </div>\n        `;\n    boardElement = document.getElementById('board');\n    // Mock offsetWidth as JSDOM doesn't layout\n    Object.defineProperty(HTMLElement.prototype, 'offsetWidth', { configurable: true, value: 64 });\n\n    renderer = new ArrowRenderer(boardElement);\n  });\n\n  afterEach(() => {\n    renderer.destroy();\n  });\n\n  test('should initialize and create SVG layer', () => {\n    const svg = document.getElementById('arrow-layer');\n    expect(svg).toBeDefined();\n    expect(svg.tagName.toLowerCase()).toBe('svg');\n    expect(boardElement.parentElement.style.position).toBe('relative');\n  });\n\n  test('should create arrowhead markers in defs', () => {\n    const defs = renderer.svgLayer.querySelector('defs');\n    expect(defs).toBeDefined();\n    const markers = defs.querySelectorAll('marker');\n    expect(markers.length).toBe(3); // gold, silver, bronze\n    expect(markers[0].id).toBe('arrowhead-gold');\n  });\n\n  test('drawArrow should create a path with correct attributes', () => {\n    renderer.drawArrow(0, 0, 1, 1, 'gold');\n    const path = renderer.svgLayer.querySelector('.tutor-arrow');\n    expect(path).toBeDefined();\n    expect(path.getAttribute('stroke')).toBe('#FFD700');\n    expect(path.getAttribute('marker-end')).toBe('url(#arrowhead-gold)');\n    expect(path.getAttribute('d')).toContain('M');\n    expect(path.getAttribute('d')).toContain('L');\n  });\n\n  test('clearArrows should remove all arrow paths', () => {\n    renderer.drawArrow(0, 0, 2, 2);\n    renderer.drawArrow(1, 1, 3, 3);\n    expect(renderer.svgLayer.querySelectorAll('.tutor-arrow').length).toBe(2);\n\n    renderer.clearArrows();\n    expect(renderer.svgLayer.querySelectorAll('.tutor-arrow').length).toBe(0);\n  });\n\n  test('highlightMove should clear previous and draw new arrow', () => {\n    renderer.highlightMove(0, 0, 1, 1, 'silver');\n    expect(renderer.lastArrow).toEqual({ fromR: 0, fromC: 0, toR: 1, toC: 1, quality: 'silver' });\n\n    renderer.highlightMove(2, 2, 3, 3, 'gold');\n    const arrows = renderer.svgLayer.querySelectorAll('.tutor-arrow');\n    expect(arrows.length).toBe(1);\n    expect(arrows[0].getAttribute('stroke')).toBe('#FFD700');\n  });\n\n  test('redraw should refresh the current arrow', () => {\n    renderer.highlightMove(0, 0, 1, 1, 'bronze');\n    const initialPath = renderer.svgLayer.querySelector('.tutor-arrow');\n\n    renderer.redraw();\n    const newPath = renderer.svgLayer.querySelector('.tutor-arrow');\n    expect(newPath).not.toBe(initialPath);\n    expect(newPath.getAttribute('stroke')).toBe('#CD7F32');\n  });\n\n  test('destroy should remove the SVG layer', () => {\n    renderer.destroy();\n    expect(document.getElementById('arrow-layer')).toBeNull();\n  });\n\n  test('updateCellSize should handle missing cells', () => {\n    document.body.innerHTML = '<div id=\"board\"></div>';\n    renderer.boardElement = document.getElementById('board');\n    renderer.updateCellSize();\n    expect(renderer.cellSize).toBe(64); // Fallback\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/battleAnimations.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/battleChess3D.boost.test.js","messages":[{"ruleId":"no-dupe-keys","severity":2,"message":"Duplicate key 'Vector2'.","line":71,"column":3,"nodeType":"ObjectExpression","messageId":"unexpected","endLine":71,"endColumn":10}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\n\n// Comprehensive Three.js Mock\nconst mockThree = {\n  Scene: jest.fn().mockImplementation(() => ({\n    add: jest.fn(),\n    remove: jest.fn(),\n    traverse: jest.fn((cb) => cb({ geometry: { dispose: jest.fn() }, material: { dispose: jest.fn() } })),\n    background: null,\n    children: []\n  })),\n  PerspectiveCamera: jest.fn().mockImplementation(() => ({\n    position: { set: jest.fn() },\n    lookAt: jest.fn(),\n    aspect: 1,\n    updateProjectionMatrix: jest.fn()\n  })),\n  WebGLRenderer: jest.fn().mockImplementation(() => ({\n    setSize: jest.fn(),\n    setPixelRatio: jest.fn(),\n    render: jest.fn(),\n    dispose: jest.fn(),\n    domElement: document.createElement('canvas'),\n    shadowMap: { enabled: false, type: null }\n  })),\n  Group: jest.fn().mockImplementation(() => ({\n    add: jest.fn(function (obj) { this.children.push(obj); }),\n    remove: jest.fn(function (obj) {\n      const index = this.children.indexOf(obj);\n      if (index > -1) this.children.splice(index, 1);\n    }),\n    position: { set: jest.fn() },\n    rotation: { x: 0, y: 0, z: 0, set: jest.fn() },\n    children: [],\n    userData: {}\n  })),\n  Raycaster: jest.fn().mockImplementation(() => ({\n    setFromCamera: jest.fn(),\n    intersectObjects: jest.fn((objs) => {\n      // Simulate intersection with a piece/square if objs contains something\n      if (objs.length > 0) {\n        return [{ object: { userData: { row: 4, col: 4, type: 'square' } } }];\n      }\n      return [];\n    })\n  })),\n  Vector2: jest.fn().mockImplementation(() => ({ x: 0, y: 0 })),\n  Vector3: jest.fn().mockImplementation(() => ({ x: 0, y: 0, z: 0 })),\n  BoxGeometry: jest.fn(),\n  SphereGeometry: jest.fn(),\n  RingGeometry: jest.fn(),\n  MeshStandardMaterial: jest.fn(),\n  MeshBasicMaterial: jest.fn(),\n  AmbientLight: jest.fn(),\n  DirectionalLight: jest.fn().mockImplementation(() => ({\n    position: { set: jest.fn() },\n    shadow: { camera: {}, mapSize: {} }\n  })),\n  Color: jest.fn(),\n  Mesh: jest.fn().mockImplementation(() => ({\n    position: { set: jest.fn() },\n    rotation: { x: 0, y: 0, z: 0, set: jest.fn() },\n    userData: {},\n    material: { color: { setHex: jest.fn() } },\n    add: jest.fn()\n  })),\n  HemisphereLight: jest.fn().mockImplementation(() => ({\n    position: { set: jest.fn() }\n  })),\n  LatheGeometry: jest.fn(),\n  Vector2: jest.fn().mockImplementation((x, y) => ({ x, y })),\n  DoubleSide: 2,\n  PCFSoftShadowMap: 1\n};\n\njest.unstable_mockModule('three', () => mockThree);\njest.unstable_mockModule('three/examples/jsm/controls/OrbitControls.js', () => ({\n  OrbitControls: jest.fn().mockImplementation(() => ({\n    update: jest.fn(),\n    dispose: jest.fn(),\n    target: { set: jest.fn() }\n  }))\n}));\n\njest.unstable_mockModule('../js/pieces3D.js', () => ({\n  createPiece3D: jest.fn(() => ({\n    position: { set: jest.fn() },\n    userData: {}\n  })),\n  PIECE_COLORS: { white: 0xffffff, black: 0x000000 }\n}));\n\njest.unstable_mockModule('../js/battleAnimations.js', () => ({\n  BattleAnimator: jest.fn().mockImplementation(() => ({\n    playBattle: jest.fn(() => Promise.resolve())\n  }))\n}));\n\nconst { BattleChess3D } = await import('../js/battleChess3D.js');\n\ndescribe('BattleChess3D Class', () => {\n  let container;\n  let engine;\n\n  beforeEach(() => {\n    container = document.createElement('div');\n    // Mock clientWidth/Height for init\n    Object.defineProperty(container, 'clientWidth', { value: 800, configurable: true });\n    Object.defineProperty(container, 'clientHeight', { value: 600, configurable: true });\n\n    engine = new BattleChess3D(container);\n    jest.clearAllMocks();\n  });\n\n  test('should initialize correctly', async () => {\n    const result = await engine.init();\n    expect(result).toBe(true);\n    expect(engine.scene).toBeDefined();\n    expect(engine.renderer).toBeDefined();\n  });\n\n  test('should handle init failure with zero dimensions', async () => {\n    Object.defineProperty(container, 'clientWidth', { value: 0 });\n    const result = await engine.init();\n    expect(result).toBe(false);\n  });\n\n  test('should boardToWorld correctly', () => {\n    const pos = engine.boardToWorld(0, 0);\n    expect(pos).toEqual({ x: -4, z: -4 });\n  });\n\n  test('should updateFromGameState', async () => {\n    await engine.init();\n    const game = {\n      board: Array(9).fill(null).map(() => Array(9).fill(null))\n    };\n    game.board[0][0] = { type: 'r', color: 'white' };\n\n    engine.updateFromGameState(game);\n    expect(Object.keys(engine.pieces).length).toBe(1);\n  });\n\n  test('should highlightMoves', async () => {\n    await engine.init();\n    engine.highlights = []; // Mock highlights array if not initialized\n    const moves = [{ r: 4, c: 4 }, { r: 5, c: 5 }];\n    engine.highlightMoves(moves);\n    expect(engine.highlights.length).toBe(2);\n  });\n\n  test('should toggle enabled state', () => {\n    engine.toggle(true);\n    expect(engine.enabled).toBe(true);\n    engine.toggle(false);\n    expect(engine.enabled).toBe(false);\n  });\n\n  test('should dispose correctly', async () => {\n    await engine.init();\n    engine.dispose();\n    expect(engine.enabled).toBe(false);\n  });\n\n  test('should setTheme', async () => {\n    await engine.init();\n    engine.boardGroup = { children: [{ userData: { type: 'square', isLight: true }, material: { color: { setHex: jest.fn() } } }] };\n    engine.setTheme('blue');\n    expect(engine.currentTheme).toBe('blue');\n  });\n\n  test('should setSkin', async () => {\n    await engine.init();\n    engine.pieces = { '0,0': { userData: { type: 'p', color: 'white', row: 0, col: 0 } } };\n    engine.setSkin('neon');\n    expect(engine.currentSkin).toBe('neon');\n  });\n\n  test('should animateMove', async () => {\n    await engine.init();\n    const piece = { position: { set: jest.fn(), x: 0, y: 0, z: 0 }, userData: {} };\n    engine.pieces['0,0'] = piece;\n\n    const animationPromise = engine.animateMove(0, 0, 1, 1);\n\n    // Mock requestAnimationFrame to call the callback immediately\n    const rafSpy = jest.spyOn(window, 'requestAnimationFrame').mockImplementation(cb => {\n      setTimeout(cb, 0);\n      return 1;\n    });\n\n    // Jump time to finish animation\n    const realDate = Date.now;\n    let currentTime = Date.now();\n    global.Date.now = jest.fn(() => currentTime);\n    currentTime += 600;\n\n    await animationPromise;\n    expect(engine.animating).toBe(false);\n    rafSpy.mockRestore();\n    global.Date.now = realDate;\n  });\n\n  test('should handle onClick', async () => {\n    await engine.init();\n    const mockEvent = { clientX: 100, clientY: 100 };\n    const dispatchSpy = jest.spyOn(window, 'dispatchEvent');\n\n    engine.onClick(mockEvent);\n\n    expect(dispatchSpy).toHaveBeenCalled();\n    const event = dispatchSpy.mock.calls[0][0];\n    expect(event.type).toBe('board3dclick');\n    expect(event.detail.row).toBe(4);\n  });\n\n  test('should handle onWindowResize', async () => {\n    await engine.init();\n    Object.defineProperty(container, 'clientWidth', { value: 1024, configurable: true });\n    Object.defineProperty(container, 'clientHeight', { value: 768, configurable: true });\n\n    engine.onWindowResize();\n\n    expect(engine.camera.aspect).toBe(1024 / 768);\n    expect(engine.renderer.setSize).toHaveBeenCalledWith(1024, 768);\n  });\n\n  test('should playBattleSequence', async () => {\n    await engine.init();\n    const attacker = { type: 'q', color: 'white' };\n    const defender = { type: 'p', color: 'black' };\n    const attackerPos = { r: 6, c: 4 };\n    const defenderPos = { r: 5, c: 4 };\n\n    await engine.playBattleSequence(attacker, defender, attackerPos, defenderPos);\n\n    expect(engine.battleAnimator.playBattle).toHaveBeenCalled();\n    expect(engine.animating).toBe(false);\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/battleChess3D.coords.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'THREE' is defined but never used.","line":2,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":18},{"ruleId":"no-unused-vars","severity":1,"message":"'defenderPos' is assigned a value but never used.","line":127,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":127,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\nimport * as THREE from 'three';\nimport { BattleChess3D } from '../js/battleChess3D.js';\n\n// Mock THREE\njest.mock('three', () => {\n  return {\n    Scene: jest.fn(() => ({\n      add: jest.fn(),\n      remove: jest.fn(),\n      background: null,\n      traverse: jest.fn(),\n    })),\n    PerspectiveCamera: jest.fn(() => ({\n      position: { set: jest.fn(), clone: jest.fn() },\n      lookAt: jest.fn(),\n      aspect: 1,\n      updateProjectionMatrix: jest.fn(),\n    })),\n    WebGLRenderer: jest.fn(() => ({\n      setSize: jest.fn(),\n      setPixelRatio: jest.fn(),\n      render: jest.fn(),\n      dispose: jest.fn(),\n      domElement: {\n        addEventListener: jest.fn(),\n        removeEventListener: jest.fn(),\n        getBoundingClientRect: jest.fn(() => ({ left: 0, top: 0, width: 100, height: 100 })),\n      },\n      shadowMap: { enabled: false, type: null },\n    })),\n    AmbientLight: jest.fn(),\n    DirectionalLight: jest.fn(() => ({\n      position: { set: jest.fn() },\n      shadow: {\n        camera: {},\n        mapSize: {},\n      },\n    })),\n    Group: jest.fn(() => ({\n      add: jest.fn(),\n      children: [],\n    })),\n    BoxGeometry: jest.fn(),\n    MeshStandardMaterial: jest.fn(),\n    Mesh: jest.fn(() => ({\n      position: { set: jest.fn() },\n      rotation: { x: 0 },\n      userData: {},\n    })),\n    Vector2: jest.fn(),\n    Vector3: jest.fn((x, y, z) => ({ x, y, z })),\n    Raycaster: jest.fn(),\n    Color: jest.fn(),\n    SphereGeometry: jest.fn(),\n    MeshBasicMaterial: jest.fn(),\n    RingGeometry: jest.fn(),\n    PCFSoftShadowMap: 'PCFSoftShadowMap',\n    DoubleSide: 'DoubleSide',\n  };\n});\n\n// Mock OrbitControls\njest.mock('three/examples/jsm/controls/OrbitControls.js', () => ({\n  OrbitControls: jest.fn(() => ({\n    enableDamping: false,\n    target: { set: jest.fn() },\n    update: jest.fn(),\n    dispose: jest.fn(),\n  })),\n}));\n\n// Mock pieces3D\njest.mock('../js/pieces3D.js', () => ({\n  createPiece3D: jest.fn(() => ({\n    position: { set: jest.fn() },\n    userData: {},\n  })),\n  PIECE_COLORS: {},\n}));\n\n// Mock battleAnimations\njest.mock('../js/battleAnimations.js', () => ({\n  BattleAnimator: jest.fn(() => ({\n    playBattle: jest.fn().mockResolvedValue(),\n  })),\n}));\n\ndescribe('BattleChess3D Debug Tests', () => {\n  let battleChess;\n  let container;\n\n  beforeEach(() => {\n    container = document.createElement('div');\n    container.style.width = '800px';\n    container.style.height = '600px';\n    document.body.appendChild(container);\n\n    battleChess = new BattleChess3D(container);\n    // Manually init minimal parts to avoid full THREE init if possible, \n    // but init() is async and complex.\n    // We can just mock the battleAnimator property directly if we don't call init.\n    battleChess.battleAnimator = {\n      playBattle: jest.fn().mockResolvedValue(),\n    };\n    battleChess.scene = {}; // Mock scene\n  });\n\n  afterEach(() => {\n    document.body.removeChild(container);\n    jest.clearAllMocks();\n  });\n\n  test('playBattleSequence should convert board coords to world coords', async () => {\n    const attacker = { type: 'p', color: 'white' };\n    const defender = { type: 'p', color: 'black' };\n\n    // Inputs from moveController are {r, c} objects\n    const from = { r: 6, c: 4 };\n    const to = { r: 5, c: 4 };\n\n    await battleChess.playBattleSequence(attacker, defender, from, to);\n\n    // Check what playBattle was called with\n    const callArgs = battleChess.battleAnimator.playBattle.mock.calls[0];\n    const attackerPos = callArgs[2];\n    const defenderPos = callArgs[3];\n\n    // Should have x and z properties, NOT r and c\n    expect(attackerPos).toHaveProperty('x');\n    expect(attackerPos).toHaveProperty('z');\n    expect(attackerPos).not.toHaveProperty('r');\n\n    // Verify correct conversion (center is 0,0 at 4,4)\n    // 6,4 -> row 6 is z=(6-4)=2, col 4 is x=(4-4)=0\n    expect(attackerPos.x).toBe(0);\n    expect(attackerPos.z).toBe(2);\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/battleChess3D.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'mockScene' is assigned a value but never used.","line":9,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":16},{"ruleId":"no-unused-vars","severity":1,"message":"'mockCamera' is assigned a value but never used.","line":19,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":17},{"ruleId":"no-unused-vars","severity":1,"message":"'mockRenderer' is assigned a value but never used.","line":26,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":19},{"ruleId":"no-unused-vars","severity":1,"message":"'mockGroup' is assigned a value but never used.","line":38,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":38,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tests for 3D Battle Chess Mode\n * @jest-environment jsdom\n */\n\nimport { jest } from '@jest/globals';\n\n// We need to create mock modules before importing the module under test\nconst mockScene = {\n  background: null,\n  fog: null,\n  add: jest.fn(),\n  remove: jest.fn(),\n  traverse: jest.fn((callback) => {\n    callback({ isMesh: true, geometry: { dispose: jest.fn() }, material: { dispose: jest.fn() } });\n  }),\n};\n\nconst mockCamera = {\n  aspect: 1,\n  updateProjectionMatrix: jest.fn(),\n  position: { set: jest.fn() },\n  lookAt: jest.fn(),\n};\n\nconst mockRenderer = {\n  setSize: jest.fn(),\n  setPixelRatio: jest.fn(),\n  render: jest.fn(),\n  dispose: jest.fn(),\n  domElement: document.createElement('canvas'),\n  shadowMap: {\n    enabled: false,\n    type: null,\n  },\n};\n\nconst mockGroup = jest.fn().mockImplementation(() => ({\n  position: { set: jest.fn(), x: 0, y: 0, z: 0 },\n  rotation: { x: 0, y: 0, z: 0 },\n  userData: {},\n  add: jest.fn(),\n  traverse: jest.fn(),\n}));\n\n// Simple test without mocking complex Three.js for now\ndescribe('BattleChess3D - Basic Tests', () => {\n  let container;\n\n  beforeEach(() => {\n    container = document.createElement('div');\n    container.id = 'battle-chess-3d-container';\n    container.style.width = '800px';\n    container.style.height = '800px';\n    document.body.appendChild(container);\n\n    // Mock window.battleChess3D\n    global.window = global.window || {};\n  });\n\n  afterEach(() => {\n    if (container.parentNode) {\n      document.body.removeChild(container);\n    }\n    jest.clearAllMocks();\n  });\n\n  describe('Container Setup', () => {\n    test('should have correct container element', () => {\n      expect(container).toBeDefined();\n      expect(container.id).toBe('battle-chess-3d-container');\n    });\n\n    test('should have correct dimensions', () => {\n      expect(container.style.width).toBe('800px');\n      expect(container.style.height).toBe('800px');\n    });\n  });\n\n  describe('Board Coordinate Conversion', () => {\n    test('should convert board coordinates to 3D world position', () => {\n      // This is the logic from battleChess3D.boardToWorld\n      const boardToWorld = (row, col) => {\n        const squareSize = 1.0;\n        const x = (col - 4) * squareSize;\n        const z = (row - 4) * squareSize;\n        return { x, z };\n      };\n\n      // Test corner positions\n      expect(boardToWorld(0, 0)).toEqual({ x: -4, z: -4 });\n      expect(boardToWorld(0, 8)).toEqual({ x: 4, z: -4 });\n      expect(boardToWorld(8, 0)).toEqual({ x: -4, z: 4 });\n      expect(boardToWorld(8, 8)).toEqual({ x: 4, z: 4 });\n\n      // Test center position\n      expect(boardToWorld(4, 4)).toEqual({ x: 0, z: 0 });\n    });\n  });\n\n  describe('3D Mode Integration', () => {\n    test('should have toggle button in DOM', () => {\n      const toggleBtn = document.createElement('button');\n      toggleBtn.id = 'toggle-3d-btn';\n      document.body.appendChild(toggleBtn);\n\n      const btn = document.getElementById('toggle-3d-btn');\n      expect(btn).toBeDefined();\n      expect(btn.tagName).toBe('BUTTON');\n\n      document.body.removeChild(toggleBtn);\n    });\n\n    test('should have 3D container in correct position', () => {\n      const container3d = document.createElement('div');\n      container3d.id = 'battle-chess-3d-container';\n      container3d.style.position = 'absolute';\n      container3d.style.top = '0';\n      container3d.style.left = '0';\n      container3d.style.width = '100%';\n      container3d.style.height = '100%';\n      container3d.style.zIndex = '5';\n\n      expect(container3d.style.position).toBe('absolute');\n      expect(container3d.style.zIndex).toBe('5');\n    });\n  });\n\n  describe('Game State Synchronization Logic', () => {\n    test('should create piece map key correctly', () => {\n      const createKey = (row, col) => `${row},${col}`;\n\n      expect(createKey(0, 0)).toBe('0,0');\n      expect(createKey(8, 8)).toBe('8,8');\n      expect(createKey(3, 7)).toBe('3,7');\n    });\n\n    test('should update board state from game', () => {\n      const mockBoard = Array(9).fill(null).map(() => Array(9).fill(null));\n      mockBoard[6][0] = { type: 'r', color: 'white' };\n      mockBoard[6][8] = { type: 'r', color: 'white' };\n      mockBoard[7][4] = { type: 'k', color: 'white' };\n\n      const pieces = new Map();\n\n      // Simulate updateFromGameState logic\n      for (let row = 0; row < 9; row++) {\n        for (let col = 0; col < 9; col++) {\n          const piece = mockBoard[row][col];\n          if (piece) {\n            pieces.set(`${row},${col}`, piece);\n          }\n        }\n      }\n\n      expect(pieces.size).toBe(3);\n      expect(pieces.has('6,0')).toBe(true);\n      expect(pieces.has('6,8')).toBe(true);\n      expect(pieces.has('7,4')).toBe(true);\n    });\n  });\n\n  describe('Move Animation Logic', () => {\n    test('should update piece position after move', () => {\n      const pieces = new Map();\n      pieces.set('6,4', { type: 'p', color: 'white', position: { x: 0, y: 0, z: 2 } });\n\n      // Simulate move\n      const fromKey = '6,4';\n      const toKey = '5,4';\n      const piece = pieces.get(fromKey);\n\n      pieces.delete(fromKey);\n      pieces.set(toKey, piece);\n\n      expect(pieces.has('6,4')).toBe(false);\n      expect(pieces.has('5,4')).toBe(true);\n    });\n\n    test('should handle captured piece', () => {\n      const pieces = new Map();\n      pieces.set('6,4', { type: 'p', color: 'white' });\n      pieces.set('5,4', { type: 'p', color: 'black' });\n\n      // Simulate capture move\n      const capturedPiece = pieces.get('5,4');\n      expect(capturedPiece.color).toBe('black');\n\n      pieces.delete('5,4'); // Remove captured\n      const movingPiece = pieces.get('6,4');\n      pieces.delete('6,4');\n      pieces.set('5,4', movingPiece);\n\n      expect(pieces.size).toBe(1);\n      expect(pieces.get('5,4').color).toBe('white');\n    });\n  });\n\n  describe('Toggle State Management', () => {\n    test('should track enabled state', () => {\n      let enabled = false;\n\n      expect(enabled).toBe(false);\n\n      enabled = true;\n      expect(enabled).toBe(true);\n\n      enabled = false;\n      expect(enabled).toBe(false);\n    });\n\n    test('should update container display on toggle', () => {\n      container.style.display = 'none';\n      container.style.opacity = '0';\n\n      // Toggle on\n      container.style.display = 'block';\n      container.style.opacity = '1';\n      container.classList.add('active');\n\n      expect(container.style.display).toBe('block');\n      expect(container.classList.contains('active')).toBe(true);\n\n      // Toggle off\n      container.style.display = 'none';\n      container.style.opacity = '0';\n      container.classList.remove('active');\n\n      expect(container.style.display).toBe('none');\n      expect(container.classList.contains('active')).toBe(false);\n    });\n  });\n\n  describe('Battle Animation Trigger', () => {\n    test('should determine if move is a capture', () => {\n      const isCaptureMove = (targetPiece, specialMove) => {\n        return targetPiece || (specialMove && specialMove.type === 'enPassant');\n      };\n\n      expect(isCaptureMove({ type: 'n', color: 'black' }, null)).toBeTruthy();\n      expect(isCaptureMove(null, { type: 'enPassant' })).toBeTruthy();\n      expect(isCaptureMove(null, null)).toBeFalsy();\n      expect(isCaptureMove(null, { type: 'castling' })).toBeFalsy();\n    });\n  });\n\n  describe('Highlight Management', () => {\n    test('should track highlight markers', () => {\n      const highlights = [];\n\n      // Add highlights\n      highlights.push({ row: 5, col: 4 });\n      highlights.push({ row: 4, col: 4 });\n      highlights.push({ row: 5, col: 3 });\n\n      expect(highlights.length).toBe(3);\n\n      // Clear highlights\n      highlights.length = 0;\n      expect(highlights.length).toBe(0);\n    });\n  });\n\n  describe('Window Resize Handling', () => {\n    test('should calculate new aspect ratio on resize', () => {\n      const calculateAspect = (width, height) => width / height;\n\n      expect(calculateAspect(800, 800)).toBe(1);\n      expect(calculateAspect(1600, 800)).toBe(2);\n      expect(calculateAspect(800, 1600)).toBe(0.5);\n    });\n  });\n\n  describe('Cleanup Logic', () => {\n    test('should clear pieces map on cleanup', () => {\n      const pieces = new Map();\n      pieces.set('1,1', { type: 'p' });\n      pieces.set('2,2', { type: 'n' });\n\n      expect(pieces.size).toBe(2);\n\n      // Clear all\n      pieces.clear();\n      expect(pieces.size).toBe(0);\n    });\n\n    test('should remove canvas on dispose', () => {\n      const canvas = document.createElement('canvas');\n      container.appendChild(canvas);\n\n      expect(container.querySelector('canvas')).toBeDefined();\n\n      // Simulate dispose\n      const canvasElement = container.querySelector('canvas');\n      if (canvasElement) {\n        container.removeChild(canvasElement);\n      }\n\n      expect(container.querySelector('canvas')).toBeNull();\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/chess-pieces.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'jest' is defined but never used.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":14},{"ruleId":"no-unused-vars","severity":1,"message":"'PIECE_SVGS' is assigned a value but never used.","line":5,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\n\n// Import chess-pieces\nconst chessPieces = await import('../js/chess-pieces.js');\nconst { PIECE_SETS, PIECE_SVGS, setPieceSkin } = chessPieces;\n\ndescribe('Chess Pieces', () => {\n  describe('PIECE_SETS', () => {\n    test('should contain all required skins', () => {\n      expect(PIECE_SETS).toHaveProperty('classic');\n      expect(PIECE_SETS).toHaveProperty('modern');\n      expect(PIECE_SETS).toHaveProperty('pixel');\n      expect(PIECE_SETS).toHaveProperty('infernale');\n      expect(PIECE_SETS).toHaveProperty('wood');\n      expect(PIECE_SETS).toHaveProperty('neon');\n      expect(PIECE_SETS).toHaveProperty('minimalist');\n    });\n\n    test('each skin should have all piece types', () => {\n      const requiredPieces = ['k', 'q', 'r', 'b', 'n', 'p', 'a', 'c', 'e'];\n\n      Object.keys(PIECE_SETS).forEach(skinName => {\n        const skin = PIECE_SETS[skinName];\n        requiredPieces.forEach(pieceType => {\n          expect(skin.white).toHaveProperty(pieceType);\n          expect(skin.black).toHaveProperty(pieceType);\n        });\n      });\n    });\n\n    test('each piece should be a non-empty string', () => {\n      Object.values(PIECE_SETS).forEach(skin => {\n        Object.values(skin.white).forEach(svg => {\n          expect(typeof svg).toBe('string');\n          expect(svg.length).toBeGreaterThan(0);\n        });\n        Object.values(skin.black).forEach(svg => {\n          expect(typeof svg).toBe('string');\n          expect(svg.length).toBeGreaterThan(0);\n        });\n      });\n    });\n  });\n\n  describe('setPieceSkin', () => {\n    beforeEach(() => {\n      // Reset to default skin\n      setPieceSkin('classic');\n    });\n\n    test('should switch to modern skin', () => {\n      setPieceSkin('modern');\n      expect(window.PIECE_SVGS.white.k).toBe(PIECE_SETS.modern.white.k);\n      expect(window.PIECE_SVGS.black.q).toBe(PIECE_SETS.modern.black.q);\n    });\n\n    test('should switch to pixel skin', () => {\n      setPieceSkin('pixel');\n      expect(window.PIECE_SVGS.white.r).toBe(PIECE_SETS.pixel.white.r);\n      expect(window.PIECE_SVGS.black.n).toBe(PIECE_SETS.pixel.black.n);\n    });\n\n    test('should switch to infernale skin', () => {\n      setPieceSkin('infernale');\n      expect(window.PIECE_SVGS.white.b).toBe(PIECE_SETS.infernale.white.b);\n      expect(window.PIECE_SVGS.black.p).toBe(PIECE_SETS.infernale.black.p);\n    });\n\n    test('should switch to wood skin', () => {\n      setPieceSkin('wood');\n      expect(window.PIECE_SVGS.white.a).toBe(PIECE_SETS.wood.white.a);\n      expect(window.PIECE_SVGS.black.c).toBe(PIECE_SETS.wood.black.c);\n    });\n\n    test('should switch to neon skin', () => {\n      setPieceSkin('neon');\n      expect(window.PIECE_SVGS.white.e).toBe(PIECE_SETS.neon.white.e);\n      expect(window.PIECE_SVGS.black.k).toBe(PIECE_SETS.neon.black.k);\n    });\n\n    test('should switch to minimalist skin', () => {\n      setPieceSkin('minimalist');\n      expect(window.PIECE_SVGS.white.q).toBe(PIECE_SETS.minimalist.white.q);\n      expect(window.PIECE_SVGS.black.r).toBe(PIECE_SETS.minimalist.black.r);\n    });\n\n    test('should handle switching between skins multiple times', () => {\n      setPieceSkin('modern');\n      expect(window.PIECE_SVGS.white.k).toBe(PIECE_SETS.modern.white.k);\n\n      setPieceSkin('pixel');\n      expect(window.PIECE_SVGS.white.k).toBe(PIECE_SETS.pixel.white.k);\n\n      setPieceSkin('classic');\n      expect(window.PIECE_SVGS.white.k).toBe(PIECE_SETS.classic.white.k);\n    });\n\n    test('should apply skin to all piece types', () => {\n      setPieceSkin('infernale');\n\n      const pieceTypes = ['k', 'q', 'r', 'b', 'n', 'p', 'a', 'c', 'e'];\n      pieceTypes.forEach(type => {\n        expect(window.PIECE_SVGS.white[type]).toBe(PIECE_SETS.infernale.white[type]);\n        expect(window.PIECE_SVGS.black[type]).toBe(PIECE_SETS.infernale.black[type]);\n      });\n    });\n  });\n\n  describe('PIECE_SVGS global', () => {\n    test('should be accessible via window.PIECE_SVGS', () => {\n      expect(window.PIECE_SVGS).toBeDefined();\n      expect(window.PIECE_SVGS.white).toBeDefined();\n      expect(window.PIECE_SVGS.black).toBeDefined();\n    });\n\n    test('should have default classic skin on initialization', () => {\n      // Reset and verify\n      setPieceSkin('classic');\n      expect(window.PIECE_SVGS.white.k).toBe(PIECE_SETS.classic.white.k);\n    });\n  });\n\n  describe('getAvailableSkins', () => {\n    test('should return all available skins', () => {\n      const skins = chessPieces.getAvailableSkins();\n\n      expect(skins).toHaveLength(7);\n      expect(skins).toEqual([\n        { id: 'classic', name: 'Klassisch' },\n        { id: 'modern', name: 'Modern' },\n        { id: 'pixel', name: 'Pixel' },\n        { id: 'infernale', name: 'Infernale' },\n        { id: 'wood', name: 'Holz' },\n        { id: 'neon', name: 'Neon' },\n        { id: 'minimalist', name: 'Minimalistisch' },\n      ]);\n    });\n  });\n\n  describe('setPieceSkin with invalid skin', () => {\n    test('should return false for invalid skin name', () => {\n      const result = setPieceSkin('invalid-skin');\n      expect(result).toBe(false);\n    });\n\n    test('should not change skin when given invalid name', () => {\n      setPieceSkin('pixel');\n      const beforeSkin = window.PIECE_SVGS.white.k;\n\n      setPieceSkin('nonexistent');\n\n      expect(window.PIECE_SVGS.white.k).toBe(beforeSkin);\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/controller.logic.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'BOARD_SIZE' is defined but never used.","line":2,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\nimport { PHASES, BOARD_SIZE } from '../js/config.js';\n\n// Setup JSDOM body\ndocument.body.innerHTML = `\n    <div id=\"board-wrapper\"><div id=\"board\"></div></div>\n    <div id=\"status-display\"></div>\n    <div id=\"points-display\"></div>\n    <div id=\"selected-piece-display\"></div>\n    <div id=\"clock-white\">05:00</div>\n    <div id=\"clock-black\">05:00</div>\n    <div id=\"chess-clock\" class=\"hidden\"></div>\n    <div id=\"game-over-overlay\" class=\"hidden\"><div id=\"winner-text\"></div></div>\n    <div id=\"move-history\"></div>\n    <div id=\"captured-white\"></div>\n    <div id=\"captured-black\"></div>\n    <div id=\"ai-toggle\"></div>\n    <input type=\"checkbox\" id=\"ai-toggle\">\n    <select id=\"difficulty-select\"><option value=\"beginner\">Beginner</option></select>\n    <div id=\"move-history-panel\" class=\"hidden\"></div>\n    <div id=\"captured-pieces-panel\" class=\"hidden\"></div>\n    <div id=\"draw-offer-overlay\" class=\"hidden\"><div id=\"draw-offer-message\"></div></div>\n`;\n\n// Mock dependencies\njest.unstable_mockModule('../js/ui.js', () => ({\n  renderBoard: jest.fn(), showModal: jest.fn(),\n  updateStatus: jest.fn(),\n  updateShopUI: jest.fn(),\n  updateClockDisplay: jest.fn(),\n  updateClockUI: jest.fn(),\n  updateCapturedUI: jest.fn(),\n  updateMoveHistoryUI: jest.fn(),\n  updateStatistics: jest.fn(),\n  animateMove: jest.fn().mockResolvedValue(),\n  addCapturedPiece: jest.fn(),\n  showPromotionUI: jest.fn((game, r, c, color, moveRecord, callback) => callback()),\n  showShop: jest.fn(),\n  renderEvalGraph: jest.fn(),\n}));\n\njest.unstable_mockModule('../js/sounds.js', () => ({\n  soundManager: {\n    playMove: jest.fn(),\n    playCapture: jest.fn(),\n    playGameOver: jest.fn(),\n    playGameStart: jest.fn(),\n    init: jest.fn()\n  }\n}));\n\nconst { Game } = await import('../js/gameEngine.js');\nconst { GameController } = await import('../js/gameController.js');\nconst { MoveController } = await import('../js/moveController.js');\n\ndescribe('Controller Logic Deep Dive', () => {\n  let game;\n  let gameController;\n  let moveController;\n\n  beforeEach(() => {\n    jest.useFakeTimers();\n    game = new Game(15, 'classic');\n    game.clockEnabled = true;\n    game.whiteTime = 300; // 5 minutes in seconds\n    game.blackTime = 300;\n\n    gameController = new GameController(game);\n    moveController = new MoveController(game);\n    game.gameController = gameController;\n    game.moveController = moveController;\n\n    // Mock gameStartTime to avoid \"skipping statistics save\"\n    game.gameStartTime = Date.now();\n    game.lastMoveTime = Date.now();\n\n    jest.clearAllMocks();\n    global.alert = jest.fn(); // Mock alert for save/load\n  });\n\n  afterEach(() => {\n    jest.useRealTimers();\n    jest.restoreAllMocks();\n  });\n\n  describe('Clock Mechanics', () => {\n    test('should decrement clock and timeout', () => {\n      gameController.startClock();\n      expect(game.whiteTime).toBe(300);\n\n      const startNow = Date.now();\n      jest.spyOn(Date, 'now').mockReturnValue(startNow + 1000);\n      jest.advanceTimersByTime(1000); // Trigger the interval tick\n\n      // Delta is 1s, so whiteTime should be 299\n      expect(game.whiteTime).toBeLessThan(300);\n      expect(game.whiteTime).toBeCloseTo(299, 0);\n\n      // Advance to timeout\n      Date.now.mockReturnValue(startNow + 301000);\n      jest.advanceTimersByTime(100);\n\n      expect(game.whiteTime).toBe(0);\n      expect(game.phase).toBe(PHASES.GAME_OVER);\n      expect(document.getElementById('winner-text').textContent).toContain('Schwarz gewinnt durch Zeitberschreitung');\n    });\n\n    test('should switch clocks on turn change', () => {\n      gameController.startClock();\n\n      const now = Date.now();\n      jest.spyOn(Date, 'now').mockReturnValue(now + 1000);\n      jest.advanceTimersByTime(1000);\n\n      expect(game.whiteTime).toBeCloseTo(299, 0);\n      expect(game.blackTime).toBe(300);\n\n      // Switch turn\n      game.turn = 'black';\n      game.lastMoveTime = Date.now(); // Update to now (now + 1000)\n\n      Date.now.mockReturnValue(now + 2000);\n      jest.advanceTimersByTime(1000);\n\n      expect(game.whiteTime).toBeCloseTo(299, 0);\n      expect(game.blackTime).toBeCloseTo(299, 0);\n    });\n  });\n\n  describe('State Persistence (Save/Load)', () => {\n    test('should save and load state correctly via localStorage', () => {\n      const spySet = jest.spyOn(Storage.prototype, 'setItem');\n      const spyGet = jest.spyOn(Storage.prototype, 'getItem');\n\n      game.points = 10;\n      gameController.saveGame();\n\n      expect(spySet).toHaveBeenCalledWith('schach9x9_save_autosave', expect.any(String));\n      const savedData = JSON.parse(spySet.mock.calls[0][1]);\n      expect(savedData.points).toBe(10);\n\n      // Mock load\n      spyGet.mockReturnValue(JSON.stringify(savedData));\n      game.points = 0;\n      gameController.loadGame();\n      expect(game.points).toBe(10);\n\n      spySet.mockRestore();\n      spyGet.mockRestore();\n    });\n  });\n\n  describe('Move Controller Logical Execution', () => {\n    test('should execute pawn promotion (automatic to Angel)', async () => {\n      // In moveController.js line 181, it promotes automatically to 'e'\n      game.board[1][4] = { type: 'p', color: 'white', hasMoved: true };\n      game.turn = 'white';\n\n      await moveController.executeMove({ r: 1, c: 4 }, { r: 0, c: 4 });\n\n      expect(game.board[0][4].type).toBe('e'); // 'e' is Angel\n    });\n\n    test('should execute queenside castling', async () => {\n      game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n      game.board[8][0] = { type: 'r', color: 'white', hasMoved: false };\n      game.board[8][1] = null;\n      game.board[8][2] = null;\n      game.board[8][3] = null;\n      game.turn = 'white';\n\n      await moveController.executeMove({ r: 8, c: 4 }, { r: 8, c: 2 });\n\n      expect(game.board[8][2].type).toBe('k');\n      expect(game.board[8][3].type).toBe('r');\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/effects.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'tag' is defined but never used. Allowed unused args must match /^_/u.","line":19,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\n\n// Mock DOM\n// Mock DOM\nconst createMockElement = () => ({\n  className: '',\n  style: {\n    getPropertyValue: jest.fn(),\n    setProperty: jest.fn(),\n  },\n  remove: jest.fn(),\n  appendChild: jest.fn(),\n});\n\nglobal.document = {\n  getElementById: jest.fn().mockReturnValue({\n    appendChild: jest.fn(),\n  }),\n  createElement: jest.fn((tag) => createMockElement()),\n  body: {\n    appendChild: jest.fn(),\n    removeChild: jest.fn(),\n    contains: jest.fn().mockReturnValue(true),\n  },\n};\n\n// Mock requestAnimationFrame\nglobal.requestAnimationFrame = jest.fn((cb) => setTimeout(cb, 16));\n\ndescribe('ParticleSystem', () => {\n  let ParticleSystem;\n  let particleSystem;\n\n  beforeAll(async () => {\n    const mod = await import('../js/effects.js');\n    ParticleSystem = mod.ParticleSystem;\n    particleSystem = mod.particleSystem;\n  });\n\n  beforeEach(() => {\n    // Clear particles before each test\n    particleSystem.particles = [];\n    particleSystem.animating = false;\n    jest.clearAllMocks();\n  });\n\n  describe('spawn particles', () => {\n    test('should spawn particles', () => {\n      const initialLength = particleSystem.particles.length;\n      particleSystem.spawn(100, 200, 'CAPTURE', '#ff0000');\n\n      expect(particleSystem.particles.length).toBeGreaterThan(initialLength);\n    });\n\n    test('should create more particles for CAPTURE than MOVE', () => {\n      const newParticleSystem = new ParticleSystem();\n\n      newParticleSystem.spawn(100, 100, 'CAPTURE', '#ff0000');\n      const captureCount = newParticleSystem.particles.length;\n\n      const anotherParticleSystem = new ParticleSystem();\n      anotherParticleSystem.spawn(100, 100, 'MOVE', '#0000ff');\n      const moveCount = anotherParticleSystem.particles.length;\n\n      expect(captureCount).toBeGreaterThan(moveCount);\n    });\n\n    test('should start animation when spawning particles', () => {\n      const newParticleSystem = new ParticleSystem();\n      newParticleSystem.spawn(100, 100, 'CAPTURE');\n\n      expect(newParticleSystem.animating).toBe(true);\n      expect(requestAnimationFrame).toHaveBeenCalled();\n    });\n\n    test('should use default color when not specified', () => {\n      const newParticleSystem = new ParticleSystem();\n      newParticleSystem.spawn(100, 100, 'MOVE');\n\n      expect(newParticleSystem.particles.length).toBeGreaterThan(0);\n    });\n\n    test('should create particles with different types', () => {\n      const moveSystem = new ParticleSystem();\n      const captureSystem = new ParticleSystem();\n\n      moveSystem.spawn(100, 100, 'MOVE');\n      captureSystem.spawn(100, 100, 'CAPTURE');\n\n      // CAPTURE should create more particles\n      expect(captureSystem.particles.length).toBeGreaterThan(moveSystem.particles.length);\n    });\n\n    test('should handle unknown particle type', () => {\n      const newParticleSystem = new ParticleSystem();\n      newParticleSystem.spawn(100, 100, 'UNKNOWN_TYPE');\n\n      // Should still create particles with default count\n      expect(newParticleSystem.particles.length).toBeGreaterThan(0);\n    });\n\n    test('should append particles to container', () => {\n      const mockContainer = {\n        appendChild: jest.fn()\n      };\n      const newParticleSystem = new ParticleSystem();\n      newParticleSystem.container = mockContainer;\n\n      newParticleSystem.spawn(100, 100, 'MOVE');\n\n      expect(mockContainer.appendChild).toHaveBeenCalled();\n    });\n  });\n\n  describe('particle update logic', () => {\n    test('should remove particles after life expires', () => {\n      const newParticleSystem = new ParticleSystem();\n      newParticleSystem.spawn(100, 100, 'MOVE');\n\n      const initialCount = newParticleSystem.particles.length;\n      expect(initialCount).toBeGreaterThan(0);\n\n      // Simulate particle expiry by setting life to 0\n      newParticleSystem.particles.forEach(p => p.life = 0);\n\n      // Particles with life <= 0 should be removed in next update\n      expect(newParticleSystem.particles.some(p => p.life <= 0)).toBe(true);\n    });\n\n    test('should update particle positions', () => {\n      const newParticleSystem = new ParticleSystem();\n      newParticleSystem.spawn(100, 100, 'MOVE');\n\n      const particle = newParticleSystem.particles[0];\n      const originalX = particle.x;\n      const originalY = particle.y;\n\n      // Manually update particle\n      particle.x += particle.vx;\n      particle.y += particle.vy;\n\n      expect(particle.x).not.toBe(originalX);\n      expect(particle.y).not.toBe(originalY);\n    });\n\n    test('should apply gravity to particles', () => {\n      const newParticleSystem = new ParticleSystem();\n      newParticleSystem.spawn(100, 100, 'MOVE');\n\n      const particle = newParticleSystem.particles[0];\n      const originalVy = particle.vy;\n\n      // Simulate gravity\n      particle.vy += 0.2;\n\n      expect(particle.vy).toBeGreaterThan(originalVy);\n    });\n\n    test('should decrease particle life over time', () => {\n      const newParticleSystem = new ParticleSystem();\n      newParticleSystem.spawn(100, 100, 'MOVE');\n\n      const particle = newParticleSystem.particles[0];\n      const originalLife = particle.life;\n\n      particle.life -= 0.016;\n\n      expect(particle.life).toBeLessThan(originalLife);\n    });\n  });\n\n  describe('animation lifecycle', () => {\n    test('should handle empty particle array', () => {\n      const newParticleSystem = new ParticleSystem();\n\n      expect(newParticleSystem.particles.length).toBe(0);\n      // animating should not be checked initially - it's set when particles spawn\n    });\n\n    test('should stop animation when no particles remain', () => {\n      const newParticleSystem = new ParticleSystem();\n      newParticleSystem.particles = [];\n      newParticleSystem.animating = true;\n\n      newParticleSystem.update();\n\n      expect(newParticleSystem.animating).toBe(false);\n    });\n\n    test('should not start multiple animations when already animating', () => {\n      const newParticleSystem = new ParticleSystem();\n      newParticleSystem.animating = true;\n      const callCount = requestAnimationFrame.mock.calls.length;\n\n      newParticleSystem.spawn(100, 100, 'MOVE');\n\n      // Should not increment call count when already animating\n      expect(requestAnimationFrame.mock.calls.length).toBe(callCount);\n    });\n\n    test('should continue animating when particles exist', () => {\n      const newParticleSystem = new ParticleSystem();\n      newParticleSystem.spawn(100, 100, 'MOVE');\n\n      // Set a reasonable life value\n      newParticleSystem.particles.forEach(p => p.life = 0.5);\n\n      const beforeCallCount = requestAnimationFrame.mock.calls.length;\n      newParticleSystem.update();\n\n      // Should call requestAnimationFrame again\n      expect(requestAnimationFrame.mock.calls.length).toBeGreaterThan(beforeCallCount);\n    });\n  });\n\n  describe('particle rendering', () => {\n    test('should set particle position styles', () => {\n      const newParticleSystem = new ParticleSystem();\n      newParticleSystem.spawn(150, 250, 'MOVE');\n\n      const particle = newParticleSystem.particles[0];\n\n      expect(particle.el.style.left).toBe('150px');\n      expect(particle.el.style.top).toBe('250px');\n    });\n\n    test('should set CAPTURE particles with box shadow', () => {\n      const newParticleSystem = new ParticleSystem();\n      newParticleSystem.spawn(100, 100, 'CAPTURE', '#ff0000');\n\n      const particle = newParticleSystem.particles[0];\n\n      expect(particle.el.style.boxShadow).toBeDefined();\n      expect(particle.el.style.boxShadow).toContain('#ff0000');\n    });\n\n    test('should remove particle element when life expires', () => {\n      const newParticleSystem = new ParticleSystem();\n      newParticleSystem.spawn(100, 100, 'MOVE');\n\n      const particle = newParticleSystem.particles[0];\n      // Spy on the remove method of the created element\n      const removeSpy = jest.spyOn(particle.el, 'remove');\n\n      // Set life to 0 to trigger removal\n      particle.life = 0;\n      newParticleSystem.update();\n\n      expect(removeSpy).toHaveBeenCalled();\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/fuzz.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/gameController.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'soundManager' is assigned a value but never used.","line":64,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":64,"endColumn":21},{"ruleId":"no-unused-vars","severity":1,"message":"'id' is defined but never used. Allowed unused args must match /^_/u.","line":109,"column":64,"nodeType":"Identifier","messageId":"unusedVar","endLine":109,"endColumn":66}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\nimport { PHASES } from '../js/config.js';\n\n// Mock dependencies\njest.unstable_mockModule('../js/ui.js', () => ({\n  renderBoard: jest.fn(), showModal: jest.fn(),\n  updateStatus: jest.fn(),\n  updateShopUI: jest.fn(),\n  updateClockUI: jest.fn(),\n  updateClockDisplay: jest.fn(),\n  initBoardUI: jest.fn(),\n  showShop: jest.fn(),\n  updateMoveHistoryUI: jest.fn(),\n  updateCapturedUI: jest.fn(),\n  updateStatistics: jest.fn(),\n  renderEvalGraph: jest.fn(),\n  animateCheckmate: jest.fn(),\n  animateCheck: jest.fn(),\n}));\n\njest.unstable_mockModule('../js/sounds.js', () => ({\n  soundManager: {\n    init: jest.fn(),\n    playMove: jest.fn(),\n    playGameStart: jest.fn(),\n    playGameOver: jest.fn(),\n    playSound: jest.fn(),\n    playCheck: jest.fn(),\n  }\n}));\n\njest.unstable_mockModule('../js/gameEngine.js', () => ({\n  Game: class {\n    constructor(initialPoints = 15, mode = 'classic', isAI = false) {\n      this.initialPoints = initialPoints;\n      this.mode = mode;\n      this.isAI = isAI;\n      this.board = Array(9).fill(null).map(() => Array(9).fill(null));\n      this.phase = PHASES.SETUP_WHITE_KING;\n      this.turn = 'white';\n      this.points = initialPoints;\n      this.whiteCorridor = { rowStart: 6, colStart: 3 };\n      this.blackCorridor = { rowStart: 0, colStart: 3 };\n      this.log = jest.fn();\n      this.whiteTime = 300;\n      this.blackTime = 300;\n      this.clockEnabled = false;\n      this.moveHistory = [];\n      this.redoStack = [];\n      this.positionHistory = [];\n      this.capturedPieces = { white: [], black: [] };\n      this.drawOffered = false;\n      this.drawOfferedBy = null;\n    }\n  },\n  PHASES,\n  BOARD_SIZE: 9\n}));\n\n// Import GameController\nconst { GameController } = await import('../js/gameController.js');\nconst { Game } = await import('../js/gameEngine.js');\nconst UI = await import('../js/ui.js');\nconst { soundManager } = await import('../js/sounds.js');\n\ndescribe('GameController', () => {\n  let game;\n  let gameController;\n\n  beforeEach(() => {\n    game = new Game(15, 'setup', false);\n    game.log = jest.fn();\n    gameController = new GameController(game);\n    game.gameController = gameController;\n\n    // Mock DOM\n    const createMockElement = () => {\n      const element = {\n        classList: {\n          remove: jest.fn(),\n          add: jest.fn(),\n          contains: jest.fn(() => false),\n          toggle: jest.fn()\n        },\n        style: {},\n        disabled: false,\n        value: '',\n        checked: false,\n        scrollTop: 0,\n        scrollHeight: 100,\n        appendChild: jest.fn(),\n        dataset: {}\n      };\n      let innerHTML = '';\n      let textContent = '';\n      Object.defineProperty(element, 'innerHTML', {\n        get: () => innerHTML,\n        set: (val) => { innerHTML = val; },\n        configurable: true\n      });\n      Object.defineProperty(element, 'textContent', {\n        get: () => textContent,\n        set: (val) => { textContent = val; },\n        configurable: true\n      });\n      return element;\n    };\n\n    jest.spyOn(document, 'getElementById').mockImplementation((id) => createMockElement());\n    jest.spyOn(document, 'querySelector').mockImplementation(() => ({\n      classList: { add: jest.fn(), remove: jest.fn() }\n    }));\n    jest.spyOn(document, 'querySelectorAll').mockImplementation(() => [\n      { classList: { remove: jest.fn() } },\n      { classList: { remove: jest.fn() } }\n    ]);\n    jest.spyOn(document, 'createElement').mockImplementation(() => ({\n      classList: { add: jest.fn() },\n      dataset: {},\n      addEventListener: jest.fn()\n    }));\n\n    global.alert = jest.fn();\n    global.confirm = jest.fn(() => true);\n\n    Storage.prototype.getItem = jest.fn(() => null);\n    Storage.prototype.setItem = jest.fn();\n    Storage.prototype.removeItem = jest.fn();\n    Storage.prototype.clear = jest.fn();\n\n    jest.clearAllMocks();\n  });\n\n  describe('General Logic and Statistics', () => {\n    test('should save game statistics on game over', () => {\n      gameController.gameStartTime = Date.now();\n      game.isAI = true;\n      game.difficulty = 'medium';\n      gameController.saveGameToStatistics('win', 'black');\n      expect(gameController.gameStartTime).toBeNull();\n    });\n\n    test('should skip statistics if gameStartTime not set', () => {\n      gameController.gameStartTime = null;\n      gameController.saveGameToStatistics('win', 'black');\n      expect(true).toBe(true);\n    });\n\n    test('should handle corridor placement calculation', () => {\n      game.phase = PHASES.SETUP_WHITE_KING;\n      gameController.placeKing(7, 4, 'white');\n      expect(game.board[7][4]).toEqual({ type: 'k', color: 'white', hasMoved: false });\n    });\n  });\n\n  describe('King Placement', () => {\n    test('should place white king in valid corridor', () => {\n      game.phase = PHASES.SETUP_WHITE_KING;\n      gameController.placeKing(7, 4, 'white');\n      expect(game.board[7][4]).toEqual({ type: 'k', color: 'white', hasMoved: false });\n      expect(game.phase).toBe(PHASES.SETUP_BLACK_KING);\n    });\n\n    test('should reject king placement outside corridor', () => {\n      game.phase = PHASES.SETUP_WHITE_KING;\n      gameController.placeKing(2, 4, 'white');\n      expect(game.board[2][4]).toBeNull();\n      expect(game.log).toHaveBeenCalledWith('Ungltiger Bereich fr Knig!');\n    });\n  });\n\n  describe('Shop and Piece Management', () => {\n    test('should select piece if player has enough points', () => {\n      game.points = 15;\n      gameController.selectShopPiece('n');\n      expect(game.selectedShopPiece).toBe('n');\n    });\n\n    test('should refund points when removing piece from corridor', () => {\n      game.phase = PHASES.SETUP_WHITE_PIECES;\n      game.points = 10;\n      game.board[6][3] = { type: 'p', color: 'white' };\n      game.selectedShopPiece = null;\n      gameController.placeShopPiece(6, 3);\n      expect(game.points).toBe(11);\n      expect(game.board[6][3]).toBeNull();\n    });\n\n    test('should clear selectedShopPiece after placing a piece', () => {\n      game.phase = PHASES.SETUP_WHITE_PIECES;\n      game.points = 15;\n      game.selectedShopPiece = 'p';\n      gameController.placeShopPiece(6, 3);\n      expect(game.selectedShopPiece).toBeNull();\n      expect(game.points).toBe(14);\n    });\n\n    test('should reject piece selection without shop piece', () => {\n      game.phase = PHASES.SETUP_WHITE_PIECES;\n      game.selectedShopPiece = null;\n      gameController.placeShopPiece(6, 3);\n      expect(game.log).toHaveBeenCalledWith('Bitte zuerst eine Figur im Shop auswhlen!');\n    });\n  });\n\n  describe('Cell Click Handling', () => {\n    test('should handle clicks during setup phases', () => {\n      game.phase = PHASES.SETUP_WHITE_KING;\n      gameController.handleCellClick(7, 4);\n      expect(game.board[7][4]).toEqual({ type: 'k', color: 'white', hasMoved: false });\n    });\n\n    test('should block clicks during animation', () => {\n      game.isAnimating = true;\n      game.phase = PHASES.PLAY;\n      gameController.handleCellClick(4, 4);\n      expect(UI.renderBoard).not.toHaveBeenCalled();\n    });\n\n    test('should block clicks in replay mode', () => {\n      game.replayMode = true;\n      game.phase = PHASES.PLAY;\n      gameController.handleCellClick(4, 4);\n      expect(UI.renderBoard).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('AI and Game State', () => {\n    test('should not allow player clicks during AI turn', () => {\n      game.isAI = true;\n      game.phase = PHASES.PLAY;\n      game.turn = 'black';\n      game.handlePlayClick = jest.fn();\n      gameController.handleCellClick(0, 0);\n      expect(game.handlePlayClick).not.toHaveBeenCalled();\n    });\n\n    test('should handle AI draw offer evaluation', () => {\n      game.phase = PHASES.PLAY;\n      game.isAI = true;\n      game.turn = 'white';\n      gameController.offerDraw('white');\n      expect(game.drawOffered).toBe(true);\n    });\n  });\n\n  describe('Clock Management', () => {\n    test('should stop clock when not in PLAY phase', () => {\n      game.phase = PHASES.SETUP_WHITE_PIECES;\n      gameController.clockInterval = setInterval(() => { }, 100);\n      gameController.tickClock();\n      expect(gameController.clockInterval).toBeNull();\n    });\n  });\n\n  describe('Analysis Mode', () => {\n    test('should enter analysis mode only during play', () => {\n      game.phase = PHASES.SETUP_WHITE_KING;\n      const result = gameController.enterAnalysisMode();\n      expect(result).toBe(false);\n    });\n\n    test('should restore position when exiting analysis', () => {\n      game.phase = PHASES.PLAY;\n      game.positionHistory = ['h1'];\n      game.board[0][0] = { type: 'k', color: 'black' };\n      gameController.enterAnalysisMode();\n      game.positionHistory = ['h2'];\n      gameController.exitAnalysisMode(true);\n      expect(game.positionHistory).toEqual(['h1']);\n    });\n  });\n\n  describe('Save and Load', () => {\n    test('should handle corrupt save data', () => {\n      Storage.prototype.getItem.mockReturnValueOnce('invalid');\n      gameController.loadGame();\n      expect(game.log).toHaveBeenCalledWith(expect.stringContaining('Fehler'));\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/gameEngine.additional.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/gameEngine.classic.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/gameEngine.edge.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/gameEngine.pieces.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/gameEngine.rules.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'jest' is defined but never used.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":14},{"ruleId":"no-unused-vars","severity":1,"message":"'moves' is assigned a value but never used.","line":130,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":130,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest, describe, test, expect, beforeAll, beforeEach } from '@jest/globals';\n\ndescribe('Game Engine Rules', () => {\n  let Game, PHASES, BOARD_SIZE, createEmptyBoard;\n  let game;\n\n  beforeAll(async () => {\n    // Import the module dynamically\n    const mod = await import('../js/gameEngine.js');\n    Game = mod.Game;\n    PHASES = mod.PHASES;\n    BOARD_SIZE = mod.BOARD_SIZE;\n    createEmptyBoard = mod.createEmptyBoard;\n  });\n\n  beforeEach(() => {\n    game = new Game();\n    // Manually set up a board for testing\n    game.board = Array(BOARD_SIZE)\n      .fill(null)\n      .map(() => Array(BOARD_SIZE).fill(null));\n    game.phase = PHASES.PLAY;\n  });\n\n  describe('Basic Movement', () => {\n    test('should return valid knight moves in the center', () => {\n      game.board[4][4] = { type: 'n', color: 'white' };\n      const moves = game.getValidMoves(4, 4, game.board[4][4]);\n      expect(moves).toEqual(\n        expect.arrayContaining([\n          { r: 2, c: 3 }, { r: 2, c: 5 },\n          { r: 3, c: 2 }, { r: 3, c: 6 },\n          { r: 5, c: 2 }, { r: 5, c: 6 },\n          { r: 6, c: 3 }, { r: 6, c: 5 }\n        ])\n      );\n    });\n\n    test('should not allow moves off the board', () => {\n      game.board[0][0] = { type: 'n', color: 'white' };\n      const moves = game.getValidMoves(0, 0, game.board[0][0]);\n      expect(moves).toEqual(\n        expect.arrayContaining([\n          { r: 1, c: 2 },\n          { r: 2, c: 1 },\n        ])\n      );\n      expect(moves.length).toBe(2);\n    });\n  });\n\n  describe('Check Detection', () => {\n    test('should detect simple check from Rook', () => {\n      // White King at e1 (8, 4)\n      game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n      // Black Rook at e8 (1, 4)\n      game.board[1][4] = { type: 'r', color: 'black', hasMoved: false };\n\n      expect(game.isInCheck('white')).toBe(true);\n    });\n\n    test('should NOT detect check if blocked', () => {\n      // White King at e1 (8, 4)\n      game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n      // Black Rook at e8 (1, 4)\n      game.board[1][4] = { type: 'r', color: 'black', hasMoved: false };\n      // White Pawn at e2 (7, 4) blocking\n      game.board[7][4] = { type: 'p', color: 'white', hasMoved: false };\n\n      expect(game.isInCheck('white')).toBe(false);\n    });\n\n    test('should detect Knight check', () => {\n      // White King at e1 (8, 4)\n      game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n      // Black Knight at d3 (6, 3) attacking e1\n      game.board[6][3] = { type: 'n', color: 'black', hasMoved: false };\n\n      expect(game.isInCheck('white')).toBe(true);\n    });\n  });\n\n  describe('Checkmate Detection', () => {\n    test('should detect Back Rank Mate with two Rooks', () => {\n      // White King at a1 (8, 0)\n      game.board[8][0] = { type: 'k', color: 'white', hasMoved: false };\n\n      // Black Rook at a8 (0, 0) controlling file a\n      game.board[0][0] = { type: 'r', color: 'black', hasMoved: false };\n\n      // Black Rook at b8 (0, 1) controlling file b\n      game.board[0][1] = { type: 'r', color: 'black', hasMoved: false };\n\n      // King is at (8,0).\n      // Attacked by Rook at (0,0).\n      // Escape squares:\n      // (8,1) - attacked by Rook at (0,1)\n      // (7,0) - attacked by Rook at (0,0)\n      // (7,1) - attacked by Rook at (0,1) and (0,0)? No, (0,0) is file a.\n      // (7,1) is attacked by Rook at (0,1).\n\n      expect(game.isInCheck('white')).toBe(true);\n      expect(game.isCheckmate('white')).toBe(true);\n    });\n\n    test('should NOT be checkmate if piece can block the check', () => {\n      // White King at a1 (8, 0)\n      game.board[8][0] = { type: 'k', color: 'white', hasMoved: false };\n\n      // Black Rook at a8 (0, 0) checking down the a-file\n      game.board[0][0] = { type: 'r', color: 'black', hasMoved: false };\n\n      // White Rook at h5 (4, 7) can move to a5 (4, 0) to block\n      game.board[4][7] = { type: 'r', color: 'white', hasMoved: false };\n\n      expect(game.isInCheck('white')).toBe(true);\n      expect(game.isCheckmate('white')).toBe(false);\n    });\n\n    test('should detect checkmate with a Queen and Rook', () => {\n      game = new Game();\n      game.board = createEmptyBoard();\n      // White King at i1 (8, 8)\n      game.board[8][8] = { type: 'k', color: 'white', hasMoved: false };\n      // Black Queen at h2 (7, 7)\n      game.board[7][7] = { type: 'q', color: 'black', hasMoved: false };\n      // Black Rook at h8 (1, 7) protecting the Queen\n      game.board[1][7] = { type: 'r', color: 'black', hasMoved: false };\n\n      const moves = game.getAllLegalMoves('white');\n      // console.log('Legal moves for white:', JSON.stringify(moves, null, 2));\n\n      expect(game.isInCheck('white')).toBe(true);\n      expect(game.isCheckmate('white')).toBe(true);\n    });\n\n    test('should NOT be checkmate if king can move to a safe square', () => {\n      game = new Game();\n      game.board = createEmptyBoard();\n      // White King at h1 (8, 7)\n      game.board[8][7] = { type: 'k', color: 'white', hasMoved: false };\n      // Black Queen at g2 (7, 6)\n      game.board[7][6] = { type: 'q', color: 'black', hasMoved: false };\n      // No Rook at h8, so king can move to g1 (8, 6)\n      game.board[8][6] = null; // Ensure g1 is empty\n\n      expect(game.isInCheck('white')).toBe(true);\n      expect(game.isCheckmate('white')).toBe(false);\n    });\n\n    test('should NOT be checkmate if a piece can capture the checking piece', () => {\n      game = new Game();\n      game.board = createEmptyBoard();\n      // White King at e1 (8, 4)\n      game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n      // Black Rook at e8 (1, 4) checking\n      game.board[1][4] = { type: 'r', color: 'black', hasMoved: false };\n      // White Rook at a4 (5, 0) can capture the black rook\n      game.board[5][0] = { type: 'r', color: 'white', hasMoved: false };\n\n      expect(game.isInCheck('white')).toBe(true);\n      expect(game.isCheckmate('white')).toBe(false);\n    });\n\n    test('should detect checkmate by double check (cannot block or capture)', () => {\n      game = new Game();\n      game.board = createEmptyBoard();\n      // White King at e1 (8, 4)\n      game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n\n      // Black Rook at e8 (1, 4)\n      game.board[1][4] = { type: 'r', color: 'black', hasMoved: false };\n\n      // Black Knight at d3 (6, 3)\n      game.board[6][3] = { type: 'n', color: 'black', hasMoved: false };\n\n      // White Rook at a1 (8, 0) - could capture Knight but not Rook\n      game.board[8][0] = { type: 'r', color: 'white', hasMoved: false };\n\n      // In double check, King MUST move. If he can't, it's mate.\n      // Block squares around King\n      game.board[8][3] = { type: 'p', color: 'white' };\n      game.board[8][5] = { type: 'p', color: 'white' };\n      game.board[7][3] = { type: 'p', color: 'white' };\n      game.board[7][4] = { type: 'p', color: 'white' };\n      game.board[7][5] = { type: 'p', color: 'white' };\n\n      expect(game.isInCheck('white')).toBe(true);\n      expect(game.isCheckmate('white')).toBe(true);\n    });\n  });\n\n  describe('Castling', () => {\n    test('should allow kingside castling when conditions are met', () => {\n      // White King at e1 (8, 4)\n      game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n      // White Rook at i1 (8, 8)\n      game.board[8][8] = { type: 'r', color: 'white', hasMoved: false };\n\n      const moves = game.getValidMoves(8, 4, game.board[8][4]);\n      const castlingMove = moves.find(m => m.r === 8 && m.c === 6); // King moves 2 squares right\n\n      expect(castlingMove).toBeDefined();\n    });\n\n    test('should NOT allow castling if path is blocked', () => {\n      // White King at e1 (8, 4)\n      game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n      // White Rook at i1 (8, 8)\n      game.board[8][8] = { type: 'r', color: 'white', hasMoved: false };\n      // Blocking piece at f1 (8, 5)\n      game.board[8][5] = { type: 'n', color: 'white', hasMoved: false };\n\n      const moves = game.getValidMoves(8, 4, game.board[8][4]);\n      const castlingMove = moves.find(m => m.r === 8 && m.c === 6);\n\n      expect(castlingMove).toBeUndefined();\n    });\n\n    test('should NOT allow castling if king passes through check', () => {\n      // White King at e1 (8, 4)\n      game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n      // White Rook at i1 (8, 8)\n      game.board[8][8] = { type: 'r', color: 'white', hasMoved: false };\n      // Black Rook at f8 (0, 5) attacking f1\n      game.board[0][5] = { type: 'r', color: 'black', hasMoved: false };\n\n      const moves = game.getValidMoves(8, 4, game.board[8][4]);\n      const castlingMove = moves.find(m => m.r === 8 && m.c === 6);\n\n      expect(castlingMove).toBeUndefined();\n    });\n  });\n\n  describe('En Passant', () => {\n    test('should allow en passant capture after double pawn push', () => {\n      // White pawn at e5 (3, 4)\n      game.board[3][4] = { type: 'p', color: 'white', hasMoved: true };\n\n      // Black pawn at d7 (1, 3) that just moved to d5 (3, 3)\n      game.board[3][3] = { type: 'p', color: 'black', hasMoved: true };\n\n      // Set lastMove to indicate black pawn just did a double push\n      game.lastMove = {\n        from: { r: 1, c: 3 },\n        to: { r: 3, c: 3 },\n        piece: { type: 'p', color: 'black' },\n        isDoublePawnPush: true,\n      };\n\n      const moves = game.getValidMoves(3, 4, game.board[3][4]);\n      const enPassantMove = moves.find(m => m.r === 2 && m.c === 3);\n\n      expect(enPassantMove).toBeDefined();\n    });\n  });\n\n  describe('Stalemate', () => {\n    test('should detect stalemate', () => {\n      game = new Game();\n      game.board = createEmptyBoard();\n      game.turn = 'black';\n\n      // Black King at h8 (0, 8)\n      game.board[0][8] = { type: 'k', color: 'black', hasMoved: true };\n\n      // White Queen at g7 (2, 7) - confines King\n      game.board[2][7] = { type: 'q', color: 'white', hasMoved: true };\n\n      // White King at g7 (1, 6) - protects Queen and cuts off escape\n      game.board[1][6] = { type: 'k', color: 'white', hasMoved: true };\n\n      // Black King has no moves, but is NOT in check\n      expect(game.isInCheck('black')).toBe(false);\n      const legalMoves = game.getAllLegalMoves('black');\n      if (legalMoves.length > 0) {\n        console.log('Legal moves for black:', JSON.stringify(legalMoves, null, 2));\n      }\n      expect(legalMoves.length).toBe(0);\n      expect(game.isStalemate('black')).toBe(true);\n    });\n  });\n});\n\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/integration.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'id' is defined but never used. Allowed unused args must match /^_/u.","line":51,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":51,"endColumn":49}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\nimport { Game } from '../js/gameEngine.js';\nimport { PHASES } from '../js/config.js';\n\n// Mock dependencies\njest.unstable_mockModule('../js/ui.js', () => ({\n  renderBoard: jest.fn(),\n  showModal: jest.fn((title, message, buttons) => {\n    const continueBtn = buttons.find(b => b.text === 'Fortfahren' || b.class === 'btn-primary');\n    if (continueBtn && continueBtn.callback) {\n      continueBtn.callback();\n    }\n  }),\n  updateStatus: jest.fn(),\n  updateShopUI: jest.fn(),\n  updateClockUI: jest.fn(),\n  updateClockDisplay: jest.fn(),\n  updateStatistics: jest.fn(),\n  updateMoveHistoryUI: jest.fn(),\n  updateCapturedUI: jest.fn(),\n  showShop: jest.fn(),\n  showPromotionUI: jest.fn(),\n  animateMove: jest.fn().mockResolvedValue(),\n  animateCheck: jest.fn(),\n  addMoveToHistory: jest.fn(),\n  renderEvalGraph: jest.fn(),\n}));\n\njest.unstable_mockModule('../js/sounds.js', () => ({\n  soundManager: {\n    init: jest.fn(),\n    playMove: jest.fn(),\n    playCapture: jest.fn(),\n    playCheck: jest.fn(),\n    playCheckmate: jest.fn(),\n    playGameStart: jest.fn(),\n    playGameOver: jest.fn(),\n  },\n}));\n\nconst { GameController } = await import('../js/gameController.js');\nconst { MoveController } = await import('../js/moveController.js');\n\ndescribe('Integration Tests', () => {\n  let game;\n  let gameController;\n  let moveController;\n\n  beforeEach(() => {\n    // Mock DOM elements\n    global.document.getElementById = jest.fn((id) => ({\n      textContent: '',\n      innerHTML: '',\n      classList: { add: jest.fn(), remove: jest.fn() },\n      style: {},\n      disabled: false,\n      appendChild: jest.fn(),\n      value: '',\n      checked: false,\n      scrollTop: 0,\n      scrollHeight: 100,\n    }));\n\n    global.document.querySelector = jest.fn(() => ({\n      classList: { add: jest.fn(), remove: jest.fn() },\n      innerHTML: '',\n      parentElement: {},\n    }));\n\n    global.document.querySelectorAll = jest.fn(() => []);\n    global.document.createElement = jest.fn(() => ({\n      classList: { add: jest.fn(), remove: jest.fn() },\n      dataset: {},\n      addEventListener: jest.fn(),\n      appendChild: jest.fn(),\n      innerHTML: '',\n      style: {},\n    }));\n\n    // Mock window.confirm\n    global.confirm = jest.fn(() => true);\n    global.alert = jest.fn();\n\n    // Mock localStorage\n    const localStorageMock = {\n      getItem: jest.fn(),\n      setItem: jest.fn(),\n      removeItem: jest.fn(),\n      clear: jest.fn(),\n    };\n    Object.defineProperty(global, 'localStorage', { value: localStorageMock, writable: true });\n\n    // Initialize Game and Controllers\n    game = new Game(15, 'setup');\n    gameController = new GameController(game);\n    moveController = new MoveController(game);\n\n    game.gameController = gameController;\n    game.moveController = moveController;\n\n    // Mock AI Engine if needed\n    game.aiEngine = {\n      makeMove: jest.fn(),\n    };\n  });\n\n  describe('Full Game Setup Flow', () => {\n    test('should complete full setup: white king  black king  pieces  play', async () => {\n      // Phase 1: White King Placement\n      expect(game.phase).toBe(PHASES.SETUP_WHITE_KING);\n\n      // Place white king in middle corridor\n      gameController.placeKing(7, 4, 'white');\n      expect(game.phase).toBe(PHASES.SETUP_BLACK_KING);\n      expect(game.whiteCorridor).toBeDefined();\n\n      // Phase 2: Black King Placement  \n      gameController.placeKing(1, 4, 'black');\n      expect(game.phase).toBe(PHASES.SETUP_WHITE_PIECES);\n      expect(game.blackCorridor).toBeDefined();\n\n      // Phase 3: White Piece Setup\n      gameController.selectShopPiece('p');\n      gameController.placeShopPiece(6, 3);\n      gameController.selectShopPiece('r');\n      gameController.placeShopPiece(8, 3);\n      gameController.finishSetupPhase();\n\n      expect(game.phase).toBe(PHASES.SETUP_BLACK_PIECES);\n\n      // Phase 4: Black Piece Setup\n      gameController.selectShopPiece('p');\n      gameController.placeShopPiece(2, 3);\n      gameController.selectShopPiece('r');\n      gameController.placeShopPiece(0, 3);\n      gameController.finishSetupPhase();\n\n      // Should now be in PLAY phase\n      expect(game.phase).toBe(PHASES.PLAY);\n      expect(game.turn).toBe('white');\n    });\n\n    test('should handle classic mode initialization', () => {\n      // Re-init with classic mode\n      game = new Game(15, 'classic');\n      gameController = new GameController(game);\n      moveController = new MoveController(game);\n      game.gameController = gameController;\n      game.moveController = moveController;\n\n      // Classic mode should skip setup and go straight to PLAY\n      // Note: Game constructor sets phase to PLAY for classic, \n      // but GameController constructor handles initialization logic\n      expect(game.phase).toBe(PHASES.PLAY);\n      expect(game.board[8][4]).toEqual({ type: 'k', color: 'white', hasMoved: false });\n      expect(game.board[0][4]).toEqual({ type: 'k', color: 'black', hasMoved: false });\n    });\n  });\n\n  describe('Save/Load Round Trip', () => {\n    test('should save and load game state correctly', async () => {\n      // Setup classic game\n      game = new Game(15, 'classic');\n      gameController = new GameController(game);\n      moveController = new MoveController(game);\n      game.gameController = gameController;\n      game.moveController = moveController;\n\n      // Make some moves\n      const from = { r: 7, c: 4 }; // Pawn at 7,4\n      const to = { r: 6, c: 4 };   // Move to 6,4\n      await moveController.executeMove(from, to);\n\n      // Save game\n      gameController.saveGame();\n      expect(localStorage.setItem).toHaveBeenCalledWith(\n        'schach9x9_save_autosave',\n        expect.any(String)\n      );\n\n      // Get saved data\n      const savedData = localStorage.setItem.mock.calls[0][1];\n      const parsedData = JSON.parse(savedData);\n\n      // Verify save structure\n      expect(parsedData).toHaveProperty('board');\n      expect(parsedData).toHaveProperty('turn');\n      expect(parsedData).toHaveProperty('phase');\n\n      // Create new game and load\n      const newGame = new Game(15, 'classic');\n      const newGameController = new GameController(newGame);\n      const newMoveController = new MoveController(newGame);\n      newGame.gameController = newGameController;\n      newGame.moveController = newMoveController;\n\n      localStorage.getItem.mockReturnValue(savedData);\n      newGameController.loadGame();\n\n      // Verify loaded state matches\n      expect(newGame.turn).toBe(game.turn);\n      // Note: moveHistory might be handled differently in save/load depending on implementation\n      // gameController.saveGame saves 'history' property, moveController uses 'moveHistory'\n      // Let's check if board state is restored\n      expect(newGame.board[6][4]).toEqual(expect.objectContaining({ type: 'p', color: 'white' }));\n    });\n  });\n\n  describe('Move Execution and Undo', () => {\n    test('should execute move  undo  redo correctly', async () => {\n      game = new Game(15, 'classic');\n      gameController = new GameController(game);\n      moveController = new MoveController(game);\n      game.gameController = gameController;\n      game.moveController = moveController;\n\n      const from = { r: 7, c: 4 }; // Pawn at 7,4\n      const to = { r: 6, c: 4 };   // Move to 6,4\n\n      // Execute move\n      await moveController.executeMove(from, to);\n      expect(game.moveHistory).toHaveLength(1);\n      expect(game.board[6][4].type).toBe('p');\n      expect(game.board[7][4]).toBeNull();\n\n      // Undo move\n      moveController.undoMove();\n      expect(game.moveHistory).toHaveLength(0);\n      expect(game.board[7][4].type).toBe('p');\n      expect(game.board[6][4]).toBeNull();\n\n      // Redo move\n      await moveController.redoMove();\n      expect(game.moveHistory).toHaveLength(1);\n      expect(game.board[6][4].type).toBe('p');\n    });\n  });\n\n  describe('Game End Scenarios', () => {\n    test('should handle resignation', () => {\n      game = new Game(15, 'classic');\n      gameController = new GameController(game);\n      game.gameController = gameController;\n      game.phase = PHASES.PLAY;\n\n      gameController.resign('white');\n\n      expect(game.phase).toBe(PHASES.GAME_OVER);\n      // Resignation doesn't set game.winner property directly in Game object usually, \n      // but updates UI and logs. We check phase.\n    });\n\n    test('should handle draw offer and acceptance', () => {\n      game = new Game(15, 'classic');\n      gameController = new GameController(game);\n      game.gameController = gameController;\n      game.phase = PHASES.PLAY;\n\n      gameController.offerDraw('white');\n      expect(game.drawOffered).toBe(true);\n      expect(game.drawOfferedBy).toBe('white');\n\n      gameController.acceptDraw();\n      expect(game.phase).toBe(PHASES.GAME_OVER);\n    });\n  });\n\n  describe('Time Control Integration', () => {\n    test('should handle time running out', () => {\n      game = new Game(15, 'classic');\n      gameController = new GameController(game);\n      game.gameController = gameController;\n\n      gameController.setTimeControl('blitz3');\n      game.clockEnabled = true;\n      game.phase = PHASES.PLAY;\n\n      // Simulate white time running out\n      game.whiteTime = 0;\n      gameController.tickClock();\n\n      expect(game.phase).toBe(PHASES.GAME_OVER);\n    });\n  });\n\n  describe('AI Integration', () => {\n    test('should handle AI game setup', () => {\n      game = new Game(15, 'setup');\n      gameController = new GameController(game);\n      game.gameController = gameController;\n\n      game.isAI = true;\n\n      // White (human) places king\n      gameController.placeKing(7, 4, 'white');\n\n      // AI setup is async (setTimeout), so we need to wait or use fake timers\n      // But placeKing sets phase to SETUP_BLACK_KING immediately\n      expect(game.phase).toBe(PHASES.SETUP_BLACK_KING);\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/logger.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/moveController.enhanced.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'id' is defined but never used. Allowed unused args must match /^_/u.","line":25,"column":64,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":66},{"ruleId":"no-unused-vars","severity":1,"message":"'firstPosition' is assigned a value but never used.","line":156,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":156,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\nimport { Game } from '../js/gameEngine.js';\nimport { MoveController } from '../js/moveController.js';\nimport { PHASES } from '../js/config.js';\n\ndescribe('MoveController - Enhanced Coverage Tests', () => {\n  let game, moveController;\n\n  beforeEach(() => {\n    game = new Game(15, 'classic');\n    moveController = new MoveController(game);\n    game.moveController = moveController;\n\n    // Mock basic board setup\n    game.board[6][4] = { type: 'p', color: 'white' };\n    game.board[1][4] = { type: 'p', color: 'black' };\n    game.phase = PHASES.PLAY;\n    game.turn = 'white';\n\n    // Mock game methods\n    game.stopClock = jest.fn();\n    game.startClock = jest.fn();\n\n    // Mock DOM elements\n    jest.spyOn(document, 'getElementById').mockImplementation((id) => ({\n      classList: {\n        add: jest.fn(),\n        remove: jest.fn()\n      },\n      textContent: '',\n      disabled: false\n    }));\n\n    jest.clearAllMocks();\n  });\n\n  describe('Replay Mode Edge Cases', () => {\n    test('should handle multiple promotions in replay', () => {\n      // Setup: Create game with promotion history\n      game.moveHistory = [\n        {\n          from: { r: 6, c: 4 },\n          to: { r: 4, c: 4 },\n          piece: { type: 'p', color: 'white' }\n        },\n        {\n          from: { r: 4, c: 4 },\n          to: { r: 0, c: 4 },\n          piece: { type: 'p', color: 'white' },\n          promotion: 'q' // Promoted to queen\n        }\n      ];\n\n      moveController.enterReplayMode();\n      expect(game.replayMode).toBe(true);\n      expect(game.replayPosition).toBe(1); // Starts at last move\n\n      // Go to first move\n      moveController.replayFirst();\n      expect(game.replayPosition).toBe(-1);\n\n      // Step through promotion move\n      moveController.replayNext();\n      expect(game.replayPosition).toBe(0);\n\n      // Verify replay mode is active\n      expect(game.replayMode).toBe(true);\n    });\n\n    test('should handle castling in replay correctly', () => {\n      // Setup castling move\n      game.board[7][4] = { type: 'k', color: 'white' };\n      game.board[7][7] = { type: 'r', color: 'white' };\n\n      game.moveHistory = [\n        {\n          from: { r: 7, c: 4 },\n          to: { r: 7, c: 6 },\n          piece: { type: 'k', color: 'white' },\n          castling: { rookFrom: { r: 7, c: 7 }, rookTo: { r: 7, c: 5 } }\n        }\n      ];\n\n      moveController.enterReplayMode();\n      expect(game.replayMode).toBe(true);\n\n      moveController.replayNext();\n\n      // Verify replay mode is functional\n      expect(game.replayPosition).toBeGreaterThanOrEqual(0);\n    });\n\n    test('should handle en passant in replay', () => {\n      // Setup en passant\n      game.board[3][4] = { type: 'p', color: 'white' };\n      game.board[3][5] = { type: 'p', color: 'black' };\n\n      game.moveHistory = [\n        {\n          from: { r: 3, c: 4 },\n          to: { r: 2, c: 5 },\n          piece: { type: 'p', color: 'white' },\n          enPassant: { r: 3, c: 5 }\n        }\n      ];\n\n      moveController.enterReplayMode();\n      expect(game.replayMode).toBe(true);\n\n      moveController.replayNext();\n\n      // Verify replay is working\n      expect(game.replayPosition).toBeGreaterThanOrEqual(0);\n    });\n\n    test('should correctly undo complex move sequences in replay', () => {\n      game.moveHistory = [\n        { from: { r: 6, c: 4 }, to: { r: 5, c: 4 }, piece: { type: 'p', color: 'white' } },\n        { from: { r: 1, c: 4 }, to: { r: 3, c: 4 }, piece: { type: 'p', color: 'black' } },\n        { from: { r: 5, c: 4 }, to: { r: 4, c: 4 }, piece: { type: 'p', color: 'white' } }\n      ];\n\n      moveController.enterReplayMode();\n\n      // Should start at last move\n      expect(game.replayPosition).toBe(2);\n\n      // Go to first move\n      moveController.replayFirst();\n      expect(game.replayPosition).toBe(-1);\n\n      // Go back to last\n      moveController.replayLast();\n      expect(game.replayPosition).toBe(2);\n\n      // Verify replay mode is active\n      expect(game.replayMode).toBe(true);\n    });\n\n    test('should handle replay boundary conditions', () => {\n      game.moveHistory = [\n        { from: { r: 6, c: 4 }, to: { r: 5, c: 4 }, piece: { type: 'p', color: 'white' } }\n      ];\n\n      moveController.enterReplayMode();\n\n      // Starts at last move (position 0 for 1 move)\n      expect(game.replayPosition).toBe(0);\n\n      // Try to go past last (should stay at 0)\n      moveController.replayNext();\n      expect(game.replayPosition).toBe(0);\n\n      // Go to first, then try to go before (should stay at 0 or -1)\n      moveController.replayFirst();\n      const firstPosition = game.replayPosition;\n      moveController.replayPrevious();\n\n      // Position should not change or should be at minimum allowed\n      expect(game.replayPosition).toBeLessThanOrEqual(0);\n    });\n  });\n\n  describe('Clock Management Tests', () => {\n    beforeEach(() => {\n      game.clockEnabled = true;\n      game.whiteTime = 300;\n      game.blackTime = 300;\n      game.clockRunning = false;\n    });\n\n    test('should trigger timeout when time reaches zero', () => {\n      game.whiteTime = 1;\n      game.turn = 'white';\n      game.clockRunning = true;\n\n      // Mock setTimeout\n      jest.useFakeTimers();\n\n      // Simulate clock tick\n      game.whiteTime = 0;\n\n      // Check if timeout is detected\n      const isTimeout = game.whiteTime <= 0;\n      expect(isTimeout).toBe(true);\n\n      jest.useRealTimers();\n    });\n\n    test('should apply time increment after move', () => {\n      game.timeControl = { initial: 300, increment: 2 };\n      game.whiteTime = 100;\n      game.turn = 'black'; // After white's move\n\n      // Simulate increment application\n      const timeAfterIncrement = 100 + 2;\n      expect(timeAfterIncrement).toBe(102);\n    });\n\n    test('should pause clock correctly', () => {\n      game.clockRunning = true;\n      game.whiteTime = 250;\n\n      moveController.stopClock = jest.fn(() => {\n        game.clockRunning = false;\n      });\n\n      moveController.stopClock();\n      expect(game.clockRunning).toBe(false);\n      expect(moveController.stopClock).toHaveBeenCalled();\n    });\n\n    test('should not decrement time when clock is paused', () => {\n      game.clockRunning = false;\n      const initialTime = game.whiteTime;\n\n      // Simulate tick attempt\n      if (!game.clockRunning) {\n        // Time should not change\n        expect(game.whiteTime).toBe(initialTime);\n      }\n    });\n\n    test('should handle different time controls', () => {\n      const timeControls = [\n        { name: 'blitz3', initial: 180, increment: 0 },\n        { name: 'blitz5', initial: 300, increment: 0 },\n        { name: 'rapid10', initial: 600, increment: 5 },\n        { name: 'rapid15', initial: 900, increment: 10 }\n      ];\n\n      timeControls.forEach(tc => {\n        game.timeControl = tc;\n        game.whiteTime = tc.initial;\n        game.blackTime = tc.initial;\n\n        expect(game.whiteTime).toBe(tc.initial);\n        expect(game.blackTime).toBe(tc.initial);\n      });\n    });\n  });\n\n  describe('Save/Load Robustness Tests', () => {\n    test('should handle corrupt save data gracefully', () => {\n      localStorage.setItem('schach9x9_save_autosave', 'invalid-json-{]}');\n\n      expect(() => {\n        try {\n          JSON.parse(localStorage.getItem('schach9x9_save_autosave'));\n        } catch (e) {\n          // Should catch parse error\n          expect(e).toBeInstanceOf(SyntaxError);\n        }\n      }).not.toThrow();\n    });\n\n    test('should handle missing fields with defaults', () => {\n      const incompleteSave = {\n        turn: 'white',\n        board: game.board\n        // Missing: moveHistory, capturedPieces, etc.\n      };\n\n      localStorage.setItem('schach9x9_save_autosave', JSON.stringify(incompleteSave));\n\n      const loaded = JSON.parse(localStorage.getItem('schach9x9_save_autosave'));\n\n      // Should provide defaults\n      const moveHistory = loaded.moveHistory || [];\n      const capturedPieces = loaded.capturedPieces || { white: [], black: [] };\n\n      expect(moveHistory).toEqual([]);\n      expect(capturedPieces).toEqual({ white: [], black: [] });\n    });\n\n    test('should migrate old save format', () => {\n      const oldFormatSave = {\n        turn: 'white',\n        boardState: game.board, // Old key name\n        moves: [] // Old key name\n      };\n\n      localStorage.setItem('schach9x9_save_autosave', JSON.stringify(oldFormatSave));\n\n      const loaded = JSON.parse(localStorage.getItem('schach9x9_save_autosave'));\n\n      // Simulate migration\n      const migratedBoard = loaded.board || loaded.boardState;\n      const migratedMoves = loaded.moveHistory || loaded.moves;\n\n      expect(migratedBoard).toBeDefined();\n      expect(migratedMoves).toEqual([]);\n    });\n\n    test('should handle localStorage quota exceeded', () => {\n      // Create very large save data\n      const largeSave = {\n        board: game.board,\n        moveHistory: new Array(10000).fill({\n          from: { r: 0, c: 0 },\n          to: { r: 1, c: 1 },\n          piece: { type: 'p', color: 'white' }\n        })\n      };\n\n      try {\n        localStorage.setItem('schach9x9_save_autosave', JSON.stringify(largeSave));\n      } catch (e) {\n        // Should handle QuotaExceededError\n        expect(e.name).toBe('QuotaExceededError');\n      }\n    });\n  });\n\n  describe('Position Hash and Draw Detection', () => {\n    test('should generate consistent board hashes', () => {\n      const hash1 = moveController.getBoardHash();\n      const hash2 = moveController.getBoardHash();\n\n      expect(hash1).toBe(hash2);\n    });\n\n    test('should detect threefold repetition', () => {\n      // Setup: Create position that repeats 3 times\n      moveController.positionHistory = ['hash1', 'hash2', 'hash1', 'hash2', 'hash1'];\n\n      const currentHash = 'hash1';\n      const count = moveController.positionHistory.filter(h => h === currentHash).length;\n\n      expect(count).toBeGreaterThanOrEqual(3);\n    });\n\n    test('should detect insufficient material', () => {\n      // King vs King\n      game.board = Array(9).fill(null).map(() => Array(9).fill(null));\n      game.board[0][4] = { type: 'k', color: 'black' };\n      game.board[8][4] = { type: 'k', color: 'white' };\n\n      const isInsufficient = moveController.isInsufficientMaterial();\n      expect(isInsufficient).toBe(true);\n    });\n\n    test('should not detect sufficient material as insufficient', () => {\n      // King + Queen vs King\n      game.board = Array(9).fill(null).map(() => Array(9).fill(null));\n      game.board[0][4] = { type: 'k', color: 'black' };\n      game.board[8][4] = { type: 'k', color: 'white' };\n      game.board[8][3] = { type: 'q', color: 'white' };\n\n      const isInsufficient = moveController.isInsufficientMaterial();\n      expect(isInsufficient).toBe(false);\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/moveController.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'id' is defined but never used. Allowed unused args must match /^_/u.","line":36,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\nimport { Game, createEmptyBoard } from '../js/gameEngine.js';\nimport { PHASES } from '../js/config.js';\n\n// Mock UI and SoundManager modules\njest.unstable_mockModule('../js/ui.js', () => ({\n  renderBoard: jest.fn(), showModal: jest.fn(),\n  showPromotionModal: jest.fn(),\n  showPromotionUI: jest.fn(),\n  animateMove: jest.fn().mockResolvedValue(),\n  animateCheck: jest.fn(),\n  animateCheckmate: jest.fn(),\n  updateStatistics: jest.fn(),\n  updateMoveHistoryUI: jest.fn(),\n  updateCapturedUI: jest.fn(),\n  updateStatus: jest.fn(),\n  updateShopUI: jest.fn(),\n  showShop: jest.fn(),\n  updateClockDisplay: jest.fn(),\n  updateClockUI: jest.fn(),\n  renderEvalGraph: jest.fn(),\n}));\n\njest.unstable_mockModule('../js/sounds.js', () => ({\n  soundManager: {\n    playMove: jest.fn(),\n    playCapture: jest.fn(),\n    playCheck: jest.fn(),\n    playCheckmate: jest.fn(),\n    playGameOver: jest.fn(),\n  },\n}));\n\n// Mock document functions used in MoveController\nglobal.document = {\n  getElementById: jest.fn((id) => ({\n    classList: { remove: jest.fn(), add: jest.fn() },\n    style: {},\n    textContent: '',\n    value: '',\n    checked: false,\n    disabled: false,\n    appendChild: jest.fn(),\n    scrollTop: 0,\n    scrollHeight: 100,\n    innerHTML: '',\n  })),\n};\n\n// Mock localStorage\nStorage.prototype.getItem = jest.fn(() => null);\nStorage.prototype.setItem = jest.fn();\nStorage.prototype.removeItem = jest.fn();\nStorage.prototype.clear = jest.fn();\n\n// Mock alert\nglobal.alert = jest.fn();\n\n// Import MoveController AFTER mocking\nconst { MoveController } = await import('../js/moveController.js');\nconst UI = await import('../js/ui.js');\nconst { soundManager } = await import('../js/sounds.js');\n\ndescribe('MoveController', () => {\n  let game;\n  let moveController;\n\n  beforeEach(() => {\n    game = new Game();\n    game.board = createEmptyBoard();\n    game.phase = PHASES.PLAY;\n\n    moveController = new MoveController(game);\n    game.moveController = moveController; // Link back\n    game.log = jest.fn(); // Mock log function\n    game.stopClock = jest.fn();\n    game.startClock = jest.fn();\n    game.updateBestMoves = jest.fn();\n\n    // Place Kings to avoid \"King captured\" game over logic\n    // Use corners to avoid conflict with test moves (usually in center/files 4)\n    game.board[0][0] = { type: 'k', color: 'black' };\n    game.board[8][8] = { type: 'k', color: 'white' };\n\n    jest.clearAllMocks();\n  });\n\n  test('should execute a simple move', async () => {\n    // Setup: White Pawn at 6,4\n    game.board[6][4] = { type: 'p', color: 'white' };\n\n    const from = { r: 6, c: 4 };\n    const to = { r: 5, c: 4 };\n\n    await moveController.executeMove(from, to);\n\n    // Check board update\n    expect(game.board[6][4]).toBeNull();\n    expect(game.board[5][4]).toEqual({ type: 'p', color: 'white', hasMoved: true });\n\n    // Check turn switch\n    expect(game.turn).toBe('black');\n\n    // Check UI update\n    expect(UI.renderBoard).toHaveBeenCalled();\n    expect(soundManager.playMove).toHaveBeenCalled();\n  });\n\n  test('should handle capture', async () => {\n    // Setup: White Rook at 4,4, Black Pawn at 4,6\n    game.board[4][4] = { type: 'r', color: 'white' };\n    game.board[4][6] = { type: 'p', color: 'black' };\n\n    const from = { r: 4, c: 4 };\n    const to = { r: 4, c: 6 };\n\n    await moveController.executeMove(from, to);\n\n    // Check board\n    expect(game.board[4][4]).toBeNull();\n    expect(game.board[4][6].type).toBe('r');\n\n    // Check captures\n    expect(game.capturedPieces.white.length).toBe(1); // White captured a piece\n    expect(game.capturedPieces.white[0].type).toBe('p');\n\n    // Check sound\n    expect(soundManager.playCapture).toHaveBeenCalled();\n  });\n\n  test('should handle promotion', async () => {\n    // Setup: White Pawn at 1,4 (about to promote)\n    game.board[1][4] = { type: 'p', color: 'white' };\n\n    const from = { r: 1, c: 4 };\n    const to = { r: 0, c: 4 };\n\n    // Mock showPromotionUI to immediately call callback\n    UI.showPromotionUI.mockImplementation((game, r, c, color, record, callback) => {\n      // Simulate user choosing Queen\n      // Note: The callback in MoveController.js calls finishMove(), but doesn't take arguments.\n      // The choice is usually handled inside showPromotionUI which updates the board/record.\n      // We need to simulate what showPromotionUI does.\n\n      // Manually set the piece to Angel (e)\n      game.board[0][4] = { type: 'e', color: 'white', hasMoved: true };\n\n      // Call the callback to finish move\n      callback();\n    });\n\n    await moveController.executeMove(from, to);\n\n    // Check board - was manually promoted to Angel by the mock\n    expect(game.board[0][4].type).toBe('e');\n    // Note: With auto-promotion to Angel, showPromotionUI is NOT called anymore\n    // expect(UI.showPromotionUI).toHaveBeenCalled();\n  });\n\n  test('should correctly undo promotion', async () => {\n    // Setup: White Pawn at 1,4 (about to promote)\n    game.board[1][4] = { type: 'p', color: 'white' };\n\n    const from = { r: 1, c: 4 };\n    const to = { r: 0, c: 4 };\n\n    // Mock auto-promotion (which is what happens in code now)\n    // The code automatically promotes to 'e' and calls finishMove\n    await moveController.executeMove(from, to);\n\n    // Verify promotion\n    expect(game.board[0][4].type).toBe('e');\n\n    // Undo\n    moveController.undoMove();\n\n    // Should be back to pawn at 1,4\n    expect(game.board[1][4]).not.toBeNull();\n    expect(game.board[1][4].type).toBe('p');\n    expect(game.board[0][4]).toBeNull();\n  });\n\n  test('should handle undo move', async () => {\n    // Setup: Execute a move first\n    game.board[6][4] = { type: 'p', color: 'white' };\n    const from = { r: 6, c: 4 };\n    const to = { r: 5, c: 4 };\n\n    await moveController.executeMove(from, to);\n    expect(game.board[5][4]).not.toBeNull();\n\n    // Now undo\n    moveController.undoMove();\n\n    // Piece should be back at original position\n    expect(game.board[6][4]).not.toBeNull();\n    expect(game.board[5][4]).toBeNull();\n    expect(game.turn).toBe('white'); // Turn should be back to white\n  });\n\n  test('should handle castling kingside', async () => {\n    // Setup: White King and Rook for kingside castling\n    game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n    game.board[8][8] = { type: 'r', color: 'white', hasMoved: false };\n\n    const from = { r: 8, c: 4 };\n    const to = { r: 8, c: 6 }; // Kingside castle\n\n    await moveController.executeMove(from, to);\n\n    // King should move to g1 (col 6), Rook to f1 (col 5)\n    expect(game.board[8][6]).not.toBeNull();\n    expect(game.board[8][6].type).toBe('k');\n    expect(game.board[8][5]).not.toBeNull();\n    expect(game.board[8][5].type).toBe('r');\n  });\n\n  test('should correctly undo kingside castling', async () => {\n    // Setup: White King and Rook for kingside castling\n    game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n    game.board[8][8] = { type: 'r', color: 'white', hasMoved: false };\n\n    const from = { r: 8, c: 4 };\n    const to = { r: 8, c: 6 }; // Kingside castle\n\n    await moveController.executeMove(from, to);\n    moveController.undoMove();\n\n    // King should be back at e1 (8, 4)\n    expect(game.board[8][4]).not.toBeNull();\n    expect(game.board[8][4].type).toBe('k');\n    expect(game.board[8][4].hasMoved).toBe(false);\n\n    // Rook should be back at i1 (8, 8)\n    expect(game.board[8][8]).not.toBeNull();\n    expect(game.board[8][8].type).toBe('r');\n    expect(game.board[8][8].hasMoved).toBe(false);\n\n    // Castling squares should be empty\n    expect(game.board[8][6]).toBeNull();\n    expect(game.board[8][5]).toBeNull();\n  });\n\n  test('should handle en passant', async () => {\n    // Setup: Black pawn does double move\n    game.board[1][4] = { type: 'p', color: 'black' };\n    await moveController.executeMove({ r: 1, c: 4 }, { r: 3, c: 4 });\n\n    // White pawn positioned to capture en passant\n    game.board[3][3] = { type: 'p', color: 'white' };\n    game.turn = 'white';\n\n    // En passant capture\n    await moveController.executeMove({ r: 3, c: 3 }, { r: 2, c: 4 });\n\n    // White pawn should be at 2,4 and black pawn at 3,4 should be gone\n    expect(game.board[2][4]).not.toBeNull();\n    expect(game.board[2][4].type).toBe('p');\n    expect(game.board[3][4]).toBeNull();\n  });\n\n  test('should correctly undo en passant', async () => {\n    // Setup: Black pawn does double move\n    game.board[1][4] = { type: 'p', color: 'black' };\n    await moveController.executeMove({ r: 1, c: 4 }, { r: 3, c: 4 });\n\n    // White pawn positioned to capture en passant\n    game.board[3][3] = { type: 'p', color: 'white' };\n    game.turn = 'white';\n\n    // En passant capture\n    await moveController.executeMove({ r: 3, c: 3 }, { r: 2, c: 4 });\n\n    // Undo\n    moveController.undoMove();\n\n    // White pawn back at 3,3\n    expect(game.board[3][3]).not.toBeNull();\n    expect(game.board[3][3].type).toBe('p');\n\n    // Black pawn back at 3,4 (captured pawn restored)\n    expect(game.board[3][4]).not.toBeNull();\n    expect(game.board[3][4].type).toBe('p');\n    expect(game.board[3][4].color).toBe('black');\n\n    // Destination square empty\n    expect(game.board[2][4]).toBeNull();\n  });\n\n  test('should record move in history', async () => {\n    game.board[6][4] = { type: 'p', color: 'white' };\n    const initialHistoryLength = game.moveHistory.length;\n\n    await moveController.executeMove({ r: 6, c: 4 }, { r: 5, c: 4 });\n\n    expect(game.moveHistory.length).toBe(initialHistoryLength + 1);\n    expect(game.moveHistory[game.moveHistory.length - 1]).toMatchObject({\n      from: { r: 6, c: 4 },\n      to: { r: 5, c: 4 },\n    });\n  });\n\n  test('should handle redo move', async () => {\n    // Setup and execute a move\n    game.board[6][4] = { type: 'p', color: 'white' };\n    await moveController.executeMove({ r: 6, c: 4 }, { r: 5, c: 4 });\n\n    // Undo the move\n    moveController.undoMove();\n    expect(game.board[6][4]).not.toBeNull();\n    expect(game.board[5][4]).toBeNull();\n\n    // Redo the move\n    await moveController.redoMove();\n\n    // After redo, piece should be at the destination again\n    expect(game.board[5][4]).not.toBeNull();\n    expect(game.board[5][4].type).toBe('p');\n    expect(game.board[6][4]).toBeNull();\n  });\n\n  test('should clear redo stack when new move is made', async () => {\n    // Setup and execute a move\n    game.board[6][4] = { type: 'p', color: 'white' };\n    await moveController.executeMove({ r: 6, c: 4 }, { r: 5, c: 4 });\n\n    // Undo\n    moveController.undoMove();\n\n    // Make a different move (should clear redo stack)\n    game.board[6][3] = { type: 'p', color: 'white' };\n    await moveController.executeMove({ r: 6, c: 3 }, { r: 5, c: 3 });\n\n    // Redo should not work now\n    expect(moveController.redoStack.length).toBe(0);\n    const initialHistoryLength = game.moveHistory.length;\n    moveController.redoMove();\n    expect(game.moveHistory.length).toBe(initialHistoryLength);\n  });\n\n  test('should handle castling queenside', async () => {\n    // Setup: White King and Rook for queenside castling\n    game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n    game.board[8][0] = { type: 'r', color: 'white', hasMoved: false };\n\n    const from = { r: 8, c: 4 };\n    const to = { r: 8, c: 2 }; // Queenside castle\n\n    await moveController.executeMove(from, to);\n\n    // King should move to c1 (col 2), Rook to d1 (col 3)\n    expect(game.board[8][2]).not.toBeNull();\n    expect(game.board[8][2].type).toBe('k');\n    expect(game.board[8][3]).not.toBeNull();\n    expect(game.board[8][3].type).toBe('r');\n  });\n\n  test('should correctly undo queenside castling', async () => {\n    // Setup: White King and Rook for queenside castling\n    game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n    game.board[8][0] = { type: 'r', color: 'white', hasMoved: false };\n\n    const from = { r: 8, c: 4 };\n    const to = { r: 8, c: 2 }; // Queenside castle\n\n    await moveController.executeMove(from, to);\n    moveController.undoMove();\n\n    // King should be back at e1 (8, 4)\n    expect(game.board[8][4]).not.toBeNull();\n    expect(game.board[8][4].type).toBe('k');\n    expect(game.board[8][4].hasMoved).toBe(false);\n\n    // Rook should be back at a1 (8, 0)\n    expect(game.board[8][0]).not.toBeNull();\n    expect(game.board[8][0].type).toBe('r');\n    expect(game.board[8][0].hasMoved).toBe(false);\n\n    // Castling squares should be empty\n    expect(game.board[8][2]).toBeNull();\n    expect(game.board[8][3]).toBeNull();\n  });\n\n  test('should set hasMoved flag on pieces', async () => {\n    // Setup: fresh piece without hasMoved\n    game.board[6][4] = { type: 'p', color: 'white' };\n\n    await moveController.executeMove({ r: 6, c: 4 }, { r: 5, c: 4 });\n\n    // hasMoved should be set\n    expect(game.board[5][4].hasMoved).toBe(true);\n  });\n\n  test('should handle multiple undo operations', async () => {\n    // Execute 3 moves\n    game.board[6][4] = { type: 'p', color: 'white' };\n    await moveController.executeMove({ r: 6, c: 4 }, { r: 5, c: 4 });\n\n    game.board[1][4] = { type: 'p', color: 'black' };\n    await moveController.executeMove({ r: 1, c: 4 }, { r: 2, c: 4 });\n\n    game.board[5][4] = { type: 'p', color: 'white', hasMoved: true };\n    await moveController.executeMove({ r: 5, c: 4 }, { r: 4, c: 4 });\n\n    // Verify we have 3 moves in history\n    expect(game.moveHistory.length).toBeGreaterThanOrEqual(3);\n\n    // Undo all 3\n    moveController.undoMove();\n    moveController.undoMove();\n    moveController.undoMove();\n\n    // Should be back to initial state\n    expect(game.turn).toBe('white');  // Back to white's turn\n    expect(game.moveHistory.length).toBe(0); // All moves undone\n    // After all undos, the board should be cleared or back to original state\n  });\n\n  describe('handlePlayClick', () => {\n    test('should select own piece', () => {\n      game.board[4][4] = { type: 'p', color: 'white' };\n\n      moveController.handlePlayClick(4, 4);\n\n      expect(game.selectedSquare).toEqual({ r: 4, c: 4 });\n      expect(game.validMoves).toBeDefined();\n      expect(UI.renderBoard).toHaveBeenCalled();\n    });\n\n    test('should deselect when clicking empty square', () => {\n      game.selectedSquare = { r: 4, c: 4 };\n      game.validMoves = [{ r: 3, c: 4 }];\n\n      moveController.handlePlayClick(2, 2);\n\n      expect(game.selectedSquare).toBeNull();\n      expect(game.validMoves).toBeNull();\n    });\n\n    test('should switch selection when clicking different own piece', () => {\n      game.board[4][4] = { type: 'p', color: 'white' };\n      game.board[5][5] = { type: 'r', color: 'white' };\n      game.selectedSquare = { r: 4, c: 4 };\n\n      moveController.handlePlayClick(5, 5);\n\n      expect(game.selectedSquare).toEqual({ r: 5, c: 5 });\n    });\n\n    test('should show threats when clicking enemy piece', () => {\n      game.board[4][4] = { type: 'q', color: 'black' };\n\n      moveController.handlePlayClick(4, 4);\n\n      expect(game.selectedSquare).toEqual({ r: 4, c: 4 });\n      expect(game.validMoves).toBeDefined();\n    });\n  });\n\n  describe('Draw Conditions', () => {\n    test('should detect insufficient material (K vs K)', () => {\n      game.board = createEmptyBoard();\n      game.board[0][0] = { type: 'k', color: 'black' };\n      game.board[8][8] = { type: 'k', color: 'white' };\n\n      expect(moveController.isInsufficientMaterial()).toBe(true);\n    });\n\n    test('should detect insufficient material (K+N vs K)', () => {\n      game.board = createEmptyBoard();\n      game.board[0][0] = { type: 'k', color: 'black' };\n      game.board[8][8] = { type: 'k', color: 'white' };\n      game.board[7][7] = { type: 'n', color: 'white' };\n\n      expect(moveController.isInsufficientMaterial()).toBe(true);\n    });\n\n    test('should detect insufficient material (K+B vs K)', () => {\n      game.board = createEmptyBoard();\n      game.board[0][0] = { type: 'k', color: 'black' };\n      game.board[8][8] = { type: 'k', color: 'white' };\n      game.board[7][7] = { type: 'b', color: 'white' };\n\n      expect(moveController.isInsufficientMaterial()).toBe(true);\n    });\n\n    test('should NOT detect insufficient material with pawn', () => {\n      game.board = createEmptyBoard();\n      game.board[0][0] = { type: 'k', color: 'black' };\n      game.board[8][8] = { type: 'k', color: 'white' };\n      game.board[6][4] = { type: 'p', color: 'white' };\n\n      expect(moveController.isInsufficientMaterial()).toBe(false);\n    });\n  });\n\n  describe('Save and Load Game', () => {\n    test('should call localStorage.setItem when saving', () => {\n      moveController.saveGame();\n\n      expect(global.localStorage.setItem).toHaveBeenCalledWith(\n        'schach9x9_save_autosave',\n        expect.any(String)\n      );\n    });\n\n    test('should handle missing save data', () => {\n      // Ensure getItem returns null (already default, but explicit)\n      Storage.prototype.getItem.mockReturnValueOnce(null);\n\n      moveController.loadGame();\n\n      expect(game.log).toHaveBeenCalledWith(expect.stringContaining('gefunden'));\n    });\n\n    test('should successfully load a saved game', () => {\n      const savedState = {\n        board: createEmptyBoard(),\n        phase: PHASES.PLAY,\n        turn: 'black',\n        points: { white: 10, black: 10 },\n        moveHistory: [],\n        capturedPieces: { white: [], black: [] },\n        isAI: false,\n        difficulty: 'medium'\n      };\n\n      Storage.prototype.getItem.mockReturnValue(JSON.stringify(savedState));\n\n      // Verify mock works in test scope\n      console.log('Test Verify:', localStorage.getItem('schach9x9_save_autosave'));\n      // Explicitly mock getElementById for this test to avoid leakage issues\n      document.getElementById = jest.fn((id) => {\n        if (id === 'ai-toggle') return { checked: false, addEventListener: jest.fn() };\n        if (id === 'difficulty-select') return { value: 'medium', addEventListener: jest.fn() };\n        if (id === 'draw-offer-overlay') return { classList: { remove: jest.fn(), add: jest.fn() } };\n        if (id === 'move-history-panel') return { classList: { remove: jest.fn(), add: jest.fn() } };\n        if (id === 'captured-pieces-panel') return { classList: { remove: jest.fn(), add: jest.fn() } };\n        return {\n          classList: { remove: jest.fn(), add: jest.fn() },\n          style: {},\n          textContent: '',\n          value: '',\n          checked: false,\n          innerHTML: '',\n          addEventListener: jest.fn()\n        };\n      });\n\n      // Mock UI updates that are called during load\n      // UI.updateShopUI is already mocked globally\n\n      const errorSpy = jest.spyOn(console, 'error').mockImplementation(() => { });\n\n      moveController.loadGame();\n\n      if (errorSpy.mock.calls.length > 0) {\n        console.log('Load Error:', errorSpy.mock.calls[0]);\n      }\n      if (game.log.mock.calls.length > 0) {\n        // Check for error logs\n        const lastLog = game.log.mock.calls[game.log.mock.calls.length - 1][0];\n        if (lastLog.includes('Fehler')) {\n          console.log('Game Log Error:', lastLog);\n        }\n      }\n\n      expect(game.turn).toBe('black');\n      expect(game.phase).toBe(PHASES.PLAY);\n      expect(UI.renderBoard).toHaveBeenCalled();\n      expect(UI.updateStatus).toHaveBeenCalled();\n      expect(UI.updateShopUI).toHaveBeenCalled();\n\n      errorSpy.mockRestore();\n    });\n  });\n\n  describe('Material Calculation', () => {\n    test('should calculate material advantage correctly', () => {\n      game.board = createEmptyBoard();\n      game.board[0][0] = { type: 'k', color: 'black' };\n      game.board[8][8] = { type: 'k', color: 'white' };\n      game.board[7][7] = { type: 'q', color: 'white' }; // +9\n      game.board[0][4] = { type: 'r', color: 'black' }; // -5\n\n      const advantage = moveController.calculateMaterialAdvantage();\n\n      expect(advantage).toBe(4);\n    });\n\n    test('should return correct value for Angel piece', () => {\n      const angel = { type: 'e', color: 'white' };\n\n      expect(moveController.getMaterialValue(angel)).toBe(12);\n    });\n  });\n\n  describe('Replay Mode', () => {\n    beforeEach(() => {\n      // Mock replay-specific elements\n      document.getElementById = jest.fn((id) => {\n        if (id === 'replay-status' || id === 'replay-exit' || id === 'undo-btn') {\n          return {\n            classList: { remove: jest.fn(), add: jest.fn() },\n            disabled: false,\n            textContent: '',\n          };\n        }\n        return {\n          classList: { remove: jest.fn(), add: jest.fn() },\n          style: {},\n          textContent: '',\n          value: '',\n          checked: false,\n          disabled: false,\n          appendChild: jest.fn(),\n          scrollTop: 0,\n          scrollHeight: 100,\n          innerHTML: '',\n        };\n      });\n    });\n\n    test('should enter replay mode', async () => {\n      // Setup: Make a move so we have history\n      game.board[6][4] = { type: 'p', color: 'white' };\n      await moveController.executeMove({ r: 6, c: 4 }, { r: 5, c: 4 });\n\n      moveController.enterReplayMode();\n\n      expect(game.replayMode).toBe(true);\n      expect(game.replayPosition).toBe(0);\n      expect(game.stopClock).toHaveBeenCalled();\n      expect(game.savedGameState).toBeDefined();\n    });\n\n    test('should exit replay mode', async () => {\n      game.board[6][4] = { type: 'p', color: 'white' };\n      await moveController.executeMove({ r: 6, c: 4 }, { r: 5, c: 4 });\n      moveController.enterReplayMode();\n\n      moveController.exitReplayMode();\n\n      expect(game.replayMode).toBe(false);\n      expect(game.replayPosition).toBe(-1);\n      expect(game.savedGameState).toBeNull();\n    });\n\n    test('should navigate through replay', async () => {\n      // Setup: 3 moves\n      game.board[6][4] = { type: 'p', color: 'white' };\n      await moveController.executeMove({ r: 6, c: 4 }, { r: 5, c: 4 });\n\n      game.board[1][4] = { type: 'p', color: 'black' };\n      await moveController.executeMove({ r: 1, c: 4 }, { r: 2, c: 4 });\n\n      game.board[5][4] = { type: 'p', color: 'white', hasMoved: true };\n      await moveController.executeMove({ r: 5, c: 4 }, { r: 4, c: 4 });\n\n      moveController.enterReplayMode();\n      expect(game.replayPosition).toBe(2);\n\n      moveController.replayFirst();\n      expect(game.replayPosition).toBe(-1);\n\n      moveController.replayNext();\n      expect(game.replayPosition).toBe(0);\n\n      moveController.replayLast();\n      expect(game.replayPosition).toBe(2);\n\n      moveController.replayPrevious();\n      expect(game.replayPosition).toBe(1);\n    });\n  });\n\n  describe('Draw Detection', () => {\n    beforeEach(() => {\n      // Mock game-over overlay elements\n      document.getElementById = jest.fn((id) => {\n        if (id === 'game-over-overlay' || id === 'winner-text') {\n          return {\n            classList: { remove: jest.fn(), add: jest.fn() },\n            textContent: '',\n          };\n        }\n        return {\n          classList: { remove: jest.fn(), add: jest.fn() },\n          style: {},\n          textContent: '',\n          value: '',\n          checked: false,\n          disabled: false,\n          appendChild: jest.fn(),\n          scrollTop: 0,\n          scrollHeight: 100,\n          innerHTML: '',\n        };\n      });\n    });\n\n    test('should detect 50-move rule', () => {\n      game.halfMoveClock = 100;\n      const result = moveController.checkDraw();\n      expect(result).toBe(true);\n      expect(game.phase).toBe(PHASES.GAME_OVER);\n    });\n\n    test('should detect 3-fold repetition', () => {\n      game.positionHistory = ['hash1', 'hash2', 'hash1', 'hash3', 'hash1'];\n      moveController.getBoardHash = jest.fn(() => 'hash1');\n\n      const result = moveController.checkDraw();\n      expect(result).toBe(true);\n      expect(game.phase).toBe(PHASES.GAME_OVER);\n    });\n  });\n\n  describe('handlePlayClick EdgeCases', () => {\n    test('should deselect when clicking empty square with piece selected', () => {\n      game.board[6][0] = { type: 'p', color: 'white' };\n      game.turn = 'white';\n      moveController.handlePlayClick(6, 0);\n      expect(game.selectedSquare).toEqual({ r: 6, c: 0 });\n\n      moveController.handlePlayClick(5, 5); // empty square\n      expect(game.selectedSquare).toBeNull();\n    });\n\n    test('should switch selection between own pieces', () => {\n      game.board[6][0] = { type: 'p', color: 'white' };\n      game.board[6][1] = { type: 'p', color: 'white' };\n      game.turn = 'white';\n\n      moveController.handlePlayClick(6, 0);\n      const firstSelection = game.selectedSquare;\n\n      moveController.handlePlayClick(6, 1);\n      const secondSelection = game.selectedSquare;\n\n      expect(firstSelection).toEqual({ r: 6, c: 0 });\n      expect(secondSelection).toEqual({ r: 6, c: 1 });\n    });\n  });\n  describe('Coverage Improvements', () => {\n    test('enterReplayMode should do nothing if already in replay mode', () => {\n      game.moveHistory.push({ from: { r: 0, c: 0 }, to: { r: 1, c: 1 } }); // Ensure history is not empty\n      moveController.enterReplayMode();\n      const firstState = game.savedGameState;\n\n      moveController.enterReplayMode(); // Call again\n      expect(game.savedGameState).toBe(firstState); // Should be same object reference\n    });\n\n    test('enterReplayMode should do nothing if history is empty', () => {\n      game.moveHistory = [];\n      moveController.enterReplayMode();\n      expect(game.replayMode).toBeFalsy();\n    });\n\n    test('exitReplayMode should do nothing if not in replay mode', () => {\n      game.replayMode = false;\n      moveController.exitReplayMode();\n      expect(game.savedGameState).toBeNull(); // Should remain null\n    });\n\n    test('replay navigation functions should enter replay mode if not active', () => {\n      // Ensure history with valid move structure\n      game.moveHistory.push({\n        from: { r: 6, c: 4 },\n        to: { r: 5, c: 4 },\n        piece: { type: 'p', color: 'white', hasMoved: true }\n      });\n\n      // Mock board state for the move\n      game.board[5][4] = { type: 'p', color: 'white', hasMoved: true };\n\n      moveController.replayFirst();\n      expect(game.replayMode).toBe(true);\n      moveController.exitReplayMode();\n\n      moveController.replayPrevious();\n      expect(game.replayMode).toBe(true);\n      moveController.exitReplayMode();\n\n      moveController.replayNext();\n      expect(game.replayMode).toBe(true);\n      moveController.exitReplayMode();\n\n      moveController.replayLast();\n      expect(game.replayMode).toBe(true);\n      moveController.exitReplayMode();\n    });\n\n    test('undoMoveForReplay should handle castling', () => {\n      // Setup a move record for castling\n      const move = {\n        from: { r: 8, c: 4 },\n        to: { r: 8, c: 6 },\n        piece: { type: 'k', color: 'white', hasMoved: false },\n        specialMove: {\n          type: 'castling',\n          rookFrom: { r: 8, c: 8 },\n          rookTo: { r: 8, c: 5 },\n          rookHadMoved: false\n        }\n      };\n\n      // Setup board state AFTER castling\n      game.board[8][6] = { type: 'k', color: 'white', hasMoved: true };\n      game.board[8][5] = { type: 'r', color: 'white', hasMoved: true };\n      game.board[8][4] = null;\n      game.board[8][8] = null;\n\n      moveController.undoMoveForReplay(move);\n\n      // Verify board state restored\n      expect(game.board[8][4].type).toBe('k');\n      expect(game.board[8][8].type).toBe('r');\n      expect(game.board[8][6]).toBeNull();\n      expect(game.board[8][5]).toBeNull();\n    });\n\n    test('undoMoveForReplay should handle en passant', () => {\n      const move = {\n        from: { r: 3, c: 3 },\n        to: { r: 2, c: 4 },\n        piece: { type: 'p', color: 'white', hasMoved: true },\n        specialMove: {\n          type: 'enPassant',\n          capturedPawn: { type: 'p', color: 'black', hasMoved: true },\n          capturedPawnPos: { r: 3, c: 4 }\n        }\n      };\n\n      // Setup board state AFTER en passant\n      game.board[2][4] = { type: 'p', color: 'white', hasMoved: true };\n      game.board[3][3] = null;\n      game.board[3][4] = null; // Captured pawn is gone\n\n      moveController.undoMoveForReplay(move);\n\n      // Verify\n      expect(game.board[3][3].type).toBe('p'); // Mover back\n      expect(game.board[3][4].type).toBe('p'); // Captured back\n      expect(game.board[3][4].color).toBe('black');\n      expect(game.board[2][4]).toBeNull();\n    });\n\n    test('undoMoveForReplay should handle promotion', () => {\n      const move = {\n        from: { r: 1, c: 0 },\n        to: { r: 0, c: 0 },\n        piece: { type: 'e', color: 'white', hasMoved: true }, // Promoted piece\n        specialMove: {\n          type: 'promotion',\n          promotedTo: 'e'\n        }\n      };\n\n      // Setup board state AFTER promotion\n      game.board[0][0] = { type: 'e', color: 'white', hasMoved: true };\n      game.board[1][0] = null;\n\n      moveController.undoMoveForReplay(move);\n\n      // Verify\n      expect(game.board[1][0].type).toBe('p'); // Should be pawn again\n      expect(game.board[0][0]).toBeNull();\n    });\n\n    test('setTheme should update theme and localStorage', () => {\n      // Spy on the mock function directly\n      const setItemSpy = Storage.prototype.setItem;\n\n      // Mock document.body.setAttribute\n      document.body.setAttribute = jest.fn();\n\n      moveController.setTheme('dark-mode');\n\n      expect(game.currentTheme).toBe('dark-mode');\n      expect(document.body.setAttribute).toHaveBeenCalledWith('data-theme', 'dark-mode');\n      expect(setItemSpy).toHaveBeenCalledWith('chess_theme', 'dark-mode');\n    });\n  });\n\n  describe('handlePlayClick', () => {\n    test('should select own piece', () => {\n      game.board[6][4] = { type: 'p', color: 'white' };\n      game.turn = 'white';\n\n      moveController.handlePlayClick(6, 4);\n\n      expect(game.selectedSquare).toEqual({ r: 6, c: 4 });\n      expect(UI.renderBoard).toHaveBeenCalled();\n    });\n\n    test('should deselect when clicking empty square', () => {\n      game.selectedSquare = { r: 6, c: 4 };\n\n      moveController.handlePlayClick(5, 4); // Empty square\n\n      expect(game.selectedSquare).toBeNull();\n      expect(UI.renderBoard).toHaveBeenCalled();\n    });\n\n    test('should select enemy piece to show threats', () => {\n      game.board[1][4] = { type: 'p', color: 'black' };\n      game.turn = 'white';\n\n      moveController.handlePlayClick(1, 4);\n\n      expect(game.selectedSquare).toEqual({ r: 1, c: 4 });\n      expect(UI.renderBoard).toHaveBeenCalled();\n    });\n\n    test('should track player stats for valid move', () => {\n      game.board[6][4] = { type: 'p', color: 'white' };\n      game.turn = 'white';\n      game.selectedSquare = { r: 6, c: 4 };\n      game.validMoves = [{ r: 5, c: 4 }];\n      game.stats = { playerMoves: 0, playerBestMoves: 0 };\n\n      // Mock tutor move check\n      game.isTutorMove = jest.fn(() => true);\n\n      moveController.handlePlayClick(5, 4);\n\n      expect(game.stats.playerMoves).toBe(1);\n      expect(game.stats.playerBestMoves).toBe(1);\n    });\n  });\n\n  describe('executeMove Edge Cases', () => {\n    test('should detect checkmate', async () => {\n      game.board[6][4] = { type: 'p', color: 'white' };\n      game.isCheckmate = jest.fn(() => true);\n\n      await moveController.executeMove({ r: 6, c: 4 }, { r: 5, c: 4 });\n\n      expect(game.phase).toBe(PHASES.GAME_OVER);\n      // expect(game.winner).toBe('white'); // game.winner not set on object\n      expect(UI.animateCheckmate).toHaveBeenCalled();\n    });\n\n    test('should detect stalemate', async () => {\n      game.board[6][4] = { type: 'p', color: 'white' };\n      game.isCheckmate = jest.fn(() => false);\n      game.isStalemate = jest.fn(() => true);\n\n      await moveController.executeMove({ r: 6, c: 4 }, { r: 5, c: 4 });\n\n      expect(game.phase).toBe(PHASES.GAME_OVER);\n      expect(game.phase).toBe(PHASES.GAME_OVER);\n      // expect(game.isDraw).toBe(true); // Implementation does not set isDraw property\n      expect(UI.updateStatus).toHaveBeenCalled();\n    });\n\n    test('should trigger AI move if enabled', async () => {\n      jest.useFakeTimers();\n      game.board[6][4] = { type: 'p', color: 'white' };\n      game.isAI = true;\n      game.turn = 'white'; // Start with white, executeMove switches to black, triggering AI\n      game.aiMove = jest.fn();\n\n      await moveController.executeMove({ r: 6, c: 4 }, { r: 5, c: 4 });\n\n      jest.runAllTimers();\n\n      expect(game.aiMove).toHaveBeenCalled();\n      jest.useRealTimers();\n    });\n  });\n\n  describe('Undo/Redo Complex Scenarios', () => {\n    test('should undo and redo castling', async () => {\n      // Mock animateMove to avoid async issues/delays\n      moveController.animateMove = jest.fn().mockResolvedValue();\n\n      // Setup castling situation\n      game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n      game.board[8][8] = { type: 'r', color: 'white', hasMoved: false };\n      // Clear path\n      game.board[8][5] = null;\n      game.board[8][6] = null;\n      game.board[8][7] = null;\n\n      const from = { r: 8, c: 4 };\n      const to = { r: 8, c: 6 }; // Kingside castling target\n\n      await moveController.executeMove(from, to);\n\n      // Verify castling execution\n      expect(game.board[8][6].type).toBe('k');\n      expect(game.board[8][5].type).toBe('r');\n\n      // Undo\n      moveController.undoMove();\n\n      expect(game.board[8][4].type).toBe('k');\n      expect(game.board[8][8].type).toBe('r');\n      expect(game.board[8][6]).toBeNull();\n      expect(game.board[8][5]).toBeNull();\n\n      // Redo\n      await moveController.redoMove();\n\n      expect(game.board[8][6].type).toBe('k');\n      expect(game.board[8][5].type).toBe('r');\n    });\n\n    test('should undo and redo en passant', async () => {\n      // Mock animateMove\n      moveController.animateMove = jest.fn().mockResolvedValue();\n\n      // Setup en passant situation\n      game.board[3][4] = { type: 'p', color: 'white' };\n      game.board[3][3] = { type: 'p', color: 'black' };\n      game.lastMove = {\n        to: { r: 3, c: 3 },\n        piece: { type: 'p', color: 'black' },\n        isDoublePawnPush: true // Correct property name\n      };\n\n      const from = { r: 3, c: 4 };\n      const to = { r: 2, c: 3 }; // En passant capture square\n\n      await moveController.executeMove(from, to);\n\n      // Verify capture\n      expect(game.board[2][3].type).toBe('p');\n      expect(game.board[3][3]).toBeNull(); // Captured pawn gone\n\n      // Undo\n      moveController.undoMove();\n\n      expect(game.board[3][4].type).toBe('p'); // White pawn back\n      expect(game.board[3][3].type).toBe('p'); // Black pawn back\n      expect(game.board[2][3]).toBeNull();\n\n      // Redo\n      await moveController.redoMove();\n\n      expect(game.board[2][3].type).toBe('p');\n      expect(game.board[3][3]).toBeNull();\n    });\n  });\n\n  describe('Load Game', () => {\n    test('should load valid game state', () => {\n      const savedState = JSON.stringify({\n        board: game.board,\n        turn: 'black',\n        moveHistory: [],\n        capturedPieces: { white: [], black: [] },\n        phase: PHASES.PLAY\n      });\n      Storage.prototype.getItem.mockReturnValue(savedState);\n\n      const success = moveController.loadGame();\n\n      expect(success).toBe(true);\n      expect(game.turn).toBe('black');\n      expect(UI.renderBoard).toHaveBeenCalled();\n    });\n\n    test('should handle corrupt save data', () => {\n      Storage.prototype.getItem.mockReturnValue('invalid-json');\n\n      const success = moveController.loadGame();\n\n      expect(success).toBe(false);\n      expect(game.log).toHaveBeenCalledWith(expect.stringContaining('Fehler'));\n    });\n\n    test('should handle missing save data', () => {\n      Storage.prototype.getItem.mockReturnValue(null);\n\n      const success = moveController.loadGame();\n\n      expect(success).toBe(false);\n      expect(game.log).toHaveBeenCalledWith(expect.stringContaining('Kein gespeichertes Spiel'));\n    });\n  });\n\n  describe('Game Over and Special States', () => {\n    test('should handle checkmate', async () => {\n      game.isCheckmate = jest.fn(() => true);\n      game.turn = 'white';\n\n      game.board[6][4] = { type: 'p', color: 'white' };\n      await moveController.executeMove({ r: 6, c: 4 }, { r: 5, c: 4 });\n\n      expect(game.phase).toBe(PHASES.GAME_OVER);\n      expect(UI.animateCheckmate).toHaveBeenCalledWith(game, 'black');\n      expect(soundManager.playGameOver).toHaveBeenCalled();\n    });\n\n    test('should handle stalemate', async () => {\n      game.isStalemate = jest.fn(() => true);\n      game.turn = 'white';\n\n      game.board[6][4] = { type: 'p', color: 'white' };\n      await moveController.executeMove({ r: 6, c: 4 }, { r: 5, c: 4 });\n\n      expect(game.phase).toBe(PHASES.GAME_OVER);\n      expect(game.log).toHaveBeenCalledWith(expect.stringContaining('PATT'));\n    });\n\n    test('should generate consistent board hash', () => {\n      game.board[0][0] = { type: 'k', color: 'black' };\n      game.board[8][8] = { type: 'k', color: 'white' };\n\n      const hash1 = moveController.getBoardHash();\n      const hash2 = moveController.getBoardHash();\n      expect(hash1).toBe(hash2);\n\n      game.board[4][4] = { type: 'p', color: 'white' };\n      const hash3 = moveController.getBoardHash();\n      expect(hash1).not.toBe(hash3);\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/pieces3D.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'callback' is defined but never used. Allowed unused args must match /^_/u.","line":11,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\n\n// Comprehensive Three.js Mock\nconst mockThree = {\n  Group: jest.fn().mockImplementation(() => ({\n    add: jest.fn(),\n    remove: jest.fn(),\n    position: { set: jest.fn() },\n    rotation: { set: jest.fn() },\n    userData: {},\n    traverse: jest.fn((callback) => {\n      // No-op for now, or could simulate children\n    })\n  })),\n  Mesh: jest.fn().mockImplementation(() => ({\n    castShadow: false,\n    receiveShadow: false,\n    position: { set: jest.fn() },\n    rotation: { set: jest.fn(), x: 0, y: 0, z: 0 }\n  })),\n  Vector2: jest.fn().mockImplementation((x, y) => ({ x, y })),\n  LatheGeometry: jest.fn(),\n  BoxGeometry: jest.fn(),\n  CylinderGeometry: jest.fn(),\n  SphereGeometry: jest.fn(),\n  ConeGeometry: jest.fn(),\n  TorusGeometry: jest.fn(),\n  MeshStandardMaterial: jest.fn().mockImplementation((params) => params),\n  Color: jest.fn().mockImplementation((c) => ({ hex: c }))\n};\n\njest.unstable_mockModule('three', () => mockThree);\n\nconst { createPiece3D, SKIN_PRESETS } = await import('../js/pieces3D.js');\n\ndescribe('pieces3D Module', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  test('should create all standard piece types', () => {\n    const types = ['p', 'n', 'b', 'r', 'q', 'k', 'a', 'c', 'e'];\n    const colors = ['white', 'black'];\n\n    types.forEach(type => {\n      colors.forEach(color => {\n        const piece = createPiece3D(type, color);\n        expect(piece).toBeDefined();\n        expect(mockThree.Group).toHaveBeenCalled();\n      });\n    });\n  });\n\n  test('should apply different skin presets', () => {\n    const skins = Object.keys(SKIN_PRESETS);\n\n    skins.forEach(skin => {\n      const piece = createPiece3D('p', 'white', skin);\n      expect(piece).toBeDefined();\n    });\n  });\n\n  test('should handle unknown piece type gracefully', () => {\n    // Depending on implementation, it might return empty group or throw\n    // Based on outline, it seems to just call sub-functions. \n    // Let's see if it returns something for 'x'\n    const piece = createPiece3D('x', 'white');\n    expect(piece).toBeDefined();\n  });\n\n  describe('Piece specific generation', () => {\n    test('should create Archbishop (hybrid)', () => {\n      const piece = createPiece3D('a', 'white');\n      expect(piece).toBeDefined();\n    });\n\n    test('should create Chancellor (hybrid)', () => {\n      const piece = createPiece3D('c', 'white');\n      expect(piece).toBeDefined();\n    });\n\n    test('should create Angel', () => {\n      const piece = createPiece3D('e', 'white');\n      expect(piece).toBeDefined();\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/puzzle.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'jest' is defined but never used.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":14},{"ruleId":"no-unused-vars","severity":1,"message":"'PHASES' is defined but never used.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":16},{"ruleId":"no-unused-vars","severity":1,"message":"'BOARD_SIZE' is defined but never used.","line":4,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\nimport { PuzzleManager } from '../js/puzzleManager.js';\nimport { Game } from '../js/gameEngine.js';\nimport { PHASES, BOARD_SIZE } from '../js/gameEngine.js';\n\ndescribe('PuzzleMode', () => {\n  let puzzleManager;\n  let game;\n\n  beforeEach(() => {\n    puzzleManager = new PuzzleManager();\n    game = new Game(15, 'classic');\n  });\n\n  test('should load a puzzle correctly', () => {\n    const puzzle = puzzleManager.loadPuzzle(game, 0); // Load first puzzle (Mate in 1)\n\n    expect(puzzle).toBeDefined();\n    expect(game.mode).toBe('puzzle');\n    expect(game.puzzleState.active).toBe(true);\n\n    // New Puzzle 1: White King at 2,2; Black King at 0,2; White Rook at 1,7\n    expect(game.board[2][2].type).toBe('k');\n    expect(game.board[0][2].type).toBe('k');\n    expect(game.board[1][7].type).toBe('r');\n  });\n\n  test('should validate correct move', () => {\n    puzzleManager.loadPuzzle(game, 0); // Mate in 1\n\n    // Correct move: R(1,7) -> R(0,7)\n    const move = {\n      from: { r: 1, c: 7 },\n      to: { r: 0, c: 7 }\n    };\n\n    const result = puzzleManager.checkMove(game, move);\n    expect(result).toBe('solved');\n    expect(game.puzzleState.solved).toBe(true);\n  });\n\n  test('should reject wrong move', () => {\n    puzzleManager.loadPuzzle(game, 0);\n\n    // Wrong move: R(1,7) -> R(1,6)\n    const move = {\n      from: { r: 1, c: 7 },\n      to: { r: 1, c: 6 }\n    };\n\n    const result = puzzleManager.checkMove(game, move);\n    expect(result).toBe('wrong');\n    expect(game.puzzleState.solved).toBe(false);\n  });\n\n  test('should handle multi-step puzzles', () => {\n    puzzleManager.loadPuzzle(game, 1); // Mate in 2\n\n    // Move 1: R(6,4) -> R(1,4)\n    const move1 = {\n      from: { r: 6, c: 4 },\n      to: { r: 1, c: 4 }\n    };\n\n    const result1 = puzzleManager.checkMove(game, move1);\n    expect(result1).toBe('continue');\n    expect(game.puzzleState.currentMoveIndex).toBe(1);\n\n    // Move 2: R(2,0) -> R(0,0)\n    const move2 = {\n      from: { r: 2, c: 0 },\n      to: { r: 0, c: 0 }\n    };\n\n    const result2 = puzzleManager.checkMove(game, move2);\n    expect(result2).toBe('solved');\n    expect(game.puzzleState.solved).toBe(true);\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/puzzleGenerator.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'BOARD_SIZE' is defined but never used.","line":2,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PuzzleGenerator } from '../js/puzzleGenerator.js';\nimport { createEmptyBoard, BOARD_SIZE } from '../js/gameEngine.js';\n\ndescribe('PuzzleGenerator', () => {\n  test('boardToString and stringToBoard should be inverse', () => {\n    const board = createEmptyBoard();\n    board[4][4] = { type: 'k', color: 'white' };\n    board[0][0] = { type: 'r', color: 'black' };\n    const turn = 'white';\n\n    const str = PuzzleGenerator.boardToString(board, turn);\n    const { board: newBoard, turn: newTurn } = PuzzleGenerator.stringToBoard(str);\n\n    expect(newTurn).toBe(turn);\n    expect(newBoard[4][4].type).toBe('k');\n    expect(newBoard[4][4].color).toBe('white');\n    expect(newBoard[0][0].type).toBe('r');\n    expect(newBoard[0][0].color).toBe('black');\n  });\n\n  test('should find Mate in 1', () => {\n    const board = createEmptyBoard();\n    // White King at 2,2 (covers 1,1; 1,2; 1,3)\n    // Black King at 0,2\n    // White Rook at 1,7\n    // White to move: Rook to 0,7 is mate\n    board[2][2] = { type: 'k', color: 'white', hasMoved: true };\n    board[0][2] = { type: 'k', color: 'black', hasMoved: true };\n    board[1][7] = { type: 'r', color: 'white', hasMoved: true };\n\n    const solution = PuzzleGenerator.findMateSequence(board, 'white', 1);\n    expect(solution).not.toBeNull();\n    expect(solution.length).toBe(1);\n    expect(solution[0]).toEqual({\n      from: { r: 1, c: 7 },\n      to: { r: 0, c: 7 }\n    });\n  });\n\n  test('should find Mate in 2', () => {\n    const board = createEmptyBoard();\n    // Mate in 2: White Rooks at 6,4 and 2,4. Black King at 0,4.\n    // Step 1: R(6,4)->R(1,4) Check.\n    // Step 2: Black King must move (if can) or blocked.\n    // If Black King at 0,4 is trapped by White King at 2,4.\n\n    board[2][4] = { type: 'k', color: 'white', hasMoved: true };\n    board[6][4] = { type: 'r', color: 'white', hasMoved: true };\n    board[0][4] = { type: 'k', color: 'black', hasMoved: true };\n    board[5][0] = { type: 'r', color: 'white', hasMoved: true }; // Extra piece to avoid draw\n\n    const solution = PuzzleGenerator.findMateSequence(board, 'white', 2);\n    expect(solution).not.toBeNull();\n    // Mate in 2 means 3 plys: W1, B1, W2\n    expect(solution.length).toBeGreaterThanOrEqual(1);\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/repro_bug.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'PHASES' is defined but never used.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":16},{"ruleId":"no-unused-vars","severity":1,"message":"'BOARD_SIZE' is defined but never used.","line":3,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":28},{"ruleId":"no-unused-vars","severity":1,"message":"'id' is defined but never used. Allowed unused args must match /^_/u.","line":36,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":30},{"ruleId":"no-unused-vars","severity":1,"message":"'UI' is assigned a value but never used.","line":63,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":63,"endColumn":9}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\nimport { Game, createEmptyBoard } from '../js/gameEngine.js';\nimport { PHASES, BOARD_SIZE } from '../js/config.js';\n\n// Mock UI and SoundManager modules\njest.unstable_mockModule('../js/ui.js', () => ({\n  renderBoard: jest.fn(), showModal: jest.fn(),\n  showPromotionModal: jest.fn(),\n  showPromotionUI: jest.fn(),\n  animateMove: jest.fn().mockResolvedValue(),\n  animateCheck: jest.fn(),\n  animateCheckmate: jest.fn(),\n  updateStatistics: jest.fn(),\n  updateMoveHistoryUI: jest.fn(),\n  updateCapturedUI: jest.fn(),\n  updateStatus: jest.fn(),\n  updateClockDisplay: jest.fn(),\n  updateClockUI: jest.fn(),\n  showShop: jest.fn(),\n  updateShopUI: jest.fn(),\n  renderEvalGraph: jest.fn(),\n}));\n\njest.unstable_mockModule('../js/sounds.js', () => ({\n  soundManager: {\n    playMove: jest.fn(),\n    playCapture: jest.fn(),\n    playCheck: jest.fn(),\n    playCheckmate: jest.fn(),\n    playGameOver: jest.fn(),\n  },\n}));\n\n// Mock document functions used in MoveController\nglobal.document = {\n  getElementById: jest.fn((id) => ({\n    classList: { remove: jest.fn(), add: jest.fn() },\n    style: {},\n    textContent: '',\n    value: '',\n    checked: false,\n    disabled: false,\n    appendChild: jest.fn(),\n    scrollTop: 0,\n    scrollHeight: 100,\n    innerHTML: '',\n  })),\n};\n\n// Mock localStorage with proper jest functions\nglobal.localStorage = {\n  getItem: jest.fn(() => null),\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n  clear: jest.fn(),\n};\n\n// Mock alert\nglobal.alert = jest.fn();\n\n// Import MoveController AFTER mocking\nconst { MoveController } = await import('../js/moveController.js');\nconst UI = await import('../js/ui.js');\n\ndescribe('Bug Reproduction: Rook transforming into King', () => {\n  let game;\n  let moveController;\n\n  beforeEach(() => {\n    game = new Game(15, 'classic'); // Use Classic Mode\n    // Ensure board is set up for classic mode\n    // Game constructor calls setupClassicBoard if mode is classic\n\n    moveController = new MoveController(game);\n    game.moveController = moveController;\n    game.log = jest.fn();\n    game.stopClock = jest.fn();\n    game.startClock = jest.fn();\n    game.updateBestMoves = jest.fn();\n\n    jest.clearAllMocks();\n  });\n\n  test('should correctly undo kingside castling without transforming rook', async () => {\n    // Clear board to set up specific castling scenario\n    game.board = createEmptyBoard();\n\n    // Place Black King to avoid game over\n    game.board[0][4] = { type: 'k', color: 'black', hasMoved: false };\n\n    // White King at e1 (8, 4)\n    game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n    // White Rook at i1 (8, 8)\n    game.board[8][8] = { type: 'r', color: 'white', hasMoved: false };\n\n    const from = { r: 8, c: 4 };\n    const to = { r: 8, c: 6 }; // Kingside castle\n\n    // Execute castling\n    await moveController.executeMove(from, to);\n\n    // Verify castling happened\n    expect(game.board[8][6].type).toBe('k'); // King moved\n    expect(game.board[8][5].type).toBe('r'); // Rook moved\n    expect(game.board[8][4]).toBeNull();\n    expect(game.board[8][8]).toBeNull();\n\n    // Undo castling\n    moveController.undoMove();\n\n    // Verify restoration\n    expect(game.board[8][4]).not.toBeNull();\n    expect(game.board[8][4].type).toBe('k'); // King back\n\n    expect(game.board[8][8]).not.toBeNull();\n    expect(game.board[8][8].type).toBe('r'); // Rook back - THIS IS THE CRITICAL CHECK\n\n    expect(game.board[8][6]).toBeNull();\n    expect(game.board[8][5]).toBeNull();\n  });\n\n  test('should correctly undo queenside castling without transforming rook', async () => {\n    // Clear board\n    game.board = createEmptyBoard();\n\n    // Place Black King to avoid game over\n    game.board[0][4] = { type: 'k', color: 'black', hasMoved: false };\n\n    // White King at e1 (8, 4)\n    game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n    // White Rook at a1 (8, 0)\n    game.board[8][0] = { type: 'r', color: 'white', hasMoved: false };\n\n    const from = { r: 8, c: 4 };\n    const to = { r: 8, c: 2 }; // Queenside castle\n\n    // Execute castling\n    await moveController.executeMove(from, to);\n\n    // Verify castling happened\n    expect(game.board[8][2].type).toBe('k'); // King moved\n    expect(game.board[8][3].type).toBe('r'); // Rook moved\n\n    // Undo castling\n    moveController.undoMove();\n\n    // Verify restoration\n    expect(game.board[8][4].type).toBe('k'); // King back\n    expect(game.board[8][0].type).toBe('r'); // Rook back - CRITICAL CHECK\n  });\n\n  test('should correctly undo normal rook move', async () => {\n    // Clear board\n    game.board = createEmptyBoard();\n\n    // Place Kings to avoid game over\n    game.board[0][4] = { type: 'k', color: 'black', hasMoved: false };\n    game.board[8][4] = { type: 'k', color: 'white', hasMoved: false };\n\n    // White Rook at a1 (8, 0)\n    game.board[8][0] = { type: 'r', color: 'white', hasMoved: false };\n\n    const from = { r: 8, c: 0 };\n    const to = { r: 7, c: 0 };\n\n    // Execute move\n    await moveController.executeMove(from, to);\n\n    expect(game.board[7][0].type).toBe('r');\n\n    // Undo move\n    moveController.undoMove();\n\n    expect(game.board[8][0].type).toBe('r');\n    expect(game.board[7][0]).toBeNull();\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/shop.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'createEmptyBoard' is defined but never used.","line":2,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":32},{"ruleId":"no-unused-vars","severity":1,"message":"'PIECE_VALUES' is defined but never used.","line":3,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":30},{"ruleId":"no-unused-vars","severity":1,"message":"'id' is defined but never used. Allowed unused args must match /^_/u.","line":23,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":30},{"ruleId":"no-unused-vars","severity":1,"message":"'UI' is assigned a value but never used.","line":41,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":41,"endColumn":9},{"ruleId":"no-unused-vars","severity":1,"message":"'aiController' is assigned a value but never used.","line":202,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":202,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\nimport { Game, createEmptyBoard } from '../js/gameEngine.js';\nimport { PHASES, PIECE_VALUES } from '../js/config.js';\n\n// Mock UI module\njest.unstable_mockModule('../js/ui.js', () => ({\n  renderBoard: jest.fn(), showModal: jest.fn(),\n  updateShopUI: jest.fn(),\n  updateStatus: jest.fn(),\n  renderEvalGraph: jest.fn(),\n}));\n\n// Mock sounds module\njest.unstable_mockModule('../js/sounds.js', () => ({\n  soundManager: {\n    playMove: jest.fn(),\n    init: jest.fn(),\n  },\n}));\n\n// Mock DOM\nglobal.document = {\n  getElementById: jest.fn((id) => ({\n    classList: { remove: jest.fn(), add: jest.fn() },\n    style: {},\n    textContent: '',\n    value: '',\n    checked: false,\n    disabled: false,\n    appendChild: jest.fn(),\n    scrollTop: 0,\n    scrollHeight: 100,\n    innerHTML: '',\n  })),\n  querySelectorAll: jest.fn(() => []),\n  querySelector: jest.fn(() => null),\n};\n\n// Import after mocking\nconst { GameController } = await import('../js/gameController.js');\nconst UI = await import('../js/ui.js');\n\ndescribe('Shop System', () => {\n  let game;\n  let gameController;\n\n  beforeEach(() => {\n    game = new Game(15, 'setup', false); // 15 points, setup mode, no AI\n    gameController = new GameController(game);\n    game.gameController = gameController;\n    game.log = jest.fn();\n\n    // Set up corridors for testing\n    game.whiteCorridor = { rowStart: 6, colStart: 0 };\n    game.blackCorridor = { rowStart: 0, colStart: 0 };\n\n    jest.clearAllMocks();\n  });\n\n  describe('Point Deduction', () => {\n    test('should deduct correct points when placing a pawn', () => {\n      game.phase = PHASES.SETUP_WHITE_PIECES;\n      game.points = 15;\n      game.selectedShopPiece = 'p';\n\n      gameController.placeShopPiece(6, 0);\n\n      expect(game.points).toBe(14); // 15 - 1 = 14\n      expect(game.board[6][0]).toEqual({ type: 'p', color: 'white', hasMoved: false });\n    });\n\n    test('should deduct correct points when placing a queen', () => {\n      game.phase = PHASES.SETUP_WHITE_PIECES;\n      game.points = 15;\n      game.selectedShopPiece = 'q';\n\n      gameController.placeShopPiece(6, 0);\n\n      expect(game.points).toBe(6); // 15 - 9 = 6\n      expect(game.board[6][0]).toEqual({ type: 'q', color: 'white', hasMoved: false });\n    });\n\n    test('should deduct correct points for Angel piece', () => {\n      game.phase = PHASES.SETUP_WHITE_PIECES;\n      game.points = 15;\n      game.selectedShopPiece = 'e';\n\n      gameController.placeShopPiece(6, 0);\n\n      expect(game.points).toBe(3); // 15 - 12 = 3\n      expect(game.board[6][0]).toEqual({ type: 'e', color: 'white', hasMoved: false });\n    });\n\n    test('should NOT place piece if insufficient points', () => {\n      game.phase = PHASES.SETUP_WHITE_PIECES;\n      game.points = 5;\n      game.selectedShopPiece = 'q'; // Costs 9\n\n      gameController.placeShopPiece(6, 0);\n\n      expect(game.points).toBe(5); // No change\n      expect(game.board[6][0]).toBeNull(); // Not placed\n    });\n\n    test('should allow multiple purchases with remaining points', () => {\n      game.phase = PHASES.SETUP_WHITE_PIECES;\n      game.points = 15;\n\n      // Buy a rook (5 points)\n      game.selectedShopPiece = 'r';\n      gameController.placeShopPiece(6, 0);\n      expect(game.points).toBe(10);\n\n      // Buy a knight (3 points)\n      game.selectedShopPiece = 'n';\n      gameController.placeShopPiece(6, 1);\n      expect(game.points).toBe(7);\n\n      // Buy a bishop (3 points)\n      game.selectedShopPiece = 'b';\n      gameController.placeShopPiece(6, 2);\n      expect(game.points).toBe(4);\n    });\n  });\n\n  describe('Piece Placement Validation', () => {\n    test('should only allow placement in own corridor', () => {\n      game.phase = PHASES.SETUP_WHITE_PIECES;\n      game.points = 15;\n      game.selectedShopPiece = 'p';\n\n      // Try to place outside corridor (row 0 is black's corridor)\n      gameController.placeShopPiece(0, 0);\n\n      expect(game.board[0][0]).toBeNull();\n      expect(game.points).toBe(15); // No points deducted\n      expect(game.log).toHaveBeenCalledWith('Muss im eigenen Korridor platziert werden!');\n    });\n\n    test('should NOT allow placement on occupied square', () => {\n      game.phase = PHASES.SETUP_WHITE_PIECES;\n      game.points = 15;\n      game.board[6][0] = { type: 'r', color: 'white', hasMoved: false };\n      game.selectedShopPiece = 'p';\n\n      gameController.placeShopPiece(6, 0);\n\n      expect(game.board[6][0].type).toBe('r'); // Still a rook\n      expect(game.points).toBe(15); // No points deducted\n      expect(game.log).toHaveBeenCalledWith('Feld besetzt!');\n    });\n\n    test('should place piece for black during black setup phase', () => {\n      game.phase = PHASES.SETUP_BLACK_PIECES;\n      game.points = 15;\n      game.selectedShopPiece = 'n';\n\n      gameController.placeShopPiece(0, 0);\n\n      expect(game.board[0][0]).toEqual({ type: 'n', color: 'black', hasMoved: false });\n      expect(game.points).toBe(12); // 15 - 3 = 12\n    });\n  });\n\n  describe('Piece Removal and Refund', () => {\n    // Note: Refund test skipped due to complex PIECES symbol lookup in gameController\n    test('should refund points when removing own piece', () => {\n      game.phase = PHASES.SETUP_WHITE_PIECES;\n      game.points = 10;\n      game.board[6][0] = { type: 'r', color: 'white', hasMoved: false };\n      game.selectedShopPiece = null; // No piece selected (removal mode)\n\n      gameController.placeShopPiece(6, 0);\n\n      // The piece should be removed\n      expect(game.board[6][0]).toBeNull();\n      // Points should be refunded (rook costs 5)\n      expect(game.points).toBe(15); // 10 + 5 = 15\n    });\n\n    test('should NOT remove king piece', () => {\n      game.phase = PHASES.SETUP_WHITE_PIECES;\n      game.points = 10;\n      game.board[6][0] = { type: 'k', color: 'white', hasMoved: false };\n      game.selectedShopPiece = null;\n\n      gameController.placeShopPiece(6, 0);\n\n      expect(game.board[6][0]).not.toBeNull(); // King still there\n      expect(game.board[6][0].type).toBe('k');\n      expect(game.points).toBe(10); // No refund\n    });\n  });\n\n  describe('AI Purchase Logic', () => {\n    test('should use correct piece symbols when purchasing', () => {\n      game.phase = PHASES.SETUP_BLACK_PIECES;\n      game.points = 15;\n      game.isAI = true;\n\n      // Mock AI controller\n      const aiController = {\n        game: game,\n      };\n\n      // Manually set the piece using the symbol (simulating fixed AI logic)\n      game.selectedShopPiece = 'q'; // Should be symbol, not 'QUEEN'\n\n      gameController.placeShopPiece(0, 0);\n\n      expect(game.board[0][0].type).toBe('q');\n      expect(game.points).toBe(6); // 15 - 9 = 6\n    });\n\n    test('AI should stay within point budget', () => {\n      game.points = 4; // Only enough for bishop/knight or pawn\n      game.phase = PHASES.SETUP_BLACK_PIECES;\n      game.selectedShopPiece = 'q'; // Costs 9, too expensive\n\n      gameController.placeShopPiece(0, 0);\n\n      expect(game.board[0][0]).toBeNull(); // Should not place\n      expect(game.points).toBe(4); // No change\n    });\n  });\n\n  describe('Selection Logic', () => {\n    test('should not select piece if cost exceeds points', () => {\n      game.points = 5;\n\n      gameController.selectShopPiece('q'); // Costs 9\n\n      expect(game.selectedShopPiece).not.toBe('q'); // Should not be set to q\n      expect(game.log).toHaveBeenCalledWith('Nicht genug Punkte!');\n    });\n\n    test('should select piece if cost is affordable', () => {\n      game.points = 15;\n\n      // Mock querySelector to return a proper button element\n      const mockButton = { classList: { add: jest.fn(), remove: jest.fn() } };\n      document.querySelector = jest.fn(() => mockButton);\n      document.querySelectorAll = jest.fn(() => [\n        { classList: { remove: jest.fn() } },\n        { classList: { remove: jest.fn() } }\n      ]);\n      document.getElementById = jest.fn(() => ({\n        innerHTML: '',\n        style: {}\n      }));\n\n      gameController.selectShopPiece('q');\n\n      expect(game.selectedShopPiece).toBe('q');\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/sounds.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/statistics.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'gameId' is assigned a value but never used.","line":112,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":112,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\n\n// Mock logger\njest.unstable_mockModule('../js/logger.js', () => ({\n  logger: {\n    info: jest.fn(),\n    error: jest.fn(),\n    debug: jest.fn(),\n    warn: jest.fn()\n  }\n}));\n\nconst { StatisticsManager } = await import('../js/statisticsManager.js');\n\ndescribe('StatisticsManager', () => {\n  let stats;\n  let localStorageMock;\n\n  beforeEach(() => {\n    localStorageMock = {\n      getItem: jest.fn(),\n      setItem: jest.fn(),\n      removeItem: jest.fn(),\n      clear: jest.fn(),\n    };\n    Object.defineProperty(global, 'localStorage', { value: localStorageMock, writable: true });\n\n    jest.clearAllMocks();\n    stats = new StatisticsManager();\n  });\n\n  test('should initialize with default structure if storage is empty', () => {\n    expect(stats.data.games).toEqual([]);\n    expect(stats.data.stats.totalGames).toBe(0);\n  });\n\n  test('should load existing data from storage', () => {\n    const mockData = {\n      games: [{ id: '1', result: 'win' }],\n      stats: { totalGames: 1, wins: 1, losses: 0, draws: 0, winRate: 1 }\n    };\n    localStorageMock.getItem.mockReturnValue(JSON.stringify(mockData));\n\n    const newStats = new StatisticsManager();\n    expect(newStats.data.games.length).toBe(1);\n    expect(newStats.data.stats.wins).toBe(1);\n  });\n\n  test('saveGame should append game and update stats', () => {\n    const gameData = {\n      result: 'win',\n      playerColor: 'white',\n      opponent: 'AI-Level1',\n      moveHistory: [{}, {}, {}],\n      duration: 120000,\n      finalPosition: 'fen-string'\n    };\n\n    stats.saveGame(gameData);\n\n    expect(stats.data.games.length).toBe(1);\n    expect(stats.data.stats.totalGames).toBe(1);\n    expect(stats.data.stats.wins).toBe(1);\n    expect(stats.data.stats.winRate).toBe(1);\n    expect(localStorageMock.setItem).toHaveBeenCalled();\n  });\n\n  test('getStatistics should return a copy of stats', () => {\n    const currentStats = stats.getStatistics();\n    expect(currentStats).toEqual(stats.data.stats);\n    expect(currentStats).not.toBe(stats.data.stats); // Verify it's a copy\n  });\n\n  test('getGameHistory should filter and sort games', () => {\n    stats.data.games = [\n      { id: '1', result: 'win', opponent: 'AI-Expert', date: '2023-01-01T10:00:00Z' },\n      { id: '2', result: 'loss', opponent: 'AI-Beginner', date: '2023-01-02T10:00:00Z' }\n    ];\n\n    const winGames = stats.getGameHistory({ result: 'win' });\n    expect(winGames.length).toBe(1);\n    expect(winGames[0].id).toBe('1');\n\n    const beginnerGames = stats.getGameHistory({ opponent: 'Beginner' });\n    expect(beginnerGames.length).toBe(1);\n    expect(beginnerGames[0].id).toBe('2');\n\n    const limited = stats.getGameHistory({ limit: 1 });\n    expect(limited.length).toBe(1);\n    expect(limited[0].id).toBe('2'); // Sorted newest first\n  });\n\n  test('getGameById should return game or null', () => {\n    stats.data.games = [{ id: 'test-id', result: 'win' }];\n    expect(stats.getGameById('test-id')).toBeDefined();\n    expect(stats.getGameById('nothing')).toBeNull();\n  });\n\n  test('exportGames and importGames should work together', () => {\n    stats.saveGame({ result: 'win', opponent: 'AI' });\n    const exported = stats.exportGames();\n\n    const newStats = new StatisticsManager();\n    newStats.importGames(exported, false); // Replace\n\n    expect(newStats.data.games.length).toBe(1);\n    expect(newStats.data.stats.wins).toBe(1);\n  });\n\n  test('importGames with merge should avoid duplicates', () => {\n    stats.saveGame({ result: 'win', opponent: 'Alpha' });\n    const gameId = stats.data.games[0].id;\n    const exported = stats.exportGames();\n\n    // Add another game to current stats\n    stats.saveGame({ result: 'loss', opponent: 'Beta' });\n\n    // Import the first game again with merge\n    stats.importGames(exported, true);\n\n    expect(stats.data.games.length).toBe(2); // Still 2, not 3 (no duplicate for Alpha)\n  });\n\n  test('importGames should handle invalid JSON', () => {\n    const success = stats.importGames('invalid-json');\n    expect(success).toBe(false);\n  });\n\n  test('recalculateStats should handle losses', () => {\n    stats.data.games = [{ result: 'loss' }];\n    stats.recalculateStats();\n    expect(stats.data.stats.losses).toBe(1);\n  });\n\n  test('clearHistory should reset data', () => {\n    stats.saveGame({ result: 'win' });\n    stats.clearHistory(true);\n    expect(stats.data.games.length).toBe(0);\n    expect(stats.data.stats.totalGames).toBe(0);\n  });\n\n  test('clearHistory should require confirmation', () => {\n    stats.saveGame({ result: 'win' });\n    stats.clearHistory(false);\n    expect(stats.data.games.length).toBe(1);\n  });\n\n  test('getRecentStats should return stats for specified period', () => {\n    const now = new Date();\n    const oldDate = new Date();\n    oldDate.setDate(now.getDate() - 40);\n\n    stats.data.games = [\n      { result: 'win', date: now.toISOString() },\n      { result: 'loss', date: oldDate.toISOString() }\n    ];\n\n    const recent = stats.getRecentStats(30);\n    expect(recent.totalGames).toBe(1);\n    expect(recent.wins).toBe(1);\n  });\n\n  test('getStatsByOpponent should group correctly', () => {\n    stats.data.games = [\n      { result: 'win', opponent: 'AI-1' },\n      { result: 'loss', opponent: 'AI-1' },\n      { result: 'draw', opponent: 'AI-2' }\n    ];\n\n    const byOpponent = stats.getStatsByOpponent();\n    expect(byOpponent['AI-1'].totalGames).toBe(2);\n    expect(byOpponent['AI-2'].totalGames).toBe(1);\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/statisticsManager.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/storage.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'BOARD_SIZE' is defined but never used.","line":3,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\nimport { StorageManager } from '../js/storage.js';\nimport { PHASES, BOARD_SIZE } from '../js/gameEngine.js';\n\n// Mock localStorage\nconst localStorageMock = (function () {\n  let store = {};\n  return {\n    getItem: jest.fn((key) => store[key] || null),\n    setItem: jest.fn((key, value) => { store[key] = value.toString(); }),\n    removeItem: jest.fn((key) => { delete store[key]; }),\n    clear: jest.fn(() => { store = {}; })\n  };\n})();\n\nObject.defineProperty(global, 'localStorage', { value: localStorageMock });\n\ndescribe('StorageManager', () => {\n  let storageManager;\n  let mockGame;\n\n  beforeEach(() => {\n    storageManager = new StorageManager();\n    localStorage.clear();\n    jest.clearAllMocks();\n\n    mockGame = {\n      mode: 'classic',\n      difficulty: 'medium',\n      isAI: true,\n      board: Array(9).fill(Array(9).fill(null)),\n      turn: 'white',\n      phase: PHASES.PLAY,\n      points: 0,\n      moveHistory: [{ from: { r: 1, c: 1 }, to: { r: 3, c: 1 } }],\n      capturedPieces: { white: [], black: ['p'] },\n      whiteTime: 300,\n      blackTime: 300,\n      clockEnabled: true,\n      lastMove: { from: { r: 1, c: 1 }, to: { r: 3, c: 1 } }\n    };\n  });\n\n  test('should save game state correctly', () => {\n    const result = storageManager.saveGame(mockGame, 'test-slot');\n    expect(result).toBe(true);\n    expect(localStorage.setItem).toHaveBeenCalled();\n\n    const saveKey = 'schach9x9_save_test-slot';\n    const savedData = JSON.parse(localStorage.getItem(saveKey));\n\n    expect(savedData.mode).toBe('classic');\n    expect(savedData.turn).toBe('white');\n    expect(savedData.moveHistory).toHaveLength(1);\n    expect(savedData.capturedPieces.black).toContain('p');\n  });\n\n  test('should load game state correctly', () => {\n    storageManager.saveGame(mockGame, 'test-slot');\n    const loadedState = storageManager.loadGame('test-slot');\n\n    expect(loadedState).not.toBeNull();\n    expect(loadedState.mode).toBe('classic');\n    expect(loadedState.turn).toBe('white');\n  });\n\n  test('should return null if no save exists', () => {\n    const loadedState = storageManager.loadGame('non-existent');\n    expect(loadedState).toBeNull();\n  });\n\n  test('should check if save exists', () => {\n    expect(storageManager.hasSave('test-slot')).toBe(false);\n    storageManager.saveGame(mockGame, 'test-slot');\n    expect(storageManager.hasSave('test-slot')).toBe(true);\n  });\n\n  test('should load state into game object', () => {\n    storageManager.saveGame(mockGame, 'test-slot');\n    const loadedState = storageManager.loadGame('test-slot');\n\n    const targetGame = {};\n    const success = storageManager.loadStateIntoGame(targetGame, loadedState);\n\n    expect(success).toBe(true);\n    expect(targetGame.mode).toBe('classic');\n    expect(targetGame.moveHistory).toHaveLength(1);\n    expect(targetGame.capturedPieces.black).toEqual(['p']);\n    expect(targetGame.points).toBe(0);\n  });\n\n  test('should handle autosave default slot', () => {\n    storageManager.saveGame(mockGame); // Default is 'autosave'\n    expect(localStorage.setItem).toHaveBeenCalledWith(\n      expect.stringContaining('autosave'),\n      expect.any(String)\n    );\n    expect(storageManager.hasSave('autosave')).toBe(true);\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/tutorController.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/tutorial.full.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/tutorial.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/ui.advanced.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'BOARD_SIZE' is defined but never used.","line":2,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\nimport { PHASES, BOARD_SIZE } from '../js/config.js';\n\n// Mock dependencies\njest.unstable_mockModule('../js/utils.js', () => ({\n  debounce: jest.fn(fn => fn),\n  formatTime: jest.fn(t => `${Math.floor(t / 60)}:${String(t % 60).padStart(2, '0')}`)\n}));\n\njest.unstable_mockModule('../js/effects.js', () => ({\n  particleSystem: {\n    spawn: jest.fn()\n  }\n}));\n\n// Import UI module\nconst UI = await import('../js/ui.js');\n\ndescribe('UI Module - Advanced Features', () => {\n  let game;\n\n  beforeEach(() => {\n    // Mock Game state\n    game = {\n      board: Array(9).fill(null).map(() => Array(9).fill(null)),\n      phase: PHASES.PLAY,\n      turn: 'white',\n      capturedPieces: { white: [], black: [] },\n      moveHistory: [],\n      stats: {\n        totalMoves: 10,\n        playerMoves: 5,\n        playerBestMoves: 3,\n        captures: 2\n      },\n      replayMode: false,\n      replayPosition: -1,\n      savedGameState: null,\n      arrowRenderer: {\n        clearArrows: jest.fn(),\n        highlightMove: jest.fn()\n      },\n      tutorController: {\n        getTutorHints: jest.fn(() => []),\n        getSetupTemplates: jest.fn(() => []),\n        applySetupTemplate: jest.fn()\n      },\n      executeMove: jest.fn(),\n      calculateMaterialAdvantage: jest.fn(() => 5),\n      startClock: jest.fn(),\n      stopClock: jest.fn()\n    };\n\n    document.body.innerHTML = `\n            <div id=\"stat-moves\"></div>\n            <div id=\"stat-captures\"></div>\n            <div id=\"stat-accuracy\"></div>\n            <div id=\"stat-best-moves\"></div>\n            <div id=\"stat-material\"></div>\n            \n            <div id=\"tutor-panel\" class=\"hidden\"></div>\n            <div id=\"tutor-suggestions\"></div>\n            <div id=\"tutor-overlay\" class=\"hidden\">\n                <div id=\"tutor-hints-body\"></div>\n                <button id=\"close-tutor-btn\"></button>\n            </div>\n            \n            <div id=\"replay-status\" class=\"hidden\"></div>\n            <div id=\"replay-exit\" class=\"hidden\"></div>\n            <div id=\"replay-move-num\"></div>\n            <button id=\"replay-first\"></button>\n            <button id=\"replay-prev\"></button>\n            <button id=\"replay-next\"></button>\n            <button id=\"replay-last\"></button>\n            <button id=\"undo-btn\"></button>\n            \n            <div id=\"board-wrapper\"><div id=\"board\"></div></div>\n        `;\n\n    jest.clearAllMocks();\n  });\n\n  describe('updateStatistics', () => {\n    test('should update all statistical elements', () => {\n      UI.updateStatistics(game);\n\n      expect(document.getElementById('stat-moves').textContent).toBe('10');\n      expect(document.getElementById('stat-captures').textContent).toBe('0'); // 0 based on capturedPieces.length\n      expect(document.getElementById('stat-accuracy').textContent).toBe('60%');\n      expect(document.getElementById('stat-best-moves').textContent).toBe('3');\n      expect(document.getElementById('stat-material').textContent).toBe('+5');\n      expect(document.getElementById('stat-material').classList.contains('positive')).toBe(true);\n    });\n\n    test('should handle zero player moves for accuracy', () => {\n      game.stats.playerMoves = 0;\n      UI.updateStatistics(game);\n      expect(document.getElementById('stat-accuracy').textContent).toBe('--%');\n    });\n  });\n\n  describe('Replay Mode', () => {\n    test('enterReplayMode should save state and update UI', () => {\n      game.moveHistory = [{ from: { r: 6, c: 4 }, to: { r: 5, c: 4 } }];\n      UI.enterReplayMode(game);\n\n      expect(game.replayMode).toBe(true);\n      expect(game.replayPosition).toBe(0);\n      expect(game.savedGameState).toBeDefined();\n      expect(game.stopClock).toHaveBeenCalled();\n      expect(document.getElementById('replay-status').classList.contains('hidden')).toBe(false);\n    });\n\n    test('exitReplayMode should restore state and update UI', () => {\n      game.replayMode = true;\n      game.savedGameState = {\n        board: Array(9).fill(null).map(() => Array(9).fill(null)),\n        turn: 'white',\n        selectedSquare: null,\n        validMoves: null,\n        lastMoveHighlight: null\n      };\n      game._previousBoardState = Array(9).fill(null).map(() => Array(9).fill(null));\n\n      UI.exitReplayMode(game);\n\n      expect(game.replayMode).toBe(false);\n      expect(game.savedGameState).toBeNull();\n      expect(document.getElementById('replay-status').classList.contains('hidden')).toBe(true);\n    });\n\n    test('updateReplayUI should update button states', () => {\n      game.moveHistory = [1, 2, 3];\n      game.replayPosition = 1;\n      UI.updateReplayUI(game);\n\n      expect(document.getElementById('replay-move-num').textContent).toBe('2');\n      expect(document.getElementById('replay-first').disabled).toBe(false);\n      expect(document.getElementById('replay-last').disabled).toBe(false);\n\n      game.replayPosition = -1;\n      UI.updateReplayUI(game);\n      expect(document.getElementById('replay-first').disabled).toBe(true);\n\n      game.replayPosition = 2;\n      UI.updateReplayUI(game);\n      expect(document.getElementById('replay-last').disabled).toBe(true);\n    });\n  });\n\n  describe('Tutor Suggestions - Setup Templates', () => {\n    test('should show setup templates in setup phase', () => {\n      game.phase = PHASES.SETUP_WHITE_PIECES;\n      game.tutorController.getSetupTemplates.mockReturnValue([\n        { id: 'classic', name: 'Classic', description: 'desc', cost: 15, pieces: ['p'] }\n      ]);\n\n      UI.showTutorSuggestions(game);\n\n      const suggestions = document.getElementById('tutor-suggestions');\n      expect(suggestions.innerHTML).toContain('Classic');\n      expect(suggestions.innerHTML).toContain('Empfohlene Aufstellungen');\n    });\n\n    test('should apply template on click', () => {\n      window.confirm = jest.fn(() => true);\n      game.phase = PHASES.SETUP_WHITE_PIECES;\n      game.tutorController.getSetupTemplates.mockReturnValue([\n        { id: 'classic', name: 'Classic', description: 'desc', cost: 15, pieces: ['p'] }\n      ]);\n\n      UI.showTutorSuggestions(game);\n      const templateEl = document.querySelector('.setup-template');\n      templateEl.click();\n\n      expect(game.tutorController.applySetupTemplate).toHaveBeenCalledWith('classic');\n    });\n  });\n\n  describe('Tutor Suggestions - Gameplay Hints', () => {\n    beforeEach(() => {\n      game.getTutorHints = jest.fn(() => [\n        {\n          move: { from: { r: 6, c: 4 }, to: { r: 4, c: 4 } },\n          score: 150,\n          notation: 'e4',\n          analysis: {\n            category: 'excellent',\n            qualityLabel: 'Bester Zug',\n            tacticalExplanations: ['Gewinnt Zentrum'],\n            strategicExplanations: ['Entwickelt Springer'],\n            warnings: ['Vorsicht vor f7']\n          }\n        }\n      ]);\n    });\n\n    test('should render gameplay hints with analysis', () => {\n      UI.showTutorSuggestions(game);\n\n      const suggestions = document.getElementById('tutor-suggestions');\n      expect(suggestions.innerHTML).toContain('Bester Zug');\n      expect(suggestions.innerHTML).toContain('Gewinnt Zentrum');\n      expect(suggestions.innerHTML).toContain('Vorsicht vor f7');\n    });\n\n    test('should highlight move on click', () => {\n      UI.showTutorSuggestions(game);\n      const suggestion = document.querySelector('.tutor-suggestion');\n      suggestion.click();\n\n      expect(game.arrowRenderer.highlightMove).toHaveBeenCalled();\n      // Check for cell highlights\n      expect(document.querySelector('.cell.suggestion-highlight')).toBeDefined();\n    });\n\n    test('should execute move on \"Try This\" button click', () => {\n      UI.showTutorSuggestions(game);\n      const tryBtn = document.querySelector('.try-move-btn');\n      tryBtn.click();\n\n      expect(game.executeMove).toHaveBeenCalledWith({ r: 6, c: 4 }, { r: 4, c: 4 });\n      expect(document.getElementById('tutor-panel').classList.contains('hidden')).toBe(true);\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/ui.extra.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'BOARD_SIZE' is defined but never used.","line":2,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\nimport { PHASES, BOARD_SIZE } from '../js/config.js';\n\n// Setup JSDOM body \ndocument.body.innerHTML = `\n    <div id=\"board\"></div>\n    <div id=\"status-display\"></div>\n    <div id=\"points-display\"></div>\n    <div id=\"selected-piece-display\"></div>\n    <div id=\"clock-white\"></div>\n    <div id=\"clock-black\"></div>\n    <div id=\"game-over-overlay\" class=\"hidden\"><div id=\"winner-text\"></div><button id=\"restart-btn-overlay\"></button><button id=\"close-game-over-btn\"></button></div>\n    <div id=\"move-history\"></div>\n    <div id=\"captured-white\"></div>\n    <div id=\"captured-black\"></div>\n    <div id=\"shop-panel\" class=\"hidden\"></div>\n    <div id=\"promotion-overlay\" class=\"hidden\"><div id=\"promotion-options\"></div></div>\n    <div id=\"tutor-panel\" class=\"hidden\"></div>\n    <div id=\"replay-status\" class=\"hidden\"></div>\n    <div id=\"replay-exit\" class=\"hidden\"></div>\n    <div id=\"replay-move-num\"></div>\n    <button id=\"undo-btn\"></button>\n    <div id=\"tutor-suggestions\"></div>\n`;\n\n// Mock PIECE_SVGS\nglobal.window.PIECE_SVGS = {\n  white: { p: 'wp', n: 'wn', b: 'wb', r: 'wr', q: 'wq', k: 'wk', a: 'wa', c: 'wc', e: 'we' },\n  black: { p: 'bp', n: 'bn', b: 'bb', r: 'br', q: 'bq', k: 'bk', a: 'ba', c: 'bc', e: 'be' }\n};\nglobal.window._svgCache = {};\n\n// Mock sounds\njest.unstable_mockModule('../js/sounds.js', () => ({\n  soundManager: { playMove: jest.fn(), playCapture: jest.fn(), playGameOver: jest.fn() }\n}));\n\nconst UI = await import('../js/ui.js');\n\ndescribe('UI Final Precision V3', () => {\n  let game;\n\n  beforeEach(() => {\n    game = {\n      board: Array(9).fill(null).map(() => Array(9).fill(null)),\n      phase: PHASES.PLAY,\n      turn: 'white',\n      points: 15,\n      whiteTime: 300,\n      blackTime: 300,\n      stats: { totalMoves: 10, playerMoves: 5, playerBestMoves: 4, accuracy: 80, captures: 2 },\n      capturedPieces: { white: [], black: [] },\n      moveHistory: [],\n      positionHistory: [],\n      _previousBoardState: Array(9).fill(null).map(() => Array(9).fill(null)),\n      _forceFullRender: true,\n      calculateMaterialAdvantage: jest.fn(() => 5),\n      tutorController: { getSetupTemplates: () => [], getTutorHints: () => [] },\n      arrowRenderer: { highlightMove: jest.fn(), clearArrows: jest.fn() },\n      handleCellClick: jest.fn(),\n      getValidMoves: jest.fn(() => [])\n    };\n    game.board[0][0] = { type: 'k', color: 'white' };\n    jest.clearAllMocks();\n  });\n\n  test('Drag & Drop full cycle (Line 157-286)', () => {\n    UI.initBoardUI(game);\n    UI.renderBoard(game);\n    const cell = document.querySelector('.cell[data-r=\"0\"][data-c=\"0\"]');\n\n    // Mock Event\n    const createEvent = (type, data = {}) => {\n      const ev = new Event(type);\n      ev.dataTransfer = {\n        setData: jest.fn(),\n        getData: jest.fn(() => '0,0'),\n        setDragImage: jest.fn(),\n        effectAllowed: 'move',\n        dropEffect: 'move'\n      };\n      ev.preventDefault = jest.fn();\n      Object.assign(ev, data);\n      return ev;\n    };\n\n    cell.dispatchEvent(createEvent('dragstart'));\n    cell.dispatchEvent(createEvent('dragover'));\n    cell.dispatchEvent(createEvent('dragleave'));\n    cell.dispatchEvent(createEvent('drop'));\n    cell.dispatchEvent(createEvent('dragend'));\n  });\n\n  test('updateStatus - GAME_OVER branch (Line 1159)', () => {\n    game.phase = PHASES.GAME_OVER;\n    game.result = 'white';\n    UI.updateStatus(game);\n    expect(document.getElementById('status-display').textContent).toContain('Wei hat gewonnen');\n  });\n\n  test('updateClockDisplay - zero time fixed', () => {\n    game.whiteTime = 0;\n    UI.updateClockDisplay(game);\n    expect(document.getElementById('clock-white').textContent).toBe('0:00');\n  });\n\n  test('updateClockUI - low time warning (Line 1120)', () => {\n    game.whiteTime = 10;\n    UI.updateClockUI(game);\n    expect(document.getElementById('clock-white').classList.contains('low-time')).toBe(true);\n  });\n\n  test('renderBoard - highlights sweep', () => {\n    game.lastMoveHighlight = { from: { r: 0, c: 0 }, to: { r: 0, c: 1 } };\n    game.selectedSquare = { r: 0, c: 0 };\n    UI.renderBoard(game);\n    // Cover Line 310 etc.\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/ui.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/tobber/.gemini/antigravity/scratch/schach/tests/utils.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"linebreak-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
